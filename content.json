{"meta":{"title":"Xiho’s Blog","subtitle":null,"description":"Android Developer","author":"Xiho","url":"https://xuhaoblog.com"},"pages":[{"title":"About","date":"2017-05-31T02:05:56.000Z","updated":"2017-11-03T18:21:25.000Z","comments":true,"path":"about/index.html","permalink":"https://xuhaoblog.com/about/index.html","excerpt":"","text":"about 待完善～～～"},{"title":"Categories","date":"2017-11-04T05:37:31.000Z","updated":"2017-11-04T05:38:04.000Z","comments":true,"path":"categories/index.html","permalink":"https://xuhaoblog.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-04T05:34:52.000Z","updated":"2017-11-04T05:37:04.000Z","comments":true,"path":"tags/index.html","permalink":"https://xuhaoblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 开源项目 Kotlin+Mvp+RxJava+Retrofit架构开发的短视频APP","slug":"android-kotlin-mvp","date":"2017-12-09T15:20:24.000Z","updated":"2017-12-10T15:42:29.000Z","comments":true,"path":"2017/12/09/android-kotlin-mvp/","link":"","permalink":"https://xuhaoblog.com/2017/12/09/android-kotlin-mvp/","excerpt":"KotlinMvp GitHub地址：https://github.com/git-xuhao/KotlinMvp （开源不易，如果喜欢的话希望给个 Star 或者 Fork，谢谢！） 《KotlinMvp》 是仿着“开眼Eyepetizer”之前版本并加上自己的想法，开发的一款的短视频小应用，每日为你推荐精选视频，让你大开眼界。本项目采用 Kotlin 语言编写，结合 MVP+RxJava2+Retrofit2+Glide等的架构设计，学习 Kotlin 利用空余时间开发的一款小项目，代码结构清晰有详细注释，如有任何疑问和建议请提 Issue或联系","text":"KotlinMvp GitHub地址：https://github.com/git-xuhao/KotlinMvp （开源不易，如果喜欢的话希望给个 Star 或者 Fork，谢谢！） 《KotlinMvp》 是仿着“开眼Eyepetizer”之前版本并加上自己的想法，开发的一款的短视频小应用，每日为你推荐精选视频，让你大开眼界。本项目采用 Kotlin 语言编写，结合 MVP+RxJava2+Retrofit2+Glide等的架构设计，学习 Kotlin 利用空余时间开发的一款小项目，代码结构清晰有详细注释，如有任何疑问和建议请提 Issue或联系 项目截图 下载体验点击 或者扫描下方二维码 技术要点主要使用的第三方开源框架有： RxJava RxAndroid Retrofit Glide Logger FlycoTabLayout Flexbox-layout RealtimeBlurView SmartRefreshLayout BGABanner-Android GSYVideoPlayer 模块说明： 每日精选：首页采用下拉刷新+RecyclerView 实现，Banner展示每日精选推荐的视频，监听 RecyclerView 的滑动事件，实现 TitleBar 的隐藏显示功能，底部菜单采用高斯模糊的半透明效果，使整个 APP 风格更加清爽。 发现： 包括关注和分类模块，关注是推荐的作者上传的视频，分类包括时尚、运动、创意、广告、音乐、旅行、生活、记录、开胃、游戏、萌宠、动画、综艺、搞笑等可自由选择想查看的类型视频。 热门： 热门排行榜包括周排行、月排行、总排行的视频列表。 搜索： 根据关键字搜索榜你找到感兴趣的视频。 我的： 个人主页的相关介绍。 更新日志v1.0 初始化版本，主要功能已经完成。 关于我 Email: igeekho@gmail.com Home: https://xuhaoblog.com CSDN:http://blog.csdn.net/u011974987 简书: http://www.jianshu.com/u/25bc3e1e7595 Thanks 感谢所有优秀的开源项目 Eyepetizer ：最初是看了这个项目才开始做的，学了不少东西，写出了我自己的代码风格 声明项目中的 API 均来自开眼视频，纯属学习交流使用，不得用于商业用途！ LICENSE12345678910111213Copyright 2017 XihoLicensed under the Apache License, Version 2.0 (the \"License\");you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.","categories":[{"name":"开源项目","slug":"开源项目","permalink":"https://xuhaoblog.com/categories/开源项目/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://xuhaoblog.com/tags/Kotlin/"}]},{"title":"Android 中取得当前时区和语言","slug":"Android-getdate-language","date":"2016-10-20T10:05:00.000Z","updated":"2017-11-04T10:54:59.000Z","comments":true,"path":"2016/10/20/Android-getdate-language/","link":"","permalink":"https://xuhaoblog.com/2016/10/20/Android-getdate-language/","excerpt":"国际化需求，要访问当地的时区和语言，作为参数上传服务器处理一些业务，Android手机中如果想以GMT形式（GMT+08:00）得到当前时区，如下的工具类做个记录：","text":"国际化需求，要访问当地的时区和语言，作为参数上传服务器处理一些业务，Android手机中如果想以GMT形式（GMT+08:00）得到当前时区，如下的工具类做个记录：1234567891011121314151617181920212223242526272829303132333435/** * 时区语言工具类 * @author Xiho * */public class I18NUtils &#123; /** * 获取当前时区 * @return */ public static String getCurrentTimeZone() &#123; TimeZone tz = TimeZone.getDefault(); String strTz = tz.getDisplayName(false, TimeZone.SHORT); return strTz; &#125; /** * 获取当前系统语言格式 * @param mContext * @return */ public static String getCurrentLanguage(Context mContext)&#123; Locale locale =mContext.getResources().getConfiguration().locale; String language=locale.getLanguage(); String country = locale.getCountry(); String lc=language+\"_\"+country; return lc; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"}]},{"title":"AndroidStudio 2.2 的支持NDK","slug":"ndk/jni-5","date":"2016-10-19T03:42:00.000Z","updated":"2017-12-17T04:55:00.000Z","comments":true,"path":"2016/10/19/ndk/jni-5/","link":"","permalink":"https://xuhaoblog.com/2016/10/19/ndk/jni-5/","excerpt":"前言之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，觉得还挺好用的，Eclipse 是一个吃内存的IDE，反正我每次打开，编写代码的时候就会卡，有时候还是死掉，已无力吐糟~~，AndroidStudio的界面更人性化，除此之外，还有更多的功能。所以决定把之前在正在eclipse上开发的一个使用NDK开发的android项目转移到AndroidStudio上，在2.2之前对C/C++ 支持不是很友好，没有语法提示，编译也不方便等问题，所以期待了的Android Studio 2.2 版本稳定版终于在前段发布，一直未来得及尝试，今天把整个过程记下来，希望能给你有所帮助。 参考文献：https://developer.android.com/studio/projects/add-native-code.html#create-sources","text":"前言之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，觉得还挺好用的，Eclipse 是一个吃内存的IDE，反正我每次打开，编写代码的时候就会卡，有时候还是死掉，已无力吐糟~~，AndroidStudio的界面更人性化，除此之外，还有更多的功能。所以决定把之前在正在eclipse上开发的一个使用NDK开发的android项目转移到AndroidStudio上，在2.2之前对C/C++ 支持不是很友好，没有语法提示，编译也不方便等问题，所以期待了的Android Studio 2.2 版本稳定版终于在前段发布，一直未来得及尝试，今天把整个过程记下来，希望能给你有所帮助。 参考文献：https://developer.android.com/studio/projects/add-native-code.html#create-sources 正文1. 下载开发工具和NDK（windows10 64位环境） Android Studio 2.2 的NDK开发支持 CMake和ndk-build两种方式，默认的是CMake编译的，编译和调试需要下载安装以下组件： AndroidStudio 官网下载地址： Android Studio 2.2 （需要梯子） 推荐一个国内的镜像网站： http://www.androiddevtools.cn （身为开发者都应该知道，O(∩_∩)O） 下载最新版的 Android Studio 2.2 ： Download （点击下载） 下载NDK：android-ndk-r12b-windows-x86_64 CMake： Android Studio 默认使用 CMake 编译原生库，如果你只打算用ndk-build来编译的话，你就不需要这个组件。 LLDB： 使用它来调试本地代码。 注意：要在 Android Studio 中使用 CMake 或者 ndk-build，你需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。 你可以使用 SDK Manager 来安装上述组件： 已安装的软件包如有更新，其旁边的复选框中会显示短划线 打开一个项目，从菜单栏中选择 Tools &gt; Android &gt; SDK Manager 。 点击 SDK Tools 选项卡。 勾选 LLDB，CMake 和 NDK 。如图一： 点击 Apply ，然后点击 OK 。 当安装完成后，点击 Finish ，然后点击 OK 。 创建支持Native Code新项目创建一个支持 native code 的项目和创建普通的 Android studio 工程很像。但是有几点需要留意的地方： 在 Configure your new project 选项中，勾选 Include C++ Support 选项。 点击 Next，后面的流程和创建普通的 Android studio 工程一样。 在 Customize C++ Support 选项卡中。你有下面几种方式来自定义你的项目： C++ Standard ：点击下拉框，可以选择标准 C++，或者选择默认 CMake 设置的 Toolchain Default 选项。 Exceptions Support ：如果你想使用有关 C++ 异常处理的支持，就勾选它。勾选之后，Android Studio 会在 module 层的 build.gradle 文件中的 cppFlags 中添加 -fexcetions 标志。 Runtime Type Information Support ：如果你想支持 RTTI，那么就勾选它。勾选之后，Android Studio 会在 module 层的 build.gradle 文件中的 cppFlags 中添加 -frtti 标志。 点击 “Finish”。 当 Android Studio 完成新项目创建后，打开 Project 面板，选择 Android 视图。Android Studio 会添加 cpp 和 External Build Files 文件夹。 cpp 文件夹存放你所有 native code 的地方，包括源码，头文件，预编译项目等。对于新项目，Android Studio 创建了一个 C++ 模板文件： native-lib.cpp ，并且将该文件放到了你的 app 模块的 src/main/cpp/ 目录下。这份模板代码提供了一个简答的 C++ 函数： stringFromJNI() ，该函数返回一个字符串：”Hello from C++”。 External Build Files 文件夹是存放 CMake 或 ndk-build 构建脚本的地方。有点类似于 build.gradle 文件告诉 Gradle 如何编译你的 APP 一样，CMake 和 ndk-build 也需要一个脚本来告知如何编译你的 native library。对于一个新的项目，Android Studio 创建了一个 CMake 脚本： CMakeLists.txt ，并且将其放到了你的 module 的根目录下。 编译运行示例 APP当你点击 Run 按钮，Android Studio 会编译并启动一个 APP ，然后在 APP 中显示一段文字”Hello from C++”。 从编译到运行示例 APP 的流程简单归纳如下： Gradle 调用外部构建脚本，也就是 CMakeLists.txt 。 CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是 native-lib.cpp ，并将编译后的产物扔进共享对象库中，并将其命名为 libnative-lib.so ，然后 Gradle 将其打包到 APK 中。 在运行期间，APP 的 MainActivity 会调用 System.loadLibrary() 方法，加载 native library。而这个库的原生函数， stringFromJNI() ，就可以为 APP 所用了。 MainActivity.onCreate() 方法会调用 stringFromJNI() ，然后返回 “Hello from C++”，并更新 TextView 的显示。 注意： Instant Run 并不兼容使用了 native code 的项目。Android Studio 会自动禁止 InstantRun 功能。 如果你想验证一下 Gradle 是否将 native library 在APK中是否存在，你可以使用 APK Analyzer: 1231. 选择 Build &gt; Analyze APK 。2. 从 app/build/outputs/apk/ 路径中选择 APK，并点击 OK 。3. 如下图，在 APK Analyzer 窗口中，选择 lib/&lt;ABI&gt;/ ，你就可以看见 libnative-lib.so 。 将 C/C++ 代码添加到现有的项目中如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤： 创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。 创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。 将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。 一旦你配置好了你的项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击 Run 按钮，就可以编译运行你的 APP 了。 创建新的 native source 文件请按照下面的方法来创建一个 cpp/ 文件夹和源文件（native source files）： 打开IDE左边的 Project 面板，选择 Project 视图。 找到你项目的 module &gt; src 目录，右键点击 main 文件夹，选择 New &gt; Directory 。 输入文件夹的名字（比如 cpp），然后点击 OK 。 右键点击刚才创建好的文件夹，选择 New &gt; C/C++ Source File 。 输入文件名，比如 native-lib 。 在 Type 菜单下拉选项中，选择源文件的扩展后缀名，比如 .cpp 。 如果你也想创建一个头文件，点击 Create an associated header 选项框。 点击 OK 。 创建 CMake 构建脚本如果没有一个 CMake 构建脚本，你需要自己手动创建一个，并添加一些合适的 CMake 命令。CMake 构建脚本是一个空白的文本文档（后缀为 .txt 的文件），名字必须为 CMakeLists.txt 。 注意：如果你的项目使用了 ndk-build，你就不需要创建 CMake 构建脚本，只需要提供一个路径链，将你的 Android.mk文件链接到 Gradle 中即可。 将一个空白的文本文档变成一个 CMake 构建脚本，你需要这么做： 打开 IDE 左边的 Project 面板，选择 Project 视图。 在你的 module 根目录下，右键，选择 New &gt; File 。 输入 “CMakeLists.txt” 作为文件名，并点击 OK 。 现在，你可以添加 CMake 命令来配置你的构建脚本了。为了让 CMake 将源代码（native source code）编译成 native library。需要在编译文件中添加 cmake_minimum_required() 和 add_library() 命令： 123456789101112131415161718# 设置建立你的本地库所需的CMake的最低版本。# 这为了确保某些功能在你构建的时候是可用的。cmake_minimum_required(VERSION 3.4.1)# 指定库名# 并提供源代码的相对路径. # 你可以通过add.library()命令定义多个库,CMake会去构建他们，# 当你构建App 的时候，Gradle 会自动把库打包到你的apk 中add_library( # Specifies the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp ) 当你使用 add_library() ，将一个源文件（source file）或库添加到你的 CMake 构建脚本，同步你的项目，然后你会发现 Android studio 将关联的头文件也显示了处理。然而，为了让 CMake 在编译时期能定位到你的头文件，你需要在 CMake 构建脚本中添加 include_directories() 命令，并指定头文件路径： 1234add_library(...)# Specifies a path to native header files.include_directories(src/main/cpp/include/) CMake的使用命名库的文件的约定下面的形式： 1lib*library-name*.so 例如 ，如果你在构建脚本中，将 library 命名为 “native-lib”，那么 CMake 会创建叫 libnative-lib.so 的文件。但是，当你将 library 加载到 Java 代码中的时候， 你需要使用在 CMake 中指定的名称： 123static &#123; System.loadLibrary(“native-lib”);&#125; 注意：如果你将 CMake 脚本里面的 library 重命名了，或者移除了。你需要清理一下你的工程。在 IDE 的菜单栏中选择 Build &gt; Clean Project 。 Android Studio 会在 Project 面板中的 cpp 文件夹中自动添加源文件和头文件。你可以多次使用 add_library() 命令，来添加额外的 library。 添加 NDK APIsAndroid NDK 提供了一些有用的 native APIs。将 NDK librarys 添加到 CMakeLists.txt 脚本文件中，就可以使用这些 API 了。 预编译的 NDK librarys 已经存在在 Android 平台中了，所以你不需要编译它们，或者是将其打包到你的 APK 中。因为这些 NDK librarys 已经是 CMake 搜索路径的一部分，你甚至不需要提供你本地安装的 NDK 路径。你只需要向 CMake 提供你想使用的 library 名字。 将 find_library() 命令添加到你的 CMake 构建脚本中，这样就可以定位 NDK library 的位置，并将其位置存储在一个变量之中。你可以在构建脚本的其他地方使用这个变量，来代指 NDK library。下面的示例代码将 Android-specific log support library 的位置存储到变量 log-lib 中： 1234567find_library( # Defines the name of the path variable that stores the # location of the NDK library. log-lib # Specifies the name of the NDK library that # CMake needs to locate. log ) NDK 同样也包含一些只包含源码的 library，这些就需要你去编译，然后链接到你的本地库（native library）。你可以在 CMake 构建脚本中使用 add_library() 命令将源码编译进本地库。这时就需要提供你的本地 NDK 安装路径，通常将该路径保存在 ANDROID_NDK 变量中，这样 Android Studio 可以自动为你定义。 下面的命令告诉 CMake 去构建 android_native_app_glue.c ，这个命令可以管理 NativeActivity 的生命周期以及点击输入，并将其导入静态库中，然后将其链接至 native-lib ： 123456add_library( app-glue STATIC $&#123;ANDROID_NDK&#125;/sources/android/native_app_glue/android_native_app_glue.c )# You need to link static libraries against your shared native library.target_link_libraries( native-lib app-glue $&#123;log-lib&#125; ) 添加其他的预编译库添加预编译库和添加本地库（native library）类似。由于预编译库是已经构建好的，你想就要使用 IMPORTED 标志去告诉 CMake ，你只需要将其导入到你的项目中即可： add_library( imported-lib SHARED IMPORTED )然后你需要使用 set_target_properties() 命令去指定库的路径，就像下面的代码那样。 一些库会根据不同的 CPU 使用不同的包，或者是 Application Binary Interfaces(ABI) ，并且将他们归类到不同的目录中。这样做的好处是，可以充分发挥特定的 CPU 架构。你可以使用 ANDROID_ABI 路径变量，将多个 ABI 版本的库添加到你的 CMake 构建脚本中。这个变量使用了一些 NDK 默认支持的 ABI，以及一些需要手动配置到 Gradle 的 ABI，比如： 123456789add_library(...)set_target_properties( ＃指定目标库。 imported-lib ＃指定要定义的参数。 PROPERTIES IMPORTED_LOCATION ＃提供的路径，你要导入的库。 imported-lib/src/$&#123;ANDROID_ABI&#125;/libimported-lib.so ) 为了让 CMake 在编译时期能找到你的头文件，你需要使用 include_directories() 命令，并且将你的头文件地址传进去： 1include_directories( imported-lib/include/ ) 在 CMake 构建脚本中使用 target_link_libraries() 命令，将预构建库与你本地库相关联： 1target_link_libraries( native-lib imported-lib app-glue $&#123;log-lib&#125; ) 当你构建你的 APP 的时候，Gradle 会自动将导入的库打包到你的 APK 中。你可以使用 APK Analyzer 来检查。有关CMake的命令的详细信息，请参阅CMake的文档。 关联本地库与 Gradle为了将本地库与 Gradle 相关联，你需要在 CMake 或 ndk-build 构建脚本中提供一个路径地址。当你构建你的 APP 时，Gradle 会将 CMake 或 ndk-build 作为一个依赖运行，然后将共享库（.so 文件）打包到你的 APK 中。Gradle 同样使用构建脚本来识别哪些文件需要导入到 Android Studio 项目，你可以从 Project 窗口面板中看到相应的文件。如果你还没有一个为 native sources 准备的构建脚本，你需要先创建一个CMake脚本，然后在继续。 一旦你使用Gradle关联了本地项目，AndroidStudio会在窗口更新项目的C/C++源文件和本地库，和你外部构建的脚本文件。 注意： 当你改变Gradle配置的时候，请确保在工具栏中点击Sync Project 使用 Android Studio 图形化界面你可以使用 Android Studio 的图形化界面来将 Gradle 与外部 CMake 或者 ndk-build 项目关联起来。 打开 IDE 左边的 Project 面板，选择 Android 。 右键点击你想链接本地库的 module，比如 app module，然后从菜单中选择 Link C++ Project with Gradle 。你应该能看见一个和下面图片中的对话框。 在下拉菜单中，选择 CMake 或者 ndk-build 。a. 如果你选择 CMake ，需要在 Project Path 中指定 CMakeLists.txt 脚本文件的路径。b. 如果你选择 ndk-build ，你需要在 Project Path 中指定 Android.mk 脚本文件的路径。 点击 OK。 配置 Gradle如果要手动将 Gradle 与你的本地库相关联，你需要在 module 层级的 build.gradle 文件中添加 externalNativeBuild {} 代码块，并且在该代码块中配置 cmake {} 或 ndkBuild {} ： 12345678910111213141516android &#123; ... defaultConfig &#123;...&#125; buildTypes &#123;...&#125; // Encapsulates your external native build configurations. externalNativeBuild &#123; // Encapsulates your CMake build configurations. cmake &#123; // Provides a relative path to your CMake build script. path \"CMakeLists.txt\" &#125; &#125;&#125; 可选配置你可以在你的 module 层级的 build.gradle 文件中的 defaultConfig {} 代码块中，添加 externalNativeBuild {} 代码块，为 CMake 或 ndk-build 配置一些额外参数。当然，你也可以在你的构建配置中的其他每一个生产渠道重写这些属性。 比如，如果你的 CMake 或者 ndk-build 项目中定义了多个本地库，你想在某个生产渠道使用这些本地库中的几个，你就可以使用 targets 属性来构建和打包。下面的代码展示了一些你可能会用到的属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960android &#123; ... defaultConfig &#123; ... // This block is different from the one you use to link Gradle // to your CMake or ndk-build script. externalNativeBuild &#123; // For ndk-build, instead use ndkBuild &#123;&#125; cmake &#123; // Passes optional arguments to CMake. arguments \"-DCMAKE_VERBOSE_MAKEFILE=TRUE\" // Sets optional flags for the C compiler. cFlags \"-D_EXAMPLE_C_FLAG1\", \"-D_EXAMPLE_C_FLAG2\" // Sets a flag to enable format macro constants for the C++ compiler. cppFlags \"-D__STDC_FORMAT_MACROS\" &#125; &#125; &#125; buildTypes &#123;...&#125; productFlavors &#123; ... demo &#123; ... externalNativeBuild &#123; cmake &#123; ... // Specifies which native libraries to build and package for this // product flavor. If you don't configure this property, Gradle // builds and packages all shared object libraries that you define // in your CMake or ndk-build project. targets \"native-lib-demo\" &#125; &#125; &#125; paid &#123; ... externalNativeBuild &#123; cmake &#123; ... targets \"native-lib-paid\" &#125; &#125; &#125; &#125; // You use this block to link Gradle to your CMake or ndk-build script. externalNativeBuild &#123; cmake &#123;...&#125; // or ndkBuild &#123;...&#125; &#125;&#125;---------- 指定 ABI默认的情况下，Gradle 会将你的本地库构建成 .so 文件，然后将其打包到你的 APK 中。如果你想 Gradle 构建并打包某个特定的 ABI 。你可以在你的 module 层级的 build.gradle 文件中使用 ndk.abiFilters 标签来指定他们： 1234567891011121314151617181920android &#123; ... defaultConfig &#123; ... externalNativeBuild &#123; cmake &#123;...&#125; // or ndkBuild &#123;...&#125; &#125; ndk &#123; // Specifies the ABI configurations of your native // libraries Gradle should build and package with your APK. abiFilters 'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'arm64-v8a' &#125; &#125; buildTypes &#123;...&#125; externalNativeBuild &#123;...&#125; //&#125; 大多数情况，你只需要在 ndk {} 代码块中指定 abiFilters 就可以了；如上代码。它会告诉Gradle来构建编译不同的平台，但是，如果你想控制 Gradle 构建什么，独立打包到你的apk中，那就在defaultConfig.externalNativeBuild.cmake {} 代码块或 defaultConfig.externalNativeBuild.ndkBuild {} 代码块中，配置其他的 abiFilters 标签。Gradle 会构建那些 ABI 配置，但是只会将 defaultConfig.ndk {} 代码块中指定的配置打包到 apk 中。 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/categories/NDK开发/"}],"tags":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/tags/NDK开发/"},{"name":"jni","slug":"jni","permalink":"https://xuhaoblog.com/tags/jni/"}]},{"title":"Android NDK 开发（四）JNI 中局部引用、全局引用和弱全局引用","slug":"ndk/jni-4","date":"2016-10-18T06:54:00.000Z","updated":"2017-11-04T11:15:57.000Z","comments":true,"path":"2016/10/18/ndk/jni-4/","link":"","permalink":"https://xuhaoblog.com/2016/10/18/ndk/jni-4/","excerpt":"前言做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃圾回收器在处理这些事情就行了，然而，从Java虚拟机创建的对象传到C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不回触发该引用所指向Java对象的垃圾回收；这些引用在JNI 中分为3种：全局引用（Global Reference）、局部引用 (Local Reference)、弱全局引用 (Week Global Reference) since JDK1.2。 正文三种引用的区别1、全局引用全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部引用不同的是，没有那么多函数能够创建全局引用。能创建全局引用的函数只有 NewGlobalRef。以下例子说明了如何使用一个全局引用。 java native方法： 12345public native void createGlobalRef();public native String getGlobalRef();public native void deleteGlobalRef();","text":"前言做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃圾回收器在处理这些事情就行了，然而，从Java虚拟机创建的对象传到C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不回触发该引用所指向Java对象的垃圾回收；这些引用在JNI 中分为3种：全局引用（Global Reference）、局部引用 (Local Reference)、弱全局引用 (Week Global Reference) since JDK1.2。 正文三种引用的区别1、全局引用全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部引用不同的是，没有那么多函数能够创建全局引用。能创建全局引用的函数只有 NewGlobalRef。以下例子说明了如何使用一个全局引用。 java native方法： 12345public native void createGlobalRef();public native String getGlobalRef();public native void deleteGlobalRef(); jni实现：12345678910111213141516171819//全局引用//共享(可以跨多个线程)，手动控制内存使用jstring global_str;//创建JNIEXPORT void JNICALL Java_com_study_jni_JniTest_createGlobalRef(JNIEnv *env, jobject jobj)&#123; jstring obj = (*env)-&gt;NewStringUTF(env, \"jni development is powerful!\"); global_str = (*env)-&gt;NewGlobalRef(env, obj);&#125;//获得JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getGlobalRef(JNIEnv *env, jobject jobj)&#123; return global_str;&#125;//释放JNIEXPORT void JNICALL Java_com_study_jni_JniTest_deleteGlobalRef(JNIEnv *env, jobject jobj)&#123; (*env)-&gt;DeleteGlobalRef(env, global_str);&#125; 2、局部引用一个局部引用仅在创建它的native函数及该函数调用的函数中有效。在一个native函数执行期间创建的所有局部引用将在该函数返回时被释放，创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性。 1234567891011121314151617//模拟：循环创建数组JNIEXPORT void JNICALL Java_com_study_jni_JniTest_localRef(JNIEnv *env, jobject jobj)&#123; int i = 0; for (; i &lt; 5; i++)&#123; //创建Date对象 jclass cls = (*env)-&gt;FindClass(env, \"java/util/Date\"); jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, \"&lt;init&gt;\", \"()V\"); jobject obj = (*env)-&gt;NewObject(env, cls, constructor_mid); //此处省略一百行代码... //不在使用jobject对象了 //通知垃圾回收器回收这些对象 //释放局部引用 (*env)-&gt;DeleteLocalRef(env, obj); //此处省略一百行代码... &#125;&#125; 上面代码中，省略了和我们无关紧要的代码，通过FindClass返回一个对java.util.Date对象的局部引用。 3、弱全局引用节省内存，在内存不足时可以是释放所引用的对象，可以引用一个不常用的对象，如果为NULL，临时创建，弱全局引用使用NewGlobalWeakRef创建，使用DeleteGlobalWeakRef释放。下面简称弱引用。与全局引用类似，弱引用可以跨方法、线程使用。但与全局引用很重要不同的一点是，弱引用不会阻止GC回收它引用的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。 1.创建弱全局引用用NewWeakGlobalRef函数对弱全局引用进行初始化，例如： 12jclass weakGlobalclsweakGlobalcls = (*env)-&gt;NewWeakGlobalRef(env,localclazz); 2.引用的比较给定两个引用（不管是全局、局部还是弱全局引用），我们只需要调用IsSameObject来判断它们两个是否指向相同的对象。例如：（*env)-&gt;IsSameObject(env, obj1, obj2)如果obj1和obj2指向相同的对象，则返回JNI_TRUE（或者1），否则返回JNI_FALSE（或者0）。有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象。如果obj是一个局部或全局引用，使用(*env)-&gt;IsSameObject(env, obj, NULL) 或者 obj == NULL 来判断obj是否指向一个null对象即可。但需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。比如： 12345if(JNI_FALSE == (*env)-&gt;IsSameObject(env,weakGlobalcls,NULL))&#123;//TODO 对象未被回收，可以使用&#125;else&#123;//TODO 对象被垃圾回收器回收，不能使用&#125; 以上就是学习这jni 的三种引用的简单使用，相关的知识并没有深入详细的说明！O(∩_∩)O~~ 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/categories/NDK开发/"}],"tags":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/tags/NDK开发/"},{"name":"jni","slug":"jni","permalink":"https://xuhaoblog.com/tags/jni/"}]},{"title":"Android NDK开发（三）C访问Java属性和方法","slug":"ndk/jni-3","date":"2016-10-06T14:30:31.000Z","updated":"2017-11-04T11:15:37.000Z","comments":true,"path":"2016/10/06/ndk/jni-3/","link":"","permalink":"https://xuhaoblog.com/2016/10/06/ndk/jni-3/","excerpt":"前言native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~","text":"前言native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~ 正文继 Android NDK 开发（二）JNI 传递参数和返回值之后。 1.访问类方法初始化了Java虚拟机后，就可以开始调用Java的方法。要调用一个Java对象的方法必须经过几个步骤： 1.1获取指定对象的类定义（jclass）有两种方式来获取对象的类定义：第一种是在已知类名的情况下使用FindClass来查找对应的类。但是要注意类名并不同于平时写的Java代码，例如要得到类jni.test.Demo的定义必须调用如下代码： 1jclass cls = (*env)-&gt;FindClass(env, \"jni/test/Demo\"); //把点号换成斜杠 第二种是通过对象直接得到其所对应的类定义： 1jclass cls = (*env)-&gt; GetObjectClass(env, obj); //其中obj是要引用的对象，类型是jobject 1.2读取要调用方法的定义我们先来看看JNI中获取方法定义的函数： 123456jmethodID (JNICALL *GetMethodID)(JNIEnv *env, jclass clazz, const char *name, const char *sig); jmethodID (JNICALL *GetStaticMethodID)(JNIEnv *env, jclass class, const char *name, const char *sig); 这两个函数的区别明显都能猜到，GetStaticMethodID 是用来获取静态方法的定义，而GetMethodID 则是获取非静态的方法定义。 这两个函数都需要提供四个参数： 第一个参数env 就是初始化虚拟机得到的jni环境； 第二个参数class 是对象的类定义，也就是第一步得到的obj； 第三个参数是方法名称； 第四个参数是最重要德，这个参数是方法的定义。 因为我们知道Java中允许方法的多态，仅仅是通过方法名是没有办法定位到一个具体的方法，因此就需要第 四个参数来指定方法的具体定义（也就是所谓的签名）；但是怎么利用一个字符串来表示方法的具体定义呢？JDK中已经准备好一个反编译工具javap。 通过这个工具就可以得到类 中每个属性、方法的定义。下面就来看看jni.test.Demo的定义： 打开命令行窗口进入到项目目录德的bin目录下，并运行 javap -s -p jni.test.Demo 得到运行结果如下： 从上图中，我们看到类中每个属性和方法下面都有一段注释。注释中不包含空格的内容就是第四个参数要填的内容。基本数据的签名如下： 下面这段代码将调用accessConstructor（）的方法。 1234567891011121314151617//访问构造方法//使用java.util.Date产生一个当前的时间戳JNIEXPORT jobject JNICALL Java_com_dongnaoedu_jni_JniTest_accessConstructor(JNIEnv *env, jobject jobj)&#123; jclass cls = (*env)-&gt;FindClass(env, \"java/util/Date\"); //jmethodID jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, \"&lt;init&gt;\", \"()V\"); //实例化一个Date对象 jobject date_obj = (*env)-&gt;NewObject(env, cls, constructor_mid); //调用getTime方法 jmethodID mid = (*env)-&gt;GetMethodID(env, cls, \"getTime\", \"()J\"); jlong time = (*env)-&gt;CallLongMethod(env, date_obj, mid); printf(\"\\ntime:%lld\\n\",time); return date_obj;&#125; 在java 端调用 1t.accessConstructor(); 运行结果： 1.3 调用方法为了调用对象的某个方法，可以使用函数 1Call&lt;TYPE&gt;Method或者 CallStatic&lt;TYPE&gt;Method（访问类的静态方法）， &lt; TYPE&gt;根据不同的返回类型而定。这些方法都是使用可 变参数的定义，如果访问某个方法需要参数时，只需要把所有参数按照顺序填写到方法中就可以。在讲到构造函数的访问时，将演示如何访问带参数的构造函数。 2.访问类属性2.1 获取指定对象的类（jclass） 这一步，与访问类方法完全一样，具体就参考上面德步骤吧~ 2.2 读取类属性的定义（jfieldID）在JNI中是这样定义获取类属性的方法的： 123456jfieldID (JNICALL *GetFieldID)(JNIEnv *env, jclass clazz, const char *name, const char *sig); jfieldID (JNICALL *GetStaticFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig); 这两个函数中第一个参数为JNI环境；clazz为类的定义；name为属性名称；第四个参数同样是为了表达属性的类型。前面我们使用javap工具获取类的详细定义的时候有这样两行： public java.lang.String key;/ Ljava/lang/String; / 其中第二行注释的内容就是第四个参数要填的信息，这跟访问类方法时是相同的。 2.3 读取和设置属性值有了属性的定义要访问属性值就很容易了。有几个方法用来读取和设置类的属性，它们是：Get&lt;TYPE&gt;Field、 Set&lt;TYPE&gt;Field、GetStatic&lt;TYPE&gt;Field、 SetStatic&lt;TYPE&gt;Field。比如读取Demo类的key属性就可以用GetFieldID，相关代码如下： java调用代码： 12345678910111213//属性public String key = \"xuhao\"; //访问属性，返回修改之后的属性内容public native String accessField();public static void main(String[] args) &#123; JniTest t = new JniTest(); System.out.println(\"key修改前：\"+t.key); t.accessField(); System.out.println(\"key修改后：\"+t.key); &#125; 本地方法实现： 123456789101112131415161718192021222324252627282930313233343536//C/C++访问Java的成员//1.访问属性//修改属性keyJNIEXPORT jstring JNICALL Java_com_dongnaoedu_jni_JniTest_accessField(JNIEnv *env, jobject jobj)&#123; //jobj是t对象，JniTest.class jclass cls = (*env)-&gt;GetObjectClass(env, jobj); //jfieldID //属性名称，属性签名 jfieldID fid = (*env)-&gt;GetFieldID(env, cls, \"key\", \"Ljava/lang/String;\"); //xuhao &gt;&gt; super xuhao //获取key属性的值 //Get&lt;Type&gt;Field jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid); printf(\"jstr:%#x\\n\",&amp;jstr); //jstring -&gt; c字符串 //isCopy 是否复制（true代表赋值，false不复制） char *c_str = (*env)-&gt;GetStringUTFChars(env,jstr,JNI_FALSE); //拼接得到新的字符串 char text[20] = \"super \"; strcat(text,c_str); //c字符串 -&gt;jstring jstring new_jstr = (*env)-&gt;NewStringUTF(env, text); //修改key //Set&lt;Type&gt;Field (*env)-&gt;SetObjectField(env, jobj, fid, new_jstr); printf(\"new_jstr:%#x\\n\", &amp;new_jstr); return new_jstr;&#125; 最后调用结果如下： 12key修改前：xuhaokey修改后：super xuhao 其他的访问方式都是按照这些套路来的，理解就可以了，今天连续赶了两篇博客，后面再抽出时间继续，坚持，坚持，再坚持！！！ 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/categories/NDK开发/"}],"tags":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/tags/NDK开发/"},{"name":"jni","slug":"jni","permalink":"https://xuhaoblog.com/tags/jni/"}]},{"title":"Android NDK开发（二）JNI传递参数和返回值","slug":"ndk/jni-2","date":"2016-10-06T07:28:31.000Z","updated":"2017-11-04T11:15:27.000Z","comments":true,"path":"2016/10/06/ndk/jni-2/","link":"","permalink":"https://xuhaoblog.com/2016/10/06/ndk/jni-2/","excerpt":"前言我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。","text":"前言我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。 正文继JNI简介及调用流程这篇文章，我们再来实现一个非静态的native方法。 Java端： 123456789101112131415161718192021222324public class JniTest &#123; //静态的 public native static String getStringFromC(); //非静态的 public native String getString2FromC(int i); public static void main(String[] args) &#123; String text = getStringFromC(); System.out.println(text); JniTest t = new JniTest(); text = t.getString2FromC(6); System.out.println(text); &#125; //加载动态库 static&#123; System.loadLibrary(\"jni_study\"); &#125;&#125; 在native层实现 getString2FromC 非静态方法； 1234JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getString2FromC(JNIEnv *env, jobject jobj, jint num)&#123; return (*env)-&gt;NewStringUTF(env,\"C String2\");&#125; 由此看出，每个native函数，都至少有两个参数（JNIEnv*,jclass或者jobject) 当native方法为静态方法时：jclass 代表native方法所属类的class对象(JniTest.class) 当native方法为非静态方法时：jobject 代表native方法所属的对象 1.Java基本数据类型传递用过Java的人都知道，Java中的基本类型包括boolean，byte，char，short，int，long，float，double这样几种，如果你用这几种类型做native方法的参数，当你通过javah -jni生成.h文件的时候，只要看一下生成的.h文件，就会一清二楚，这些类型分别对应的类型是jboolean，jbyte，jchar，jshort，jint，jlong，jfloat，jdouble 。这几种类型几乎都可以当成对应的C++类型来用。 Java基本数据类型与JNI数据类型的映射关系如下： 对应的java引用数据类型： 12345678910111213141516struct _jobject;typedef struct _jobject *jobject;typedef jobject jclass;typedef jobject jthrowable;typedef jobject jstring;typedef jobject jarray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jarray jobjectArray; 关系图： 最终都是jobject 的结构体指针类型。 2.String参数的传递Java的String和C++的string是不能对等起来的，所以处理起来比较麻烦。先看一个例子 12345678910111213141516class Prompt &#123;// native method that prints a prompt and reads a lineprivate native String getLine(String prompt);public static void main(String args[]) &#123;Prompt p = new Prompt();String input = p.getLine(\"Type a line: \");System.out.println(\"User typed: \" + input);&#125;static &#123;System.loadLibrary(\"Prompt\");&#125;&#125; 在这个例子中，我们要实现一个native方法，String getLine(String prompt);读入一个String参数，返回一个String值。通过执行javah -jni得到的头文件是这样的。 1234567891011#include &lt;jni.h&gt;#ifndef _Included_Prompt#define _Included_Prompt#ifdef __cplusplusextern \"C\" &#123;#endifJNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject this, jstring prompt);#ifdef __cplusplus&#125;#endif#endif jstring是JNI中对应于String的类型，但是和基本类型不同的是，jstring不能直接当作C++的string用。如果你用 1cout &lt;&lt; prompt &lt;&lt; endl; 编译器肯定会扔给你一个错误信息的。其实要处理jstring有很多种方式，这里只讲一种我认为最简单的方式，看下面这个例子： 123456789101112131415161718192021#include \"Prompt.h\"#include &lt;iostream&gt;JNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject obj, jstring prompt)&#123;const char* str;str = env-&gt;GetStringUTFChars(prompt, false);if(str == NULL) &#123;return NULL; &#125;std::cout &lt;&lt; str &lt;&lt; std::endl;//释放资源env-&gt;ReleaseStringUTFChars(prompt, str);// 返回一个字符串char* tmpstr = \"return string succeeded\";jstring rtstr = env-&gt;NewStringUTF(tmpstr);return rtstr;&#125; 在上面的列子代码中，作为参数的prompt不能直接被C++程序使用，先做了如下转换 1str = env-&gt;GetStringUTFChars(prompt, false); 将jstring类型变成一个char*类型。返回的时候，要生成一个jstring类型的对象，也必须通过如下方式， 1jstring rtstr = env-&gt;NewStringUTF(tmpstr); 这里用到的GetStringUTFChars和NewStringUTF都是JNI提供的处理String类型的函数。 3.数组类型的传递和String一样，JNI为Java基本类型的数组提供了j*Array类型，比如int[]对应的就是jintArray。来看一个传递int数组的例子。 java端主要代码： 123456789public native void giveArray(int[] array);int[] array = &#123;9,100,10,37,5,10&#125;; //排序t.giveArray(array);for (int i : array) &#123; System.out.println(i);&#125; C实现主要代码：123456789101112131415161718192021222324int compare(int *a,int *b)&#123; return (*a) - (*b);&#125;//传入JNIEXPORT void JNICALL Java_com_study_jni_JniTest_giveArray(JNIEnv *env, jobject jobj, jintArray arr)&#123; //jintArray -&gt; jint指针 -&gt; c int 数组 jint *elems = (*env)-&gt;GetIntArrayElements(env, arr, NULL); //printf(\"%#x,%#x\\n\", &amp;elems, &amp;arr); //数组的长度 int len = (*env)-&gt;GetArrayLength(env, arr); //排序 qsort(elems, len, sizeof(jint), compare); //同步 //mode //0, Java数组进行更新，并且释放C/C++数组 //JNI_ABORT, Java数组不进行更新，但是释放C/C++数组 //JNI_COMMIT，Java数组进行更新，不释放C/C++数组（函数执行完，数组还是会释放） (*env)-&gt;ReleaseIntArrayElements(env, arr, elems, JNI_COMMIT);&#125; 这个代码中的GetIntArrayElements和ReleaseIntArrayElements函数就是JNI提供用于处理int数组的函数。 如果用arr[i]的方式去访问jintArray类型，不用问肯定会出错。JNI还提供了另一对函数GetIntArrayRegion和ReleaseIntArrayRegion访问int数组，不在这里做介绍，至于其他的类型数组，方法类似。 4.返回数组在JNI中，二维数组和String数组都被视为object数组，因为数组和String被视为object。最后一个示例说明如何在本地代码中创建一个字符串数组并将它返回给 Java 调用者。 java端的代码： 12345int[] array2 = t.getArray(10);System.out.println(\"------------\");for (int i : array2) &#123; System.out.println(i);&#125; 函数实现：123456789101112131415//返回数组JNIEXPORT jintArray JNICALL Java_com_study_jni_JniTest_getArray(JNIEnv *env, jobject jobj, jint len)&#123; //创建一个指定大小的数组 jintArray jint_arr = (*env)-&gt;NewIntArray(env, len); jint *elems = (*env)-&gt;GetIntArrayElements(env, jint_arr, NULL); int i = 0; for (; i &lt; len; i++)&#123; elems[i] = i; &#125; //同步 (*env)-&gt;ReleaseIntArrayElements(env, jint_arr, elems, 0); return jint_arr;&#125; jintArray jint_arr ;因为要返回值，所以需要创建一个指定大小jintArray对象。根据jintArray对象拿到jint 指针。然后，赋值，同步，这样通过参数返回就可以了。下一篇将会介绍C 访问Java 属性和方法。 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/categories/NDK开发/"}],"tags":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/tags/NDK开发/"},{"name":"jni","slug":"jni","permalink":"https://xuhaoblog.com/tags/jni/"}]},{"title":"Shell 脚本基础学习之函数（五）","slug":"linux/shell-script-05","date":"2016-10-01T10:10:31.000Z","updated":"2017-11-04T11:20:38.000Z","comments":true,"path":"2016/10/01/linux/shell-script-05/","link":"","permalink":"https://xuhaoblog.com/2016/10/01/linux/shell-script-05/","excerpt":"前言Linux shell脚本基础学习我们这里就差不多讲完了，函数相信大家都不陌生吧，直接入正题吧~ 正文继上篇博客之后 shell 函数Linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。shell 中函数的定义格式如下： 1234function_name () &#123; list of commands [ return value ]&#125;","text":"前言Linux shell脚本基础学习我们这里就差不多讲完了，函数相信大家都不陌生吧，直接入正题吧~ 正文继上篇博客之后 shell 函数Linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。shell 中函数的定义格式如下： 1234function_name () &#123; list of commands [ return value ]&#125; 说明： 1、函数名前面也可以加上关键字function； 2、函数的返回值，可以显示加：return 返回，如果不加，将以最后一条命令的运行结果作为返回值。 shell 函数返回值只能是整数，一般用来表示函数执行是否政工，0表示成功，其他则表示失败。 如果要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在访问这个变量来获得函数的返回值。 比如： 12345671 #!/bin/bash 2 Hello () &#123;3 echo \"My name is xu hao\"4 &#125;5 6 #调用上面的函数7 Hello 运行结果： 12root@iZ28t5k4ny4Z:/usr/xiho/shell# ./06.sh My name is xu hao 调用函数只需要给出函数名，不需要加括号。 再来看一个带有return语句的函数： 在上面例子后面添加： 123456789101112131415funWithReturn() &#123;11 echo \"这个函数功能是得到两个数字的和\"12 echo -n \"请输入第一个数字\"13 read aNum;14 echo -n \"请输入第二个数字\"15 read bNum;16 echo \"这两个数分别是 $aNum 和 $bNum !\"17 return $(($aNum+$bNum))18 &#125; 19 20 #调用funWithReturn这个函数21 funWithReturn22 23 ret=$?24 echo \"The sun of two numbers is $ret !\" 运行结果： 1234567root@iZ28t5k4ny4Z:/usr/xiho/shell# ./06.sh My name is xu hao这个函数功能是得到两个数字的和请输入第一个数字56请输入第二个数字23这两个数分别是 56 和 23 !The sun of two numbers is 79 ! $?最后运行的命令的结束代码（返回值），这个在后面会总结的。 函数参数1在shell 中，调用函数时可以向其传递参数，在函数体内部，通过$n 的形式来获取参数，比如,$1表示第一个参数，$2表示第二个参数 再来看一个带参数的函数例子： 123456789101128 funWithParam() &#123;29 echo \"第一个param为 $1\"30 echo \"第二个param为 $2\"31 echo \"第十个param为 $10\"32 echo \"第十个param为 $&#123;10&#125;\"33 echo \"参数总共有 $#\"34 echo \"作为一个字符串输出所有参数 $* !\"35 36 &#125;37 #调用函数并传递参数38 funWithParam 1 2 3 4 5 6 23 45 22 9 25 运行脚本输出的结果为： 1在这里注意下，$ 10不能获取第10个参数，当n&gt;=10时，需要$&#123;n&#125;来获取参数。 另外：在补充几个特殊字符来处理的参数 1234567$# 传递到脚本的参数个数$* 以一个单字符串显示所有向脚本传递的参数$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 一下午整理这两篇博客，算是把Linux shell 脚本的基础的理论学习讲完了，更多的细节只有等我们遇到了在慢慢琢磨吧！吃饭~ 更多相关系列传送门：【个人博客】shel 脚本系列 【Linux 系统编程】shell 脚本基础学习（一） 【Linux 系统编程】shell 命令和流程控制（二） 【Linux 系统编程】shell 流程控制loop和引号（三） 【Linux 系统编程】shell 输入/输出重定向（四） 【Linux 系统编程】shell 脚本基础学习之函数（五） 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/categories/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/tags/Shell/"}]},{"title":"Shell 输入/输出重定向（四）","slug":"linux/shell-script-04","date":"2016-10-01T04:23:31.000Z","updated":"2017-11-04T11:21:12.000Z","comments":true,"path":"2016/10/01/linux/shell-script-04/","link":"","permalink":"https://xuhaoblog.com/2016/10/01/linux/shell-script-04/","excerpt":"前言原本计划国庆节第一天假期休息一天，但是想想自己还有很多事情没有完成，就立马打开电脑，开始干活了。打算这7天的假期好好整理下之前学的知识和巩固练习，充实每一天，好了入正题，Linux shell脚本基础前面我们在介绍Linux shell脚本的控制流程时，还有一部分内容没讲就是有关here document的内容这里继续，Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 原文链接请标明：http://xuhaoblog.com/linux/shell-script-04.html本文出自:【stromxu的博客】","text":"前言原本计划国庆节第一天假期休息一天，但是想想自己还有很多事情没有完成，就立马打开电脑，开始干活了。打算这7天的假期好好整理下之前学的知识和巩固练习，充实每一天，好了入正题，Linux shell脚本基础前面我们在介绍Linux shell脚本的控制流程时，还有一部分内容没讲就是有关here document的内容这里继续，Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 原文链接请标明：http://xuhaoblog.com/linux/shell-script-04.html本文出自:【stromxu的博客】 正文接着上一篇继续… 1、Shell 输入/输出重定向重定向命令列表如下： 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 1.1、输出重定向重定向一般通过在命令间插入特定的符号来实现，语法如下： 1command1 &gt; file1 上面这个命令执行command1然后将输出的内容存入file1。 注意任何file1内的已经存在的内容将被新内容替代。如果要将新的内容添加到文件的末尾，则使用&gt;&gt;操作符。 例子： 我们先新建一个文件test2，然后执行 ls -al 重定向到test2文件中，在命令行的操作符代码如下： 1234#新建test2文件touch test2 #输出重定向ls -al &gt; test2 然后我们使用cat命令查看文件内容： 12345678910111213141516171819202122root@iZ28t5k4ny4Z:/usr/xiho/shell# cat test3total 132drwxr-xr-x 2 root root 4096 Oct 1 13:19 .drwxr-xr-x 4 root root 4096 Sep 27 16:29 ..-rw-r--r-- 1 root root 12288 Sep 27 19:15 .01.sh.swo-rw-r--r-- 1 root root 12288 Sep 27 16:35 .01.sh.swp-rwxr--r-- 1 root root 347 Sep 28 21:07 02.sh-rwxr--r-- 1 root root 100 Sep 28 21:28 03.sh-rw-r--r-- 1 root root 12288 Sep 28 21:15 .03.sh.swp-rwxr--r-- 1 root root 109 Sep 28 22:17 04.sh-rw------- 1 root root 12288 Sep 30 18:03 .04.swp-rw-r--r-- 1 root root 0 Sep 28 22:45 05.sh-rw-r--r-- 1 root root 12288 Sep 28 22:47 .05.sh.swp-rw-r--r-- 1 root root 0 Sep 30 20:57 06.sh-rw-r--r-- 1 root root 12288 Sep 30 21:00 .06.sh.swp-rwxrwxrwx 1 root root 223 Sep 30 17:50 b.sh-rw-r--r-- 1 root root 12288 Sep 30 18:03 .b.sh.swo-rw-r--r-- 1 root root 12288 Sep 28 16:50 .b.sh.swp-rwxrwxrwx 1 root root 119 Oct 1 13:12 demo.sh-rwxr--r-- 1 root root 68 Sep 30 14:09 test1.sh-rw-r--r-- 1 root root 954 Oct 1 13:10 test2-rw-r--r-- 1 root root 0 Oct 1 13:19 test3 就会把当前目录下的所有文件给显示出来了。 如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，这个请自行练习使用。 1.2、输入重定向和输出重定向一样，Unix 命令也可以从文件获取输入，语法为： 1command1 &lt; file1 这样，本来需要从键盘获取输入的命令会转移到文件读取内容。注意：输出重定向是大于号（&gt;），出入重定向是小于号（&lt;）。 例子 接着上面的例子，我们统计test2文件的行数，(不熟悉命令的同学，请查看我的 shell命令（二）的文章），执行以下命令： 12wc -l test221 test2 也可以将输入重定向到test2文件中： 12wc -l &lt; test221 注意：上面两个例子的结果不同；第一个例子，会输出文件名；第二不会，因为它仅仅知道从标准输入读取内容。 1command1 &lt; infile &gt; outfile 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。 1.3、重定向深入理解一般情况下，每一个Linux 命令运行时都会打开三个文件： 标准输入文件（stdin）: stdin的文件描述符为0，linux程序默认从stdin读取数据。 标准输出文件（stdout）: stdout 的文件描述为1，linux程序默认想stdout输出数据。 标准错误文件（stderr）: stderr 的文件描述符为2，linux程序会想stderr流中写入错误信息。 以后打开文件后。新增文件绑定描述符 可以依次增加。 一条shell命令执行，都会继承父进程的文件描述符。因此，所有运行的shell命令，都会有默认3个文件描述符。 正常情况下，command &gt; file 将stdout重定向file，command &lt; file 将stdin 重定向到 file。 一个命令执行了：先有一个输入：输入可以从键盘，也可以从文件得到命令执行完成：成功了，会把成功结果输出到屏幕：standard output默认是屏幕命令执行有错误：会把错误也输出到屏幕上面：standard error默认也是指的屏幕 如果希望stderr 重定向 到file 可以这样写： 1command 2&gt; file 如果希望stderr追加到file 文件末尾，可以这样写： 1command 2&gt;&gt; file 实例（通俗易懂） 显示当前目录文件，写一个实际存在和一个不存在的，方便理解。比如当前目录存在test1.sh，不存在xiho。代码如下：123root@iZ28t5k4ny4Z:/usr/xiho/shell# ls test1.sh xiho ls: cannot access xiho: No such file or directorytest1.sh 看到上面代码显示在屏幕上面，找不到文件路劲报错，正确输出与错误输出都显示在屏幕了，但是现在需要把正确输出写入suc.txt， 1&gt; 可以省略，不写，默认所至标准输出，把错误输出到err.txt，不输出到屏幕。 例子如下： 1ls test1.sh xiho 1&gt; suc.txt 2&gt;err.txt 然后我们分别查看suc.txt和err .txt的信息。 将错误输出信息关闭掉 1234567root@iZ28t5k4ny4Z:/usr/xiho/shell# ls test1.sh xiho 2&gt;&amp;-test1.shroot@iZ28t5k4ny4Z:/usr/xiho/shell# ls test1.sh xiho 2&gt;/dev/nulltest1.sh&amp;[n] 代表是已经存在的文件描述符，&amp;1 代表输出 &amp;2代表错误输出 &amp;-代表关闭与它绑定的描述符/dev/null 这个设备，是linux 中黑洞设备，什么信息只要输出给这个设备，都会给吃掉，哈哈~ 其他的追加操作符等，好玩的自己去试试。 注意：1、shell遇到”&gt;”操作符，会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。 无论左边命令执行是否成功。右边文件都会变为空。2、“&gt;&gt;”操作符，判断右边文件，如果不存在，先创建。以添加方式打开文件，会分配一个文件描述符[不特别指定，默认为1,2]然后，与左边的标准输出（1）或错误输出（2） 绑定。3、当命令：执行完，绑定文件的描述符也自动失效。0,1,2又会空闲。4、一条命令启动，命令的输入，正确输出，错误输出，默认分别绑定0,1,2文件描述符。5、一条命令在执行前，先会检查输出是否正确，如果输出设备错误，将不会进行命令执行。 2、Here DocumentHere Document是shell 中的一种特殊重定向方式，用来将输入重定向到一个交互式的shell脚本或程序。 基本的格式如下： 123command &lt;&lt; EOF documentEOF 它的作用是将两个EOF之间的内容（docuemnt）作为输入传递给command。 注意： 结尾的EOF一定要顶个写，前面不能有任何字符，后面也不能有任何字符，包括空格和tab缩进。 开始的EOF前后的空格不要被忽略掉。 实例 在命令行中通过wc -l 命令计算Here Document 的行数： 12345root@iZ28t5k4ny4Z:/usr/xiho/shell# wc -l &lt;&lt; EOF&gt; 学习使用shell 编程&gt; www.xuhaoblog.com&gt; EOF2 输出的结果为2行。 我们也可以将Here Document 用在脚本中，例如： 123451 #!/bin/bash 2 cat &lt;&lt; EOF 3 学习使用shell脚本编程 4 www.xuhaoblog.com 5 EOF 执行以上脚本输出的结果： 1234root@iZ28t5k4ny4Z:/usr/xiho/shell# chmod u+x 05.sh root@iZ28t5k4ny4Z:/usr/xiho/shell# ./05.sh学习使用shell脚本编程www.xuhaoblog.com Here Document 的简单使用就到这里，还有更多的操作符需要我们去练习。Linux shell脚本基础学习，我们差不多介绍完了，还有一个关于函数的，准备放到下一篇来讲。欢迎关注~ 更多相关系列传送门：【个人博客】shel 脚本系列 【Linux 系统编程】shell 脚本基础学习（一） 【Linux 系统编程】shell 命令和流程控制（二） 【Linux 系统编程】shell 流程控制loop和引号（三） 【Linux 系统编程】shell 输入/输出重定向（四） 【Linux 系统编程】shell 脚本基础学习之函数（五） 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/categories/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/tags/Shell/"}]},{"title":"Shell 流程控制Loop和引号（三）","slug":"linux/shell-script-03","date":"2016-09-30T03:06:31.000Z","updated":"2017-11-04T11:19:02.000Z","comments":true,"path":"2016/09/30/linux/shell-script-03/","link":"","permalink":"https://xuhaoblog.com/2016/09/30/linux/shell-script-03/","excerpt":"前言Linux shell 脚本基础学习第三篇；上一篇Liunx shell 脚本基础学习中，我们讲到了Linux shell 脚本中控制流程的if、select、case，这里接着介绍Linux shell 脚本控制流程的loop和引导，控制流程这部分内容较多，还有一部分是关于here document。","text":"前言Linux shell 脚本基础学习第三篇；上一篇Liunx shell 脚本基础学习中，我们讲到了Linux shell 脚本中控制流程的if、select、case，这里接着介绍Linux shell 脚本控制流程的loop和引导，控制流程这部分内容较多，还有一部分是关于here document。 正文继上篇之后 4、looploop 表达式： 123while ...; do...done while- loop 将运行一直到表达式测试为真。（will run while the expression that we test for is true.） 关键字“break”用来跳出循环。而关键字“continue”用来不执行余下的部分而直接太偶倒下一个循环。 for-loop 表达式查看一个字符串列表（字符串用空格分隔）然后将其赋给一个变量： 123for var in ....; do....done 在下面的例子中，将分别打印ABC到屏幕上： 1234#!/bin/shfor var in A B C ; doecho \"var is $var\"done 下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息： 12345678910111213#!/bin/sh# list a content summary of a number of RPM packages# USAGE: showrpm rpmfile1 rpmfile2 ... # EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpmfor rpmpackage in $*; doif [ -r \"$rpmpackage\" ];thenecho \"=============== $rpmpackage ==============\"rpm -qi -p $rpmpackageelseecho \"ERROR: cannot read file $rpmpackage\"fidone 这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。如果您运行 1showrpm openssh.rpm w3m.rpm webgrep.rpm 此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm 5、引号在想程序传递任何参数之前，程序会扩展通配符和变量。这里所谓的扩展的意思是程序会把通配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防止程序做这种替换，您可以使用引号。 下面是shell引用类型: “” 双引号 ‘’ 单引号 ` 反引号 \\ 反斜线 5.1、双引号使用双引号，可引用除了字符$、`、\\外的任意字符或字符串。例如：123#!/bin/bashSTR=\"My name is xuhao\"echo \"$STR\" 输出： 1My name is xuhao 也可以去掉双引号： 1echo $STR 执行脚本输出的结果还是一样的。 双引号可以使具有特殊含义的词失去其原本的意义，如下： 特殊含义的cal,执行的是显示出2016年 12月的日历。 但是我们将cal 命令复制给一个变量，如下： 12CAL=\"cal\"echo $CAL 最后输出cal这里，双引号使cal 命令失去了原有的显示日历的功能；在这里双引号类似于转义字符。 5.2、单引号 单引号与双引号类似，不同的是shell 会忽略任何引用值，即屏蔽的单引号内的特殊字符的原本含义。 123echo ‘my name is $LOGNAME’其结果为：my name is $LOGNAME 5.3、单引号和双引号的区别单引号‘’：取消除单引号以外的任何字符的特殊含义。如： 1`echo ‘my name is $name`’ 其结果为： 123my name is $name此时$只作为一个普通字符使用了。 双引号“”：取消除双引号、$号以及_号以外的所有字符的特殊含义 单引号是强引用，引号里的值是什么，变量的值就是什么； 双引号是弱引用，引号里的值若再包含变量，那在赋值的时候，所有这些变量就被立即替换了。 5.4、反引号反引号（`）用于设置系统命令输出到变量，shell认为反引号中的内容是一个系统命令，所以将会执行之： 12echo `date`Mon Dec 24 16:06:55 CST 2012 这和直接输入date命令是一样的： 12dateMon Dec 24 16:07:12 CST 2012 若输入一个非系统命令，则shell不认识此命令，将会报错：12echo `DATE`ksh: DATE: not found 5.5、反斜杠反斜杠起的作用是将一些特殊字符按原样输出，这些特殊字符有： 1$、*、`、+、^、&amp;、|、\"、?。 例如：echo *将当前目录下的文件名和目录名都列出来。 12echo \\** 而使用反斜杠转义之后，就输出了星号。 更多相关系列传送门：【个人博客】shel 脚本系列 【Linux 系统编程】shell 脚本基础学习（一） 【Linux 系统编程】shell 命令和流程控制（二） 【Linux 系统编程】shell 流程控制loop和引号（三） 【Linux 系统编程】shell 输入/输出重定向（四） 【Linux 系统编程】shell 脚本基础学习之函数（五） 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/categories/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/tags/Shell/"}]},{"title":"Shell 命令和流程控制（二）","slug":"linux/shell-script-02","date":"2016-09-29T08:06:31.000Z","updated":"2017-11-04T11:18:45.000Z","comments":true,"path":"2016/09/29/linux/shell-script-02/","link":"","permalink":"https://xuhaoblog.com/2016/09/29/linux/shell-script-02/","excerpt":"前言Linxu shell 脚本基础这里介绍到第二篇，详细介绍shell 命令和流程控制，这部分介绍三类命令，在学习时大家应该加以比较学习。Linux shell脚本基础课程前面一篇介绍的都是语法基础的开头、注释、变量和 环境变量，这里将介绍shell命令和控制流程的第一部分，在shell脚本中可以使用三类命令，而控制流程就放在下一讲吧。","text":"前言Linxu shell 脚本基础这里介绍到第二篇，详细介绍shell 命令和流程控制，这部分介绍三类命令，在学习时大家应该加以比较学习。Linux shell脚本基础课程前面一篇介绍的都是语法基础的开头、注释、变量和 环境变量，这里将介绍shell命令和控制流程的第一部分，在shell脚本中可以使用三类命令，而控制流程就放在下一讲吧。 正文1.1.5 Shell命令和流程控制在shell脚本中可以使用三类命令： 1)Unix 命令:虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。 常用命令语法及功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647echo \"some text\": 将文字内容打印在屏幕上ls: 文件列表wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数cp sourcefile destfile: 文件拷贝mv oldname newname : 重命名文件或移动文件rm file: 删除文件grep 'pattern' file: 在文件内搜索字符串比如：grep 'searchstring' file.txtcut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令cat file.txt: 输出文件内容到标准输出设备（屏幕）上file somefile: 得到文件类型read var: 提示用户输入，并将输入赋值给变量sort file.txt: 对file.txt文件中的行进行排序uniq: 删除文本文件中出现的行列比如： sort file.txt | uniqexpr: 进行数学运算Example: add 2 and 3expr 2 \"+\" 3find: 搜索文件比如：根据文件名搜索find . -name filename -printtee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfilebasename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tuxdirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /binhead file: 打印文本文件开头几行tail file : 打印文本文件末尾几行sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' &gt; newtext.fileawk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F, '&#123;print $1 \",\" $3 &#125;'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA 2) 概念: 管道, 重定向和 backtick这些不是系统命令，但是他们真的很重要。 管道 (|)： 将一个命令的输出作为另外一个命令的输入。 1grep \"hello\" file.txt | wc -l 在file.txt中搜索包含有”hello”的行并计算其行数。在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。 重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。 12&gt; 写入文件并覆盖旧文件&gt;&gt; 加到文件的尾部，保留旧文件内容。 反短斜线：使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。命令： 1find . -mtime -1 -type f -print 用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本： 123#!/bin/sh# The ticks are backticks (`) not normal quotes ('):tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print` 3) 流程控制1.if“if” 表达式 如果条件为真则执行then后面的部分：1234567if ....; then....elif ....; then....else....fi 大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等… 通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。 1234[ -f \"somefile\" ] ：判断是否是一个文件[ -x \"/bin/ls\" ] ：判断/bin/ls是否存在并有可执行权限[ -n \"$var\" ] ：判断$var变量是否有值[ \"$a\" = \"$b\" ] ：判断$a和$b是否相等 执行man test可以查看所有测试表达式可以比较和判断的类型。直接执行以下脚本： 123456#!/bin/shif [ \"$SHELL\" = \"/bin/bash\" ]; thenecho \"your login shell is the bash (bourne again shell)\"elseecho \"your login shell is not bash but $SHELL\"fi 变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。快捷操作符熟悉C语言的朋友可能会很喜欢下面的表达式： 1[ -f \"/etc/shadow\" ] &amp;&amp; echo \"This computer uses shadow passwors\" 这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。 您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子： 12345#!/bin/shmailfolder=/var/spool/mail/james[ -r \"$mailfolder\" ]' '&#123; echo \"Can not read $mailfolder\" ; exit 1; &#125;echo \"$mailfolder has mail from:\"grep \"^From \" $mailfolder 该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令： 打印错误信息 退出程序我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。 2.casecase :表达式可以用来匹配一个给定的字符串，而不是数字。 123case ... in...) do something here ;;esac 让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：file lf.gz这将返回： 12lf.gz: gzip compressed data, deflated, original filename,last modified: Mon Aug 27 23:09:18 2001, os: Unix 我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件： 1234567891011#!/bin/shftype=`file \"$1\"`case \"$ftype\" in\"$1: Zip archive\"*)unzip \"$1\" ;;\"$1: gzip compressed\"*)gunzip \"$1\" ;;\"$1: bzip2 compressed\"*)bunzip2 \"$1\" ;;*) echo \"File $1 can not be uncompressed with smartzip\";;esac 您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行： 1smartzip articles.zip $1 就是字符串 articles.zip 3. selsectselect 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。 1234select var in ... ; dobreakdone .... now $var can be used .... 下面是一个例子： 123456#!/bin/shecho \"What is your favourite OS?\"select var in \"Linux\" \"Gnu Hurd\" \"Free BSD\" \"Other\"; dobreak doneecho \"You have selected $var\" 下面是该脚本运行的结果： 1234567What is your favourite OS?1) Linux2) Gnu Hurd3) Free BSD4) Other#? 1You have selected Linux 上面就是这一篇的内容，控制流程比较多，这里先介绍这三个。下篇继续。。。 更多相关系列传送门：【个人博客】shel 脚本系列 【Linux 系统编程】shell 脚本基础学习（一） 【Linux 系统编程】shell 命令和流程控制（二） 【Linux 系统编程】shell 流程控制loop和引号（三） 【Linux 系统编程】shell 输入/输出重定向（四） 【Linux 系统编程】shell 脚本基础学习之函数（五） 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见,共同学习，谢谢！","categories":[{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/categories/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/tags/Shell/"}]},{"title":"Shell 脚本基础学习（一）","slug":"linux/shell-script-01","date":"2016-09-29T05:06:31.000Z","updated":"2017-11-04T11:18:30.000Z","comments":true,"path":"2016/09/29/linux/shell-script-01/","link":"","permalink":"https://xuhaoblog.com/2016/09/29/linux/shell-script-01/","excerpt":"前言Linux shell 脚本基础我们将分几篇文章来记录，希望对我们这些初次接触Linxu shell脚本编程的初学者有帮助；Linxu shell 脚本基础学习先来介绍shell的语法，开头、注释、变量和环境，虽然不涉及到具体的东西，但是大号基础是以后学习的前提，很多时候我们拿到别人的开源库，需要编译使用，但是由于各种原因，总是编译不成功，其中就有shell 脚本，如果我们看不懂别人的脚本，编译出错，还查不来原因。（比如一个空格导致编译失败，你能查出原因么？）","text":"前言Linux shell 脚本基础我们将分几篇文章来记录，希望对我们这些初次接触Linxu shell脚本编程的初学者有帮助；Linxu shell 脚本基础学习先来介绍shell的语法，开头、注释、变量和环境，虽然不涉及到具体的东西，但是大号基础是以后学习的前提，很多时候我们拿到别人的开源库，需要编译使用，但是由于各种原因，总是编译不成功，其中就有shell 脚本，如果我们看不懂别人的脚本，编译出错，还查不来原因。（比如一个空格导致编译失败，你能查出原因么？） 正文1.Linux 脚本编写基础1.1 语法的基本介绍1.1.1 开头程序必须以下面的行开始（必须放在文件的第一行）： 1#!/bin/bash 符号”#!”用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。当编辑好脚本时，如果要执行该脚本，还必须使其可执行。要使脚本可执行：编译 chmod u+x filename 这样才能用./filename 来运行 1.1.2 注释在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。 1.1.3 变量在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写： 123456#!/bin/sh#对变量赋值：a=\"hello world\"# 现在打印变量a的内容：echo \"A is:\"echo $a 有时候变量名很容易与其他文字混淆，比如：12num=2echo \"this is the $numnd\" 这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：12num=2echo \"this is the $&#123;num&#125;nd\" 这将打印： this is the 2nd 1.1.4 环境变量由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。 这一篇就介绍到这里，下面我们会接触到具体的Linux shell脚本基础的实质部分。 更多相关系列传送门：【个人博客】shel 脚本系列 【Linux 系统编程】shell 脚本基础学习（一） 【Linux 系统编程】shell 命令和流程控制（二） 【Linux 系统编程】shell 流程控制loop和引号（三） 【Linux 系统编程】shell 输入/输出重定向（四） 【Linux 系统编程】shell 脚本基础学习之函数（五） 本文由博主辛苦整理下来的笔记；希望大家能够指点或提出宝贵意见，共同学习，谢谢！","categories":[{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/categories/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://xuhaoblog.com/tags/Shell/"}]},{"title":"VIM的安装配置及使用","slug":"linux/vim-config","date":"2016-09-29T04:22:31.000Z","updated":"2017-11-04T11:21:21.000Z","comments":true,"path":"2016/09/29/linux/vim-config/","link":"","permalink":"https://xuhaoblog.com/2016/09/29/linux/vim-config/","excerpt":"前言Learn vim and it will be your last text editor. There isn’t any better text editor that I know of. It is hard to learn, but incredible to use.学习VIM，它会是你最后的文本编辑器。没有任何好转的文本编辑器，我知道的。这是很难学，但令人难以置信的使用。 VI是LINUX下最老牌的编辑工具，而VIM则是VI的升级版本，LINUX系统必备啊~~","text":"前言Learn vim and it will be your last text editor. There isn’t any better text editor that I know of. It is hard to learn, but incredible to use.学习VIM，它会是你最后的文本编辑器。没有任何好转的文本编辑器，我知道的。这是很难学，但令人难以置信的使用。 VI是LINUX下最老牌的编辑工具，而VIM则是VI的升级版本，LINUX系统必备啊~~ 摘要（以下已Ubuntu系统为例） VIM的安装和配置1、VIM安装既然VIM编辑器是在Linux 系统环境下运行的，那么我们首先要在Ubuntu上安装VIM；在命令行敲入“vi”后按”tab”键，可以查看到目前系统中有没有安装Vim，如果没有的话就只会显示vi和vim.tiny。如下图(我是已经安装了的） 如果没有安装VIM，普通用户下输入命令： 1sudo apt-get install vim-gtk 然后按照提示，输入“y”后，回车，之后不要进行任何操作，等待安装完成。安装完成后，在命令行输入vi，按“tab”键。如上图，说明vim已经安装成功~ 2、VIM配置刚安装的VIM，默认的配置可能不是很好使用，这就需要我们去配置VIM，在命令下，输入命令： 1sudo vim /etc/vim/vimrc 必须加上sudo，否则你是没有权限编辑vimrc的。 在这个文件中，会有这么一句：syntax on意思是语法高亮，如果您的被注释掉了，请“让它出来”，就如下图所示： 接着我们在VIM配置文件的最后一行，加入以下配置，会使我们方便很多。 123456set nu // 在左侧行号set tabstop //tab 长度设置为 4set nobackup //覆盖文件时不备份set cursorline //突出显示当前行set ruler //在右下角显示光标位置的状态行set autoindent //自动缩进 保存之后，配置完毕。上面的配置，其实是非常简单的，比如一些配色方案等，小编并没有写入，如果您还有其他需求的话，建议多查些资料。 VIM常用的基本命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687881. vim #在命令行中输入vim,进入vim编辑器 2. i #按一下i键,下端显示 --INSERT-- #插入命令,在vim中可能任意字符都有作用 3. Esc #退出i(插入)命令进行其它命令使用4. :r filename #读入一个文件内容,并写入到当前编辑器中 5. :w newfilename #将该编辑器中的内容写入到一个新文件中 6. :w #在编辑的过程中保存文件,相当于word中的ctrl+s 7. :! command 暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 :!ls #在编辑过程中执行shell命令ls 8. :sh #进入shell命令行,执行完命令后ctrl+d退出重新进入vim编辑继续编辑 在shell命令下，执行ctral+l完成清屏 9. :wq #保存文件并退出 10. ZZ #保存文件并退出,同上一个命令,注意大写 11. :q! #强制退出,不保存 12. :set number或者：set nu #使编辑中的文件显示行号 13. :set nonumber或者：set nonu #与上一条命令相反,不显示行号 14. :help i #查看插入命令帮助 15. u #撤消上一步操作 16. /Fedora #查找Fedora字符 17. :s /Fedora/Redhat #将Fedora字符替换为Redhat(只替换在光标所在的行) 18. dw #删除单词 dd #删除行 19. o #打开空白一行 20. vim + filename #进行文件最后一行进行编辑 21. vim +n filename #进入文件第n行进行编辑 22. :1,.s/redhat/fedora #.号表示当前行,即光标所在行 #将第1行到当前行(.)第一次出现的redhat字符代替为fedora 23. :1,.s/redhat/fedora/g #将第1行到当前行(.)所有出现的redhat字符代替为fedora,g 全局标志 24. :1,$s/redhat/fedora/g #$表示最后一行 #将第1行到最后一行所有出现的redhat字符代替为fedora 25. :%s/redhat/fedora/g #同上一个命令 26. :%s/\\/fedora/g #将第1行到最后一行所有出现的redhat字代替为fedora #字,而不是字符27. :f #显示文件内容,状态等等 #同ctrl+g命令 28. :e! #当前文件,返回到上次保存 :e file #切换编辑文件 29. :n #当编辑时有多个文件(比如vim file1 file2)时切换到下一个文件,与:e file 结合使用 学习理解并整理下来的笔记;希望大家能够指点或提出宝贵意见,共同学习，谢谢！","categories":[{"name":"vim","slug":"vim","permalink":"https://xuhaoblog.com/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://xuhaoblog.com/tags/vim/"},{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"}]},{"title":"Linux 常用的一些基本命令","slug":"linux/cmd","date":"2016-09-28T04:17:31.000Z","updated":"2017-11-04T11:05:34.000Z","comments":true,"path":"2016/09/28/linux/cmd/","link":"","permalink":"https://xuhaoblog.com/2016/09/28/linux/cmd/","excerpt":"前言Linux提供了大量的命令，利用它可以有效地完成大量的工作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。所以，在Linux系统上工作离不开使用系统提供的命令。要想真正理解Linux系统，就必须从Linux命令学起，通过基础的命令学习可以进一步理解Linux系统，下面就来简单总结下常用的基础操作命令。","text":"前言Linux提供了大量的命令，利用它可以有效地完成大量的工作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。所以，在Linux系统上工作离不开使用系统提供的命令。要想真正理解Linux系统，就必须从Linux命令学起，通过基础的命令学习可以进一步理解Linux系统，下面就来简单总结下常用的基础操作命令。 基本命令（1）指令名称：pwd1pwd 命令也是最常用最基本的命令之一，用于显示用户当前所在的目录。 （2）指令名称：cd1234cd命令不仅显示当前状态，还改变当前状态，它的用法跟dos下的cd命令基本一致。 cd ..可进入上一层目录 cd -可进入上一个进入的目录 cd ~可进入用户的home目录 （3）指令名称：cp 使用方式： 12cp [options] source dest cp [options] source... directory 说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。 参数 说明 -a 尽可能将档案状态、权限等资料都照原状予以复制。 -r 若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。 -f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。 比如： 将档案 aaa 复制(已存在)，并命名为 bbb : 1cp aaa bbb 将所有的C语言文件拷贝至 Finished 子目录中 : 1cp *.c Finished 复制文件12345cp src.txt dest.txtcp -i src.txt dest.txt 询问cp src.txt . 复制到当前目录cp -R 目录 dest 复制整个目录到指定路径cp c_?1 ../ 通配符复制到上级目录 （4）指令名称：mv使用方式： 12mv [options] source dest mv [options] source... directory 说明：将一个档案移至另一档案，或将数个档案移至另一目录。参数：-i 若目的地已有同名档案，则先询问是否覆盖旧档。 将档案 aaa 更名为 bbb : 1mv aaa bbb 将所有的C语言程序移至 Finished 子目录中 : 1mv -i *.c /Finished （5）指令名称 : chmod使用方式 : 1chmod [-cfvR] [--help] [--version] mode file... 说明 : Linux/Unix 的档案存取权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所存取。 mode : 权限设定字串，格式如下 : [ugoa…][+-=][rwxX]…][,…]，其中u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 1234-c 若该档案权限确实已经更改，才显示其更改动作-f 若该档案权限无法被更改也不要显示错误讯息-v 显示权限变更的详细资料-R 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) 将档案 file1.txt 设为所有人皆可读取 : 1chmod ugo+r file1.txt 将档案 file1.txt 设为所有人皆可读取 : 1chmod a+r file1.txt 将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : 1chmod ug+w,o-w file1.txt file2.txt 将 ex1.py 设定为只有该档案拥有者可以执行 : 1chmod u+x ex1.py 将目前目录下的所有档案与子目录皆设为任何人可读取 : 1chmod -R a+r * 此外chmod也可以用数字来表示权限如 chmod 777 file 1语法为：chmod abc file 其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 1234r=4，w=2，x=1 若要rwx属性则4+2+1=7； 若要rw-属性则4+2=6；若要r-x属性则4+1=7。 创建用户 12useradd -m jack 创建用户的同时，创建了home目录userdel -r jack 删除用户 创建组 1groupadd androidgroup 分配用户到组 1usermod -G androidgroup jack 文件权限 123r读 w写 x执行drwxr-xr-xd rwx r-x r-x d目录 1.文件所属用户具备的权限（root对该文件具备读写执行权限）2.文件所属用户的所属组具备的权限（读、执行）3.系统的其他用户具备的权限（读、执行） rwx必须是固定顺序 123456789权限 二进制 八进制--- 000 0--x 001 1-w- 010 2-wx 011 3r-- 100 4r-x 101 5rw- 110 6rwx 111 7 修改文件权限 1chmod 644 file 给用户加上执行权限 1chmod u+x file 改变创建目录的默认权限 1umask 026 1777-026 改变文件的所属 123chown user.group filechown user filechown .group file （6）指令名称 : ls使用方式 : 1ls [-alrtAFR] [name...] 说明 : 显示指定工作目录下之内容（列出目前工作目录所含之档案及子目录)。 12345678参数 说明-a 显示所有档案及目录 (ls内定将档案名或目录名称开头为\".\"的视为隐藏档，不会列出) -l 除档案名称外，亦将档案型态、权限、拥有者、档案大小等资讯详细列出 -r 将档案以相反次序显示(原定依英文字母次序) -t 将档案依建立时间之先后次序列出-A 同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录) -F 在列出的档案名称后加一符号；例如可执行档则加 \"*\", 目录则加 \"/\"-R 若目录下有档案，则以下之档案亦皆依序列出 ls -lls -la 所有ls -l ja* 通配符查找 例子： 列出目前工作目录下所有名称是 s 开头的档案，愈新的排愈后面 : 1ls -ltr s* 将 /bin 目录以下所有目录及档案详细资料列出 : 1ls -lR /bin 列出目前工作目录下所有档案及目录；目录于名称后加 “/“, 可执行档于名称后加 “*” : 1ls -AF （7）指令名称：rm使用方式： 1rm [options] name... 说明：删除档案及目录。 1234参数 说明-i 删除前逐一询问确认。-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。-r 将目录及以下之档案亦逐一删除。 范例：删除所有C语言程式档；删除前逐一询问确认 : 1rm -i *.c 将 Finished 子目录及子目录中所有档案删除 : 1rm -r Finished （8）指令名称：rmdir使用方式： 1rmdir [-p] dirName 说明： 删除空的目录。 参数： -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。范例：将工作目录下，名为 AAA 的子目录删除 : 1rmdir AAA 在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除。 1rmdir -p BBB/Test （9）指令名称：touch 使用方式： 1touch [-acfm] 12345[-r reference-file] [--file=reference-file] [-t MMDDhhmm[CC]YY][.ss] [-d time] [--date=time] [--time=&#123;atime,access,use,mtime,modify&#125;][--no-create] [--help] [--version] file1 [file2 ...] 说明：touch 指令改变档案的时间记录。 ls -l 可以显示档案的时间记录。 12345678参数 说明a 改变档案的读取时间记录m 改变档案的修改时间记录c 假如目的档案不存在，不会建立新的档案。f 不使用，是为了与其他 unix 系统的相容性而保留r 使用参考档的时间记录，与 --file 的效果一样d 设定时间与日期，可以使用各种不同的格式t 设定档案的时间记录，格式与 date 指令相同 （10）指令名称：gzip说明：gzip命令用于压缩文件。参数 ： -d 将压缩文件解压范例：如果要将ye.txt文件压缩，可用如下命令： 1gzip ye.txt 这样就可以压缩文件并在文件名后面加上gz扩展名，变成文件ye.txt.gz。解压缩文件可用gzip -d命令实现： 1gzip -d ye.txt.gz 这样就可以解压缩文件并删除gz扩展名。 （11）指定reset1reset 清空命令行 好了，暂时用到的命令就先整理出来，以免忘记咯，等不记得时候翻出来瞅瞅~~ 学习理解并整理下来的笔记;希望大家能够指点或提出宝贵意见,共同学习，谢谢！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"}]},{"title":"Android NDK开发（一）JNI简介及调用流程","slug":"ndk/jni-1","date":"2016-09-23T07:28:31.000Z","updated":"2017-11-04T11:17:04.000Z","comments":true,"path":"2016/09/23/ndk/jni-1/","link":"","permalink":"https://xuhaoblog.com/2016/09/23/ndk/jni-1/","excerpt":"前言前段时间学习了C、C++的一些基础知识后，了解了它们的编码风格，要想掌握NDK开发，前提是会使用JNI，下面我们开始简单的介绍吧！ JNI简介 JNI全称是Java Native Interface（Java本地接口），本地接口就是指用C和C++开发的接口。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。","text":"前言前段时间学习了C、C++的一些基础知识后，了解了它们的编码风格，要想掌握NDK开发，前提是会使用JNI，下面我们开始简单的介绍吧！ JNI简介 JNI全称是Java Native Interface（Java本地接口），本地接口就是指用C和C++开发的接口。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。 开发JNI程序会受到系统环境的限制，因为用C/C++语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和CPU指令集，而且各个平台对标准C/C++的规范和标准库函数实现方式也有所区别。这就造成使用了JNI接口的JAVA程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。 JNI的开发流程主要分为以下几个步骤： 编写带有native声明方法的java类； 用”javac”命令来编译所编写的java类； 使用”javah”java类的名生成扩展名为h的头文件； 复制jni.h和jni_md.h文件到CPP工程中; 实现.h头文件中声明的函数 生成dll动态链接库 配置dll文件所在目录到环境变量 重启Eclipse jni调用dill的流程图如下： 通过上面的分析，相信大家已经对jni的开发流程有一个整体的认识，接下来，我们将通过实例更进一步的了解。 第一步：编写带有native声明方法的java类JniTest.java123456package com.study.jni;public class JniTest &#123; public native static String getStringFromC();&#125; 第二步：用”javac”命令来编译所编写的java类；首先我们必须得配有java环境变量，然后我们右键点击项目-&gt;properties,复制项目路径； 然后进入dos命令， 1234567C:\\Users\\uuxuh&gt;cd E:\\Documents\\11\\JniTestC:\\Users\\uuxuh&gt;E:E:\\Documents\\11\\JniTest&gt;cd srcE:\\Documents\\11\\JniTest\\src&gt; 第三步：使用”javah”java类的名生成.h的头文件接着，复制我们的完整类名（包名+类名），执行命令： 1E:\\Documents\\11\\JniTest\\src&gt;javah com.study.jni.JniTest 回到工程目录下，刷新项目，编译后的.h头文件就出现了。 源码： com_study_jni_JniTest.h123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_study_jni_JniTest */#ifndef _Included_com_study_jni_JniTest#define _Included_com_study_jni_JniTest#ifdef __cplusplusextern \"C\" &#123;#endif/* * Class: com_study_jni_JniTest * Method: getStringFromC * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getStringFromC (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 第四步：复制jni.h和jni_md.h文件到CPP工程中将要编译的文件中引入了 1#inlcude&lt;jni.h&gt; 头文件，所以我们手动导入这两个文件到CPP工程中， 以我的jdk1.7.0_75为例，两个头文件的位置分别为：12jni.h jdk1.7.0_75/includejni_md.h jdk1.7.0_75/include/linux 将我们生成.h头文件复制到项目的代码文件目录下 ， 在解决方案中的头文件目录-&gt; 右键-&gt; 添加 -&gt; 添加现有项 。 将我们的头文件添加进来，还有jni.h和jni_md.h一起添加进来，如图： 第五步：实现.h头文件中声明的函数c代码如下：12345678910#include \"com_study_jni_JniTest.h\"//函数实现JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getStringFromC(JNIEnv *env, jclass jcls)&#123; //简单的实现return (*env)-&gt;NewStringUTF(env, \"C String\");&#125; 第六步：生成dll动态链接库我们以VS2013为例： 操作步骤： 选中项目 -&gt; 右键 -&gt; 属性 -&gt; 常规 -&gt; 项目默认值 -&gt; 配置类型 , 选择动态库.dll， 如图，右上角配置管理器，根据我们所使用的平台进去配置一下： 这里我使用64位的，所以活动解决方案平台下新建了一个x64，部署项目配置也选择x64。 配置完了之后，最后生成解决方案。去项目目录下查看dll动态库。 第七步：配置dll文件所在目录到环境变量我们把生成dll文件的路径配置java环境变量里面，这样java 才会知道有dll动态库存在，配置完之后，重启下Eclipse。 最后我们在java中调用动态库，完整代码： 12345678910111213141516package com.study.jni;public class JniTest &#123; public native static String getStringFromC(); public static void main(String[] args) &#123; System.out.println(getStringFromC()); &#125; // 加载动态库 static&#123; System.loadLibrary(\"jni_study\"); &#125;&#125; 最后运行一下项目控制台打印出C中返回给我们的字符串。 好了，整个jni的调用流程已经说的非常详细了，但这只是jni入门的基础，后续会继续更新！ 学习理解并整理下来的笔记；希望大家能够指点或提出宝贵意见，一起学习，谢谢！","categories":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/categories/NDK开发/"}],"tags":[{"name":"NDK开发","slug":"NDK开发","permalink":"https://xuhaoblog.com/tags/NDK开发/"},{"name":"jni","slug":"jni","permalink":"https://xuhaoblog.com/tags/jni/"}]},{"title":"Xshell 远程连接Linux服务器","slug":"linux/xshell","date":"2016-09-20T10:30:31.000Z","updated":"2017-11-05T16:01:13.000Z","comments":true,"path":"2016/09/20/linux/xshell/","link":"","permalink":"https://xuhaoblog.com/2016/09/20/linux/xshell/","excerpt":"我这里有一台电脑，装的Ubuntu系统，当我想使用时，又要去使用另外一台机器（如果没有，可以直接去阿里云整一台主机），更何况文件传输也不方便，比较麻烦，后来，看着同事用的Xshell 远程连接linux，挺方便的就折腾了一番，当然，putty，xftp是个很不错的选择。 xshell和xftp是windows下访问ubuntu（linux）服务器的一个非常好使的工具。 ubuntu安装ssh服务器首先，判断Ubuntu是否安装了ssh服务：1、输入： 1#ps -e |grep ssh 如果服务已经启动，则可以同时看到“ssh-agent”和“sshd”，否则表示没有安装服务，或没有开机启动 。","text":"我这里有一台电脑，装的Ubuntu系统，当我想使用时，又要去使用另外一台机器（如果没有，可以直接去阿里云整一台主机），更何况文件传输也不方便，比较麻烦，后来，看着同事用的Xshell 远程连接linux，挺方便的就折腾了一番，当然，putty，xftp是个很不错的选择。 xshell和xftp是windows下访问ubuntu（linux）服务器的一个非常好使的工具。 ubuntu安装ssh服务器首先，判断Ubuntu是否安装了ssh服务：1、输入： 1#ps -e |grep ssh 如果服务已经启动，则可以同时看到“ssh-agent”和“sshd”，否则表示没有安装服务，或没有开机启动 。 2、安装ssh服务，输入命令： 1#sudo apt-get install openssh-server 出现问题时，重启ssh服务： 1sudo service ssh restart 3、启动服务: 1#/etc/init.d/ssh start 4、本机测试是否能够成功登录： 1234# ssh 用户名@本机ip地址例如：# ssh xuhao@192.168.xxx 最后测试成功如下： 12345678Welcome to Ubuntu 15.10 (GNU/Linux 4.2.0-42-generic x86_64) * Documentation: https://help.ubuntu.com/1 package can be updated.0 updates are security updates.Last login: Sun Sep 18 12:35:27 2016 from 192.168.xxx 在ubuntu 上查看其IP在windows 使用xshell连接 远程linux 双方必须是有网络的，不然无法连接。 输入： 1$ ifconfig 如下图： 红色箭头指向的地方就是Ubuntu的IP。 在windows 上查看其IP在管理员 dos命令控制台上输入 1ipconfig 如下图： 检测是否能互相ping通在windows 同dos命令下： 1ping Ubuntu 的ip 在Ubuntu 下： 1ping Windows的ip 查看他们是否能ping。 配置Xshell远程登录如果没有Xshell的，去网上下载一个。 我们打开Xshell： 参数说明： 名称： 自己随便起个名字；协议： 选择SSH协议；主机： 填写ubuntu的IP。 下面的重新连接，根据需要选择就行， 填完之后，点击OK，填写Ubuntu的密码，contect（连接）。最后就连接成功了。 连接成功就可以控制远程服务器了，然后在去下载一个Xftp，进行文件传输，很方便，哈哈。~~ 学习理解并整理下来的笔记；希望大家能够指点或提出宝贵意见，谢谢！一起学习；","categories":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuhaoblog.com/tags/Linux/"}]},{"title":"C++ New和delete操作符使用","slug":"cpp/string","date":"2016-09-12T06:28:31.000Z","updated":"2017-04-07T10:10:10.000Z","comments":true,"path":"2016/09/12/cpp/string/","link":"","permalink":"https://xuhaoblog.com/2016/09/12/cpp/string/","excerpt":"在C语言中，动态分配内存用 malloc() 函数，释放内存用 free() 函数。如下所示： 12int *p = (int*) malloc( sizeof(int) * 10 ); //分配10个int型的内存空间free(p); //释放内存 在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。","text":"在C语言中，动态分配内存用 malloc() 函数，释放内存用 free() 函数。如下所示： 12int *p = (int*) malloc( sizeof(int) * 10 ); //分配10个int型的内存空间free(p); //释放内存 在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。 用 new 和 delete 分配内存更加简单： 12int *p = new int; //分配1个int型的内存空间delete p; //释放内存 new 操作符会根据后面的数据类型来推断所需空间的大小。 如果希望分配一组连续的数据，可以使用 new[]： 12int *p = new int[10]; //分配10个int型的内存空间delete[] p; 用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。 和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。 在C++中，建议使用 new 和 delete 来管理内存，它们可以使用C++的一些新特性，最明显的是可以自动调用构造函数和析构函数等。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C++ String字符串的增删改查","slug":"cpp/aduc","date":"2016-09-11T09:50:45.000Z","updated":"2017-11-04T11:01:15.000Z","comments":true,"path":"2016/09/11/cpp/aduc/","link":"","permalink":"https://xuhaoblog.com/2016/09/11/cpp/aduc/","excerpt":"c++ 提供的string类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。 插入字符串insert（）函数可以在string字符串中置顶的位置插入另一个字符串，它的原型为： 1string&amp; insert (size_t pos, const string&amp; str); 看这个插入的格式我们就能猜想到，pos表示要插入的下标；str表示要插入的字符串，它可以是string变量，也可以是C风格的字符串。","text":"c++ 提供的string类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。 插入字符串insert（）函数可以在string字符串中置顶的位置插入另一个字符串，它的原型为： 1string&amp; insert (size_t pos, const string&amp; str); 看这个插入的格式我们就能猜想到，pos表示要插入的下标；str表示要插入的字符串，它可以是string变量，也可以是C风格的字符串。 看下面的代码： 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void main()&#123; string s1, s2, s3; s1 = s2 = \"1234567890\"; s3 = \"aaa\"; s1.insert(5, s3); cout &lt;&lt; s1 &lt;&lt; endl; s2.insert(5, \"bbb\"); cout &lt;&lt; s2 &lt;&lt; endl; system(\"pause\");&#125; 运行结果： 12312345aaa6789012345bbb67890请按任意键继续. . . insert()函数的第一个参数有越界的可能，如果越界，则会产生运行时异常。我恶魔你要捕获这个异常。 删除字符串erase()函数可以删除string变量中的一个字符串，原型为： 1string&amp; erase (size_t pos = 0, size_t len = npos); pos 表示要删除的子字符串的起始下标，len表示要删除子字符串的长度。如果不指明len的话，那么直接删除pos到字符串结束处的所有字符（此时len =str.length-pos)。 示例代码如下： 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void main()&#123; string s1, s2, s3; s1 = s2 = s3 = \"1234567890\"; s2.erase(5); s3.erase(5, 3); cout&lt;&lt; s1 &lt;&lt;endl; cout&lt;&lt; s2 &lt;&lt;endl; cout&lt;&lt; s3 &lt;&lt;endl; system(\"pause\");&#125; 运行结果： 12341234567890123451234590请按任意键继续. . . 在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度： len的值 字符串长度减去 pos 的值。 简单的说，就是待删除字符串最多只能删除到字符串结尾。 提取字符串substr()函数原型为： 1string substr (size_t pos = 0, size_t len = npos) const; pos为要提取的子字符串的起始下标，len为要提取的子字符串的长度。 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void main()&#123; string s1 = \"first second third\"; string s2; s2 = s1.substr(6, 6); cout &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; s2 &lt;&lt; endl; system(\"pause\");&#125; 输出结果为： 123first second thirdsecond请按任意键继续. . . 系统对 substr() 参数的处理和 erase() 类似： 如果 pos 越界，会抛出异常； 如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。 字符串的查找find()函数find（）函数用于string字符串中查找子字符串出现的位置，它的原型为： 12size_t find (const string&amp; str, size_t pos = 0) const;size_t find (const char* s, size_t pos = 0) const; 第一个参数的表示为待查找的子字符串，它可以是string变量，也可以是C风格的字符串，第二个参数表示开始查找的位置（下标）； 1234567891011121314151617181920212223/字符串查找替换void main()&#123; string s1 = \"apple google apple iphone\"; //从0开始查找\"google\"的位置 int idx = s1.find(\"google\", 0); cout &lt;&lt; idx &lt;&lt; endl; //统计apple出现的次数 int idx_app = s1.find(\"apple\",0); //npos大于任何有效下标的值 int num = 0; while (idx_app != string::npos) &#123; num++; cout &lt;&lt; \"找到的索引:\" &lt;&lt; idx_app &lt;&lt; endl; idx_app+=5; idx_app = s1.find(\"apple\", idx_app); &#125; cout &lt;&lt; num &lt;&lt; endl; system(\"pause\");&#125; 输出结果为： 123456找到的索引:0找到的索引:132请按任意键继续. . . find函数最终返回的是子字符串 第一次出现在字符串的其实下标，如果没有查找到子字符串，那么会返回一个无穷大的值 4294967295。统计apple出现的次数。先查找第一次出现的位置，接着和npos大于任何有效下标的值，来判断，while循环，每次加上自身的长度，最后统计出现的次数。。。 rfind()函数rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void main()&#123; string s1 = \"first second third\"; string s2 = \"second\"; int index = s1.rfind(s2, 6); if (index &lt; s1.length()) cout &lt;&lt; \"Found at index : \" &lt;&lt; index &lt;&lt; endl; else cout &lt;&lt; \"Not found\" &lt;&lt; endl; system(\"pause\");&#125; 运行的结果为： 12Found at index : 6请按任意键继续. . . find_first_of() 函数find_first_of() 函数用于查找子字符串和字符串共同具有的字符在再辅传中首先出现的位置。 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s1 = \"first second second third\"; string s2 = \"asecond\"; int index = s1.find_first_of(s2); if(index &lt; s1.length()) cout&lt;&lt;\"Found at index : \"&lt;&lt; index &lt;&lt;endl; else cout&lt;&lt;\"Not found\"&lt;&lt;endl; return 0;&#125; 运行结果为： 1Found at index : 3 s1 和 s2 共同具有的字符是 ’s’，该字符在 s1 中首次出现的下标是3，故查找结果返回3。 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C++ String类和字符串的访问和拼接操作","slug":"cpp/string","date":"2016-09-11T06:28:31.000Z","updated":"2017-11-04T11:01:24.000Z","comments":true,"path":"2016/09/11/cpp/string/","link":"","permalink":"https://xuhaoblog.com/2016/09/11/cpp/string/","excerpt":"C++ 增强了对字符串的支持，除了可以使用c中的字符串，还可以使用内置的数据类型string，string类处理字符串会翻遍很多，完全可以代替C语言中的char 数组和char 指针。 使用sting类需要包含头文件&lt; sting &gt;, 下面我们就来介绍怎么使用。 string 的几种用法： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void main()&#123; string s1; string s2 = \"c plus plus\"; string s3 = s2; string s4(5, 's'); cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; s4 &lt;&lt; endl; system(\"pause\");&#125; 输出结果： 12c plus plusc plus plussssss请按任意键继续. . .","text":"C++ 增强了对字符串的支持，除了可以使用c中的字符串，还可以使用内置的数据类型string，string类处理字符串会翻遍很多，完全可以代替C语言中的char 数组和char 指针。 使用sting类需要包含头文件&lt; sting &gt;, 下面我们就来介绍怎么使用。 string 的几种用法： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void main()&#123; string s1; string s2 = \"c plus plus\"; string s3 = s2; string s4(5, 's'); cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; s4 &lt;&lt; endl; system(\"pause\");&#125; 输出结果： 12c plus plusc plus plussssss请按任意键继续. . . 上面的几行代码介绍了 几种定义string 类型变量的方法，变量s1只是定义但是没有初始化，编译器会将默认的值附给s1，默认值是””（空字符串）。变量s2再定义的同时被初始化为”c plus plus ”与C语言中的char 字符串不同，string类型的变量结尾没有‘\\0’,string 类型的本质是一个个string类，而我们定义的变量则是一个个的string类的对象，变量s3在定义的时候直接用s2进行初始化，因此s3的内容也是‘c plus plus’。变量s4被初始化为由5个’s’字符串组成的字符串，也就是’sssss‘。 与C语言中的字符串不同，当我们需要知道字符串长度时，可以调用string类提供的length（）函数。如下所示： 123string s = \"c plus plus\";int len = s.length();cout&lt;&lt;len&lt;&lt;endl; 编译运行的结果： 11 这里，变量 s 也是 string 类的对象，length() 是它的成员函数。由于 string 变量的末尾没有 ‘\\0’ 字符，所以 length() 返回的是字符串的真实长度，而不是长度 +1。 转换为 char 数组字符串 C++虽然提供了string类来替代C语言中的char 数组形式的字符串，但是有时候编程中必须要使用C风格的字符串，为此，string类提供了一个转换的函数c_str();函数能够将 string 变量转换为一个 const 字符串数组的形式，并将指向该数组的指针返回。请看下面的代码： 123string filename = \"input.txt\";ifstream in;in.open(filename.c_str()); 为了使用文件打开函数 open()，必须将 string 类型的变量转换为字符串数组。 123456789101112131415161718192021222324252627282930#ifndef _ITERATOR_DEBUG_LEVEL#define _ITERATOR_DEBUG_LEVEL 0#else#undef _ITERATOR_DEBUG_LEVEL#define _ITERATOR_DEBUG_LEVEL 0#endif#include &lt;iostream&gt;#include &lt;string&gt;//string字符串-&gt;c字符串转换void main()&#123; //string -&gt; char* string s1 = \"far away\"; const char* c = s1.c_str(); printf(\"%s\\n\",c); // string s2 = c; //string-&gt;char[] //从string中赋值字符到char[] char arr[50] = &#123;0&#125;; s1.copy(arr,4,0); cout &lt;&lt; arr &lt;&lt; endl; system(\"pause\");&#125; 编译输出结果： 123far awayfar请按任意键继续. . . string 字符串的输入输出string类重载了输入输出的运算符，用“&gt;&gt;”进行输入，用”&lt;&lt;”进行输出，请看下面代码： 1234567891011#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; //输入字符串 cout &lt;&lt; s &lt;&lt; endl; //输出字符串 system(\"pause\"); return 0;&#125; 运行结果： 123c plusc请按任意键继续. . . 虽然我们输入了两个由空格隔开的”c plus’,但是只输出了一个，这是因为输入的运算符“&gt;&gt;”默认会忽略空格，遇到空格就认为输入结束，所以最后输入的plus没有被存储到变量里面。 访问字符串中的字符string 字符串也可以像字符串数组一样按照下标来访问其中的每一个字符。string 字符串的起始下标仍是从 0 开始。请看下面的代码： 12345678910111213141516171819202122232425#include &lt;string&gt;using namespace std;//string遍历void main()&#123; string s1 = \"abcdefg\"; //1、数组方式 cout &lt;&lt; \"数组方式:\" &lt;&lt; endl; for (int i = 0; i &lt; s1.length(); i++)&#123; cout &lt;&lt;s1[i] &lt;&lt; endl; &#125; //2、迭代方式 cout &lt;&lt; \"迭代方式:\" &lt;&lt; endl; for (string::iterator it = s1.begin(); it != s1.end(); it++)&#123; cout&lt;&lt;*it&lt;&lt; endl; &#125; system(\"pause\");&#125; 输出结果为： 1234567891011121314151617数组方式:abcdefg迭代方式:abcdefg请按任意键继续. . . 字符串的拼接有了string 类，我们可以使用”+“ 或者”+=“运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的strcat(),strcopy(),malloc()等函数来拼接字符串了，再也不用担心空间不够溢出了。下面来看列子： 123456789101112131415161718//字符串拼接void main()&#123; string s1 = \"alan\"; string s2 = \"xiho\"; //1. string s3 = s1 + s2; string s4 = \" wahaha\"; //2. s3.append(s4); cout &lt;&lt; s3 &lt;&lt; endl; system(\"pause\");&#125; 输出结果为： 12alanxiho wahaha请按任意键继续. . . 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"Android中签名、证书、公钥密钥的概念及使用","slug":"sign","date":"2016-09-02T09:08:06.000Z","updated":"2017-11-04T11:00:54.000Z","comments":true,"path":"2016/09/02/sign/","link":"","permalink":"https://xuhaoblog.com/2016/09/02/sign/","excerpt":"资料来源于Android 官方文档：https://developer.android.com/studio/publish/app-signing.html还有些资料来源于网络。加以整理！ 公钥和私钥的概念在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是公开密钥算法（也叫非对称算法、双钥算法）”，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。","text":"资料来源于Android 官方文档：https://developer.android.com/studio/publish/app-signing.html还有些资料来源于网络。加以整理！ 公钥和私钥的概念在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是公开密钥算法（也叫非对称算法、双钥算法）”，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。 证书的概念数字证书则是由证书认证机构（CA）对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机 构的公章）后形成的一个数字文件。CA完成签发证书后，会将证书发布在CA的证书库（目录服务器）中，任何人都可以查询和下载，因此数字证书和公钥一样是公开的。实际上，数字证书就是经过CA认证过的公钥。 原则： 1、一个公钥对应一个私钥。 2、密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。 3、如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。 4、如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。 5、非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的 基于公开密钥的加密过程 比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下： 1、Bob将他的公开密钥传送给Alice。 2、Alice用Bob的公开密钥加密她的消息，然后传送给Bob。 3、Bob用他的私人密钥解密Alice的消息。 Android中的签名：是什么签名？ Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由应用开发者持有， Android使用证书作为标示应用程序作者的一种方式，并在应用程序之间建立信任的关系。 证书并不用来控制用户能否安装哪个应用。证书不需要由证书认证中心签名；完全可以使用自制签名证书。 没有正确签名的应用，Android系统不会安装或运行。此规则适用于在任何地方运行的Android系统，不管是在模拟器还是真实设备上。因为这个原因。在真机或模拟器上运行或者调试应用前，必须为其设置好签名。 为什么要有签名？ 开发Android的人这么多，完全有可能把类名，包名命名成同样的名字，这个时候该如何区分？所以，这时候就需要签名来区分了，由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证相当名字，但是签名不同的包不被替换。发布过Android应用的朋友们应该都知道，Android APK的发布是需要签名的。签名机制在Android应用和框架中有着十分重要的作用。例如，Android系统禁止更新安装签名不一致的APK；如果应用需要使用system权限，必须保证APK签名与Framework签名一致。 签名策略 应用程序签名的一些方面可能会影响应用程序的开发过程, 尤其是当你计划发布多个应用时. 通常情况下, 对于所有开发者而言,推荐的策略是:在应用程序的整个生命周期,所有的应用程序使用相同的证书签名. 为什么这么做的原因: 应用程序升级 – 当发布应用的更新时, 如果想让用户无缝地升级到新版本, 需要继续使用相同的某个或者某一套证书来签名更新包.当系统安装应用的更新时, 它会比较现有版本和新版本的证书. 如果证书吻合, 包括证书数据和顺序都吻合, 那么系统允许更新.如果新版本所做的签名不是匹配的, 那么将需要给应用起一个不同的包名 — 在这种情况下, 用户相当于安装了一个完全的新程序. 应用程序模块化 – Android允许由相同证书签名的应用程序运行在相同的进程中, 此时系统会将它们作为单个应用程序对待.在这种方式中, 可以按模块化的方式部署应用, 用户可以根据需要独立地更新每一个模块. 代码/数据 的授权共享 – Android 提供模式匹配的权限控制机制,因此一个应用可以暴露功能给另一个用指定证书签名的应用. 通过用相同证书签名多个应用,以及使用模式匹配的权限检查,应用程序可以以安全的方式共享代码和数据. 另一个影响签名策略的重要考量是, 如何设置签名应用的key的有效期. 如果计划为某个单独的应用程序提供更新支持, 那么应该确认key的有效期要比应用的寿命长. 推荐25年或者更长的有效期.当key的有效期过期, 用户将再也不能无缝地更新到应用程序的新版本. 如果要使用相同的key为多个不同的应用签名, 应当确认key的有效期比所有这些应用的所有版本的生命周期还长,包括要比将来加到这个套件中的额外的关联应用的生命周期更长. 如果计划将应用程序发布到Android Market, 为应用签名的key的有效期必须在2033年10月22日以后.Market服务器强制执行这个规则, 来保证当新版本可用时, 用户可以无缝地更新Market应用. 当设计的时候, 须牢记这些要点, 以确保使用合适的证书来签名应用程序。 Debug模式下的签名 运行或从IDE调试项目时，Android的Studio会自动由Android SDK工具生成的调试证书签名的APK。您运行或调试Android Studio中的项目第一次，IDE会自动在调试密钥库和证书 $HOME/.android/debug.keystore，并设置密钥库和密钥的密码。 因为Debug模式下的证书由构建工具创建，这样是不安全的，大部分应用程序商店（包括谷歌Play商店）不会接受的APK有出版调试证书签名。 所以你不用每次调试时都输入的Android Studio自动存储在签约配置调试签约信息。签名的配置是由所有必要的信息，以签署APK，包括密钥存储位置，存储密码，密钥名称，密钥密码的对象。您不能直接编辑调试签约配置，但可以配置你如何签上你的发布版本。 有关如何构建和调试运行的应用程序，看到更多的信息， 生成并运行您的应用程序。 调试证书到期 用来签署APK调试的自签名证书有365天，从它的创建日期的截止日期。证书过期后，你在构建的时候会报错的。 为了解决这个问题，只需删除该debug.keystore文件。该文件存储在以下位置： 123~/.android/ 在OS X和LinuxC:\\Documents and Settings\\&lt;user&gt;\\.android\\ 在Windows XP上C:\\Users\\&lt;user&gt;\\.android\\ 在Windows Vista和Windows 7，8，和10 接下来，你构建和运行调试版本的时候，构建工具将重新生成一个新的秘钥库和Debug key，请注意！你必须运行你的程序，不然就不会重新生成秘钥库和Debug key。 发布版的签名你可以使用AndroidStudio 来手动生成签名的apk，但是这样每次发布不同的版本的时候就都手动生成一次，比较麻烦的，所以，我们还可以配置Gradle文件，在构建的过程中会自动签名。 在AndroidStudio中要手动生成签名的apk，按照以下步骤： 在菜单栏中，Build &gt; Generate Signed APK 选择您想从下拉释放下来，然后单击模块 下一步。 如果你已经有一个密钥库，请转到步骤5.如果你想创建一个新的密钥库，单击 新建。 在新的密钥库窗口，为您提供密钥库和密钥以下信息，如图1所示。图1。创建Android Studio中一个新的密钥库。 Keystore Key store path:：选择您的密钥存储应该创建的位置。 Password：创建并确认您的密钥库安全的密码。 Key Alias：你的Enter键的标识名称。 Password: 创建并确认你的密钥的安全密码。这应该是从你选择你的密钥库的密码不同 Validity (years)：设置的时间长度在几年，你的key将是有效的。你的key应该是有效期至少为25年来，这样你就可以通过你的应用程序的寿命相同的密钥签名的应用程序更新。 Certificate：输入有关自己的一些信息，为您的证书。这个信息是不是在你的应用程序中显示，但是属于apk的一部分。填完上面信息，然后单击确定。 在生成签名APK窗口中，选择一个密钥库，私钥，并输入密码两种。（如果在上一步中创建您的密钥库，这些字段已经为您填充。）然后单击 下一步。 图2。选择Android Studio中的私钥。 在下一个窗口中，选择签署的apk的输出目录，和签名的环境，然后单击 Finish（完成）。 图3。生成所选Flavors的APK。 该过程完成后，你会发现在你上面选择的目标文件夹已经有签名的APK。您现在可以通过一个应用市场，如谷歌Play商店，或使用你选择的机制分发签署的APK。 配置build.gradle文件自动签名你的apk 在Android Studio中，你可以通过build.gradle 配置来构建你的项目，在构建的过程中会自动生成你的apk。步骤如下： 在当前你的项目，右键点击你的程序，然后打开Projec Structure， 再打开的窗口中，在模块的左侧面板中选择你想签署的Module。 选择你的密码存储文件，然后输入相关的信息；如图：图4。用于创建新签名构造的窗口。 点击Ok。 然后在build types配置中 选择刚刚签名的配置。如图： 最后点击ok。 然后AndroidStudio 自动构建编译，成功后可以在build/outputs/apk/为您构建模块项目目录内的文件夹中找到我们输出的apk。 签名注意事项 你应该签名所有的APK与整个应用程序的寿命预期相同的证书。有几个原因，你应该这样做： 应用程序升级：当系统安装更新到一个应用程序，它在新版本中与那些在现有版本的证书（S）比较。该系统允许更新，如果证书相匹配。如果你用不同的证书签名的新版本，你必须在不同的包名称分配给应用程序，在这种情况下，用户安装新版本作为一个全新的应用程序。 应用模块：如果是app，Android 允许同一证书签名在同一个进程中运行的APK，因此，系统会将其视为一个单一的应用程序。通过这种方式，你可以部署模块你的应用程序。 代码/数据，通过共享的权限：Android提供了基于签名的权限执行，这样应用程序可以公开的功能到与指定的证书签名的另一个应用程序。通过签署多个APK使用相同的证书，并使用基于签名的权限检查，您的应用程序可以在一个安全的方式共享代码和数据。 保护您的私钥 保护你的私钥的安全性是至关重要的，无论是你还是用户，如果允许别人使用你的秘钥，或者你泄露你的秘钥文件，使得第三方找到他们并使用它们，那么你的app安全性将会受到损失~ 作为一个开发者，在任何时候，都要保护好你的私钥，直到密钥已过期。以下是一些技巧让你的密钥的安全： 选择不容易破解的密码，和keystore； 不要给外人你的私钥和keystore文件； 把他们放置在一个安全的地方。 删除签名信息 当你创建一个签名的配置的时候，Android的Studio将在纯文本模块的您的签名信息build.gradle的文件。如果你是一个团队或用你的代码工作，你应该让它变成一个不容易给别人访问的移动的文件。要做到这一点，你应该创建一个单独的属性文件来存储安全的信息， 创建一个文件名 ​​为keystore.properties在项目的根目录。这个文件应该包含您的签名信息，如下所示： 1234storePassword = myStorePassword keyPassword = mykeyPassword keyAlias ​​= myKeyAlias ​​storeFile = myStoreFileLocation 在你的模块的build.gradle文件中，添加的代码加载你keystore.properties的文件之前android 块。 123456789101112131415...// Create a variable called keystorePropertiesFile, and initialize it to your// keystore.properties file, in the rootProject folder.def keystorePropertiesFile = rootProject.file(\"keystore.properties\")// Initialize a new Properties() object called keystoreProperties.def keystoreProperties = new Properties()// Load your keystore.properties file into the keystoreProperties object.keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android &#123; ...&#125; 你可以使用语法，来引用存储的签名信息： 1234567891011android &#123; signingConfigs &#123; config &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125; &#125; ... &#125; 使用工具签名 如果你不用AndroidStudio来签名你的apk，你还可以使用Android SDK 和 JDK 自带的工具，步骤如下： 使用keytool 生成私钥，例如： 12$ keytool -genkey -v -keystore my-release-key.keystore-alias alias_name -keyalg RSA -keysize 2048 -validity 10000 提示您输入密钥库和密钥的密码，并为你的key设置别名。然后生成密钥库作为一个名为my-release-key.keystore。密钥库包含单个键，有效10000天。别名是签署您的应用程序时，您将在以后使用的名称。 编译发布模式下您的应用程序，以获得一个无符号的APK。 使用jarsigner来签名你的app：12$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1-keystore my-release-key.keystore my_application.apk alias_name 上面提示您输入密钥库和密钥的密码。然后签名apk。 验证你的apk签名：1$ jarsigner -verify -verbose -certs my_application.apk … 使用zipalign来对齐apk包： 1$ zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk zipalign 确保所有的未压缩数据与特定字节对齐相对于文件，从而降低apk文件的大小。 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"公钥","slug":"公钥","permalink":"https://xuhaoblog.com/tags/公钥/"},{"name":"私钥","slug":"私钥","permalink":"https://xuhaoblog.com/tags/私钥/"}]},{"title":"使用Gradle和Nexus 搭建私有Maven仓库","slug":"maven","date":"2016-08-30T13:21:06.000Z","updated":"2017-11-04T11:07:09.000Z","comments":true,"path":"2016/08/30/maven/","link":"","permalink":"https://xuhaoblog.com/2016/08/30/maven/","excerpt":"前言：随着业务的增长，需求量增多，我们的App 组件也越来越多，几乎大部分组件都有用到同样的第三方库和公司内部封装的库，而团队中的所有人都重复的从maven 远程的中央仓库下载构建，这样就会加大了仓库的负载和浪费了外网的带宽，网速慢的话，就要等很久很久，半个小时，几个小时，都有可能！这样明显影响项目的开发进度，有的公司还是在内网的情况下开发，连接不到中央仓库怎么办？公司内部开发的公共组件怎么让其他项目共用呢？这个时候，我们不得不为自己的团队搭建一个私服maven仓库，来提高我们的开发效率。 起初，对gradle和maven不是很熟，看了网上的教程一脸懵逼，后来，花了点时间，发现整个过程也还是很简单的。↓↓ 首先我们来了解一下， 一、什么是Maven,Gradle?Maven 是一个项目管理和自动构建工具。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下开发用的库列表： 12345678mavenCentral();jcenter()maven &#123; url 'file:///Users/my-user-name/Documents/Android/repo/'&#125;maven &#123; url 'http://localhost:8081/nexus/content/repositories/releases/'&#125;","text":"前言：随着业务的增长，需求量增多，我们的App 组件也越来越多，几乎大部分组件都有用到同样的第三方库和公司内部封装的库，而团队中的所有人都重复的从maven 远程的中央仓库下载构建，这样就会加大了仓库的负载和浪费了外网的带宽，网速慢的话，就要等很久很久，半个小时，几个小时，都有可能！这样明显影响项目的开发进度，有的公司还是在内网的情况下开发，连接不到中央仓库怎么办？公司内部开发的公共组件怎么让其他项目共用呢？这个时候，我们不得不为自己的团队搭建一个私服maven仓库，来提高我们的开发效率。 起初，对gradle和maven不是很熟，看了网上的教程一脸懵逼，后来，花了点时间，发现整个过程也还是很简单的。↓↓ 首先我们来了解一下， 一、什么是Maven,Gradle?Maven 是一个项目管理和自动构建工具。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下开发用的库列表： 12345678mavenCentral();jcenter()maven &#123; url 'file:///Users/my-user-name/Documents/Android/repo/'&#125;maven &#123; url 'http://localhost:8081/nexus/content/repositories/releases/'&#125; Android Studio Gradle 主要支持两个 Maven 中央库：mavenCentral 和 jcenter。 mavenCentral 是最早的 maven 中央仓库 jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库 第三个是我的本机的仓库 第四个是笔者部署在内网服务器的私有仓库 Gradle 是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML 二、使用Nexus搭建maven私服 1.Nexus 下载安装：官网下载地址：http://www.sonatype.org/nexus/go/，我的开发环境是Windows，我下载的是Nexus Repository Manager OSS 2.xx下面的 All platforms nexus-2.13.0-01-bundle.zip压缩文件。↓ 2.Nexus 启动：下载完成之后，解压后进入\\nexus-2.1.2-bundle\\nexus-2.1.2\\bin\\jsw\\，根据操作系统类型选择文件夹，我选的是windows-x86-32文件夹，进入后可看到如下所示bat文件。 双击console-nexus.bat运行。再浏览器中输入http://127.0.0.1:8081/nexus/，出现图（2）所示就代表nexus已经启动成功了。 图(2) 8081是默认的端口号，要修改端口号，进入\\conf\\打开nexus.properties文件，修改application-port属性值就可以了。默认的用户名和密码分别是：admin和admin123。点击右上角的log in 登录后如图所示：点击左侧的 repositories 查看现有的仓库列表： 3.Nexus仓库： 这里的仓库分了四种类型 hosted(宿主仓库):用来部署自己,第三方或者公共仓库的构件 proxy(代理仓库):代理远程仓库 virtual(虚拟仓库):默认提供了一个 Central M1虚拟仓库 用来将maven 2适配为maven 1 group(仓库组):统一管理多个仓库 Public Repositories: 仓库组 3rd party: 无法从公共仓库获得的第三方发布版本的构件仓库 Apache Snapshots: 用了代理ApacheMaven仓库快照版本的构件仓库 Central: 用来代理maven中央仓库中发布版本构件的仓库 Central M1 shadow: 用于提供中央仓库中M1格式的发布版本的构件镜像仓库 Codehaus Snapshots: 用来代理CodehausMaven 仓库的快照版本构件的仓库 Releases: 用来部署管理内部的发布版本构件的宿主类型仓库 Snapshots:用来部署管理内部的快照版本构件的宿主类型仓库 4.建立Nexus宿主仓库 新建一个内部仓库，步骤为Repositories –&gt; Add –&gt; Hosted Repository，在页面的下半部分输入框中填入Repository ID和Repository Name即可，另外把Deployment Policy设置为Allow Redeploy，点击save就创建完成了。这里我点击添加宿主类型的仓库，在仓库列表的下方会出现新增仓库的配置，如下所示： 建立好新的仓库之后需要配置一下相关账号信息.在安全选项下选择用户选项,可以看到三个默认的账号,分别是管理员账号,部署账号和Nexus账号.正常访问仓库内容的时候是不需要这三个账户的,一般也就是把部署账号暴露出去,方便仓库项目维护人员部署项目使用.所以这里可以用默认的Deployment账户(记得重置下密码).也可以新建一个账号来使用,新建的时候可以通过add role management来控制该账号的权限。点击新建的仓库的url可以直接如今仓库的路劲，因为现在还没有部署项目，所以是空的仓库。 至此，搭建私服的maven仓库就已经完成，下面继续介绍Android 端在AS 上面的应用。 三、上传库到Maven仓库 上传库到maven仓库有两种方式，我们先来介绍第一种： 首先我们创建一个新的AndroidStudio 项目，然后新建一个module，选择Android Library。 然后，我们随便写一个功能供别人使用。例如我写一个ToastUtils： 然后RebuildProject生成依赖的arr包。 2.在MavenRepoDemo项目的根目录的build.gradle中配置刚刚建立的仓库： 1234567891011allprojects &#123; repositories &#123; jcenter() maven&#123; url 'http://localhost:8081/nexus/content/repositories/releases/'&#125; &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 在同目录下配置gradle.properties文件，定义通用属性，方便如果有多个库需要部署时，不需要修改每一个库中的配置： 123456789101112131415161718192021#Maven仓库的URLMAVEN_REPO_RELEASE_URL=http://localhost:8081/nexus/content/repositories/releases/MAVEN_REPO_SNAPSHOT_URL=http://localhost:8081/nexus/content/repositories/snapshots/#对应maven的GroupId的值GROUP = common#登录nexus ossde的用户名NEXUS_USERNAME=admin#登录nexus oss的密码NEXUS_PASSWORD=admin123# groupidGROUP_ID = common# typeTYPE = aar# descriptionDESCRIPTION = This is Toast lib 这里的仓库我用的是Nexus 原有的仓库（你可以换成刚刚新建的仓库地址）。 修改module对应的build.gradle文件，添加以下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263apply plugin: 'com.android.library'apply plugin: 'maven'android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.3\" defaultConfig &#123; minSdkVersion 19 targetSdkVersion 23 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125; &#125; lintOptions &#123; abortOnError false &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.4.0'&#125;uploadArchives &#123; configuration = configurations.archives repositories &#123; mavenDeployer &#123; snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123; authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) &#125; repository(url: MAVEN_REPO_RELEASE_URL) &#123; authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) &#125; pom.project &#123; version '1.0.0' artifactId 'toastutils-lib' groupId GROUP_ID packaging TYPE description DESCRIPTION &#125; &#125; &#125;&#125;artifacts &#123; archives file('toastutils.aar')&#125; 在as右边栏，找到Gradle打开如下： 然后双击uploadArchives，编译脚本并上传arr文件到私有仓库，最后在控制台可以看到日志是否上传成功。 可以去仓库查看到刚刚上传的库文件： 第二种，就是直接通过Nexus直接上传，这种就不详细说了，有兴趣的自己去研究下吧！ 嘿嘿 四、在项目中应用 在项目的根目录build.gradle配置如下： 在app目录下的build.gradle配置如下： 这样我们就完工了。在项目中调用我们库了，别人按照上面的配置就可以引用库使用了。 附上Demo的GitHub项目源码：MavenRepoDemo 对于频繁更新的子项目是否适合采用这种方式。因为每次变动都需要上传，而主项目在引用该AAR的时候则需要每次都去检查是否更新， 这会使得编译时间大大增加，有了这个maven库，就不用那么麻烦了。 想了解更多有关的资料： Nexus私服使Maven更加强大 拥抱的androidStudio 系列文章 博客比较全 学习理解并整理下来的笔记；希望大家能够指点或提出宝贵意见，谢谢！一起学习；","categories":[{"name":"maven","slug":"maven","permalink":"https://xuhaoblog.com/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://xuhaoblog.com/tags/maven/"}]},{"title":"C语言（七）文件的相关操作","slug":"c/c-file-operation","date":"2016-08-29T09:12:26.000Z","updated":"2017-11-04T11:01:59.000Z","comments":true,"path":"2016/08/29/c/c-file-operation/","link":"","permalink":"https://xuhaoblog.com/2016/08/29/c/c-file-operation/","excerpt":"C语言文件的打开与关闭 在C语言中，文件操作都是由库函数来完成的，我们就来总结文件的相关的操作。 文件的打开(fopen函数)fopen() 函数用来打开一个文件，它的格式为： 1FILE *fopen(char *filename, char *type); filename为文件名（包括文件路径），type为打开方式，它们都是字符串。fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。 如果接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如： 1FILE *fp = (\"demo.txt\", \"r\");","text":"C语言文件的打开与关闭 在C语言中，文件操作都是由库函数来完成的，我们就来总结文件的相关的操作。 文件的打开(fopen函数)fopen() 函数用来打开一个文件，它的格式为： 1FILE *fopen(char *filename, char *type); filename为文件名（包括文件路径），type为打开方式，它们都是字符串。fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。 如果接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如： 1FILE *fp = (\"demo.txt\", \"r\"); 上面是以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。fp 通常被称为文件指针。又如： 1FILE *fp = fopen(\"D:\\\\demo.txt\",\"rb\"); 表示以二进制方式打开 D 盘下的 demo.txt 文件，允许读和写。 打开方式(mode)有多种： 使用文件方式 含义“r”（只读） 为输入打开一个文本文件“w”（只写） 为输出打开一个文本文件“a”（追加） 为追加打开一个文本文件“rb”（只读） 为输入打开一个二进制文件“wb”（只写） 为输出打开一个二进制文件“ab”（追加） 为追加打开一个二进制文件“r+”（读写） 为读／写打开一个文本文件“w+”（读写） 为读／写创建一个文本文件“a+”（读写） 为读／写打开一个文本文件“rb+”（读写） 为读／写打开一个二进制文件“wb+”（读写） 为读／写创建一个二进制文件“ab+”（读写） 为读／写打开一个二进制文件 在打开一个文件时，如果出错，fopen将返回一个空指针值NULL，因此，我们可以在程序中这样来处理 12345if( (fp=fopen(\"D:\\\\demo.txt\",\"rb\") == NULL )&#123; printf(\"open file is error D:\\\\demo.txt file!\"); getchar(); exit(1);&#125; 如果再打开文件是，返回的指针为空，则表示不能打开D盘跟目录下的demo.txt 文件，输出提示的错误信息！！printf(“open file is error D:\\demo.txt file!”); 文件关闭（fclose函数）fp 为文件指针。例如： 1fclose(fp); 文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。 C中文本文件和二进制文件的区别下面这段摘自网上： 从文件编码的方式来看，文件可分为ASCII码文件和二进制码文件两种。 ASCII文件也称为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。例如，数5678的存储形式为：ASC码： 00110101 00110110 00110111 00111000 ↓ ↓ ↓ ↓十进制码： 5 6 7 8 共占用4个字节。ASCII码文件可在屏幕上按字符显示， 例如源程序文件就是ASCII文件，用DOS命令TYPE可显示文件的内容。 由于是按字符显示，因此能读懂文件内容。 二进制文件是按二进制的编码方式来存放文件的。 例如， 数5678的存储形式为： 00010110 00101110只占二个字节。二进制文件虽然也可在屏幕上显示， 但其内容无法读懂。C系统在处理这些文件时，并不区分类型，都看成是字符流，按字节进行处理。 输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’/n’，而二进制模式认为它是两个字符0x0D,0x0A；如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数据作相应的转换。 C语言以字符形式读写文件以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数：fgetc()和fputc()。 字符读取函数 fgetcfgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。它的原型为： 1int fgetc (FILE *fp); fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。 EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。 EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。 fgetc() 使用举例： 123char ch;FILE *fp = fopen(\"D:\\\\demo.txt\", \"r+\");ch = fgetc(fp); 表示从D:\\demo.txt文件中读取一个字符，并保存到变量ch中。 在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用fgetc 函数后，该指针会向后移动一个字节，所以可以连续多次使用fgetc读取多个字符。 注意：这个文件内部的位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是透明的。 实例： 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; FILE *fp; char ch; //如果文件不存在，给出提示并退出 if( (fp=fopen(\"D:\\\\demo.txt\",\"rt\")) == NULL )&#123; printf(\"Cannot open file, press any key to exit!\"); getch(); exit(1); &#125; //每次读取一个字节，直到读取完毕 while( (ch=fgetc(fp)) != EOF )&#123; putchar(ch); &#125; putchar('\\n'); //输出换行符 fclose(fp); return 0;&#125; 在D盘下创建demo.txt文件，输入任意内容并保存，运行程序，就会看到刚才输入的内容全部都显示在屏幕上。 该程序的功能是从文件中逐个读取字符，在屏幕上显示，直到读取完毕。 程序第14行是关键，while 循环的条件为(ch=fgetc(fp)) != EOF。fget() 每次从位置指针所在的位置读取一个字符，并保存到变量 ch，位置指针向后移动一个字节。当文件指针移动到文件末尾时，fget() 就无法读取字符了，于是返回 EOF，表示文件读取结束了。 对EOF的说明EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回EOF时，到底是文件读取完毕了还是读取出错了？我们可以借助 stdio.h 中的两个函数来判断，分别是 feof() 和 ferror()。 feof() 函数用来判断文件内部指针是否指向了文件末尾，它的原型是： 1int feof ( FILE * fp ); 当指向文件末尾时返回非零值，否则返回零值。 ferror() 函数用来判断文件操作是否出错，它的原型是： 1int ferror ( FILE *fp ); 出错时返回非零值，否则返回零值。 需要说明的是，文件出错是非常少见的情况，上面的示例基本能够保证将文件内的数据读取完毕。如果追求完美，也可以加上判断并给出提示： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; FILE *fp; char ch; //如果文件不存在，给出提示并退出 if( (fp=fopen(\"D:\\\\demo.txt\",\"rt\")) == NULL )&#123; printf(\"Cannot open file, press any key to exit!\"); getch(); exit(1); &#125; //每次读取一个字节，直到读取完毕 while( (ch=fgetc(fp)) != EOF )&#123; putchar(ch); &#125; putchar('\\n'); //输出换行符 if(ferror(fp))&#123; puts(\"读取出错\"); &#125;else&#123; puts(\"读取成功\"); &#125; fclose(fp); return 0;&#125; 这样，不管是出错还是正常读取，都能够做到心中有数。 字符写入函数fputcfputc 是 file output char 的所以，意思是向指定的文件中写入一个字符。调用的形式为： 1int fputc ( int ch, FILE *fp ); ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回EOF，返回值类型为 int 也是为了容纳这个负数。例如： 1fputc('a', fp); 或 12char ch = 'a';fputc(ch, fp); 表示把字符 ‘a’ 写入fp所指向的文件中。 两点说明： 1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。 2) 每写入一个字符，文件内部位置指针向后移动一个字节。 123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; FILE *fp; char ch; //判断文件是否成功打开 if( (fp=fopen(\"D:\\\\demo.txt\",\"wt+\")) == NULL )&#123; printf(\"Cannot open file, press any key to exit!\\n\"); getch(); exit(1); &#125; printf(\"Input a string:\\n\"); //每次从键盘读取一个字符并写入文件 while ( (ch=getchar()) != '\\n' )&#123; fputc(ch,fp); &#125; fclose(fp); return 0;&#125; 运行程序，输入一行字符并按回车键结束，打开D盘下的demo.txt文件，就可以看到刚才输入的内容。 C语言以字符串形式读写文件上面一个模块fgetc()和fputc()函数每次只能读写一个字符，速度比较慢，在实际过程中是每次读写一个字符串或者一个数据块，这样能明显提高效率。 读字符串函数fgetsfgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，它的原型为： 1char *fgets ( char *str, int n, FILE *fp ); str 为字符数组，n 为要读取的字符数目，fp 为文件指针。返回值：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。 读取到的字符串会在末尾自动添加 ‘\\0’，n 个字符也包括 ‘\\0’。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。例如： 1234#define N 101char str[N];FILE *fp = fopen(\"D:\\\\demo.txt\", \"r\");fgets(str, N, fp); 表示从 D:\\demo.txt 中读取100个字符，并保存到字符数组str中。 需要重点说明的是，在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。这就意味着，不管n的值多大，fgets() 最多只能读取一行数据，不能跨行。在C语言中，没有按行读取文件的函数，我们可以借助 fgets()，将n的值设置地足够大，每次就可以读取到一行数据。 一行一行的读取文件，代码如下： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 100int main()&#123; FILE *fp; char str[N+1]; if( (fp=fopen(\"d:\\\\demo.txt\",\"rt\")) == NULL )&#123; printf(\"Cannot open file, press any key to exit!\\n\"); getch(); exit(1); &#125; while(fgets(str, N, fp) != NULL)&#123; printf(\"%s\", str); &#125; fclose(fp); system(\"pause\"); return 0;&#125; 在这个D:\\demo.txt：文件中写入下面的内容： My Name is Android Google 那么编译运行上面的程序，结果为： 12My Name is Android Google 请按任意键继续... 写字符串函数fputsfputs 函数是指想一个文件中写入一个字符串，它的原型为： 1int fputs(char *str,FILE *fp); str为要写入的字符串，fp为文件指针，写入成功返回非负数，失败返回EOF。 eg： 12char *str = \"xuhao\";FILE *fp = fopen(\"D:\\\\demo.text\",\"a+\"); 表示把字符串str写入到D：\\demo.txt文件中。 在上述代码中建立的D：\\demo.txt 文件中追加一个字符串。 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; FILE *fp; char str[102] = &#123;0&#125;, strTemp[100]; if( (fp=fopen(\"D:\\\\demo.txt\", \"at+\")) == NULL )&#123; printf(\"Cannot open file, press any key to exit!\\n\"); getch(); exit(1); &#125; printf(\"Input a string:\"); gets(strTemp); strcat(str, \"\\n\"); strcat(str, strTemp); fputs(str, fp); fclose(fp); return 0;&#125; 编译并运行程序，在弹出的视图中 输入java C++，打开 D:\\demo.txt，文件内容为： 123My Name is Android Google java C++ C语言中其他文件的操作比如文件复制，代码如下：1234567891011121314151617181920void main()&#123; char *read_path = \"E:\\\\dongnao\\\\vip\\\\ndk\\\\08_08_C_05\\\\files\\\\liuyan.png\"; char *write_path = \"E:\\\\dongnao\\\\vip\\\\ndk\\\\08_08_C_05\\\\files\\\\liuyan_new.png\"; //读的文件 b字符表示操作二进制文件binary FILE *read_fp = fopen(read_path, \"rb\"); //写的文件 FILE *write_fp = fopen(write_path, \"wb\"); //复制 int buff[50]; //缓冲区域 int len = 0; //每次读到的数据长度 while ((len = fread(buff, sizeof(int), 50, read_fp)) != 0)&#123; //将读到的内容写入新的文件 fwrite(buff,sizeof(int),len,write_fp); &#125; //关闭流 fclose(read_fp); fclose(write_fp); getchar();&#125; 12345678910111213//获取文件的大小void main()&#123; char *read_path = \"E:\\\\dongnao\\\\vip\\\\ndk\\\\08_08_C_05\\\\files\\\\liuyan.png\"; FILE *fp = fopen(read_path, \"r\"); //重新定位文件指针 //SEEK_END文件末尾，0偏移量 fseek(fp,0,SEEK_END); //返回当前的文件指针，相对于文件开头的位移量 long filesize = ftell(fp); printf(\"%d\\n\",filesize); getchar();&#125; 常用的文件操作也就上面的几种了，有关文件的加密和解密，二进制文件的加密和解密，可能后面应该会结合JNI调用和NDK开发和实现的，好了，这篇文章到此为止！ CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C语言（六）结构体和联合体","slug":"c/structure-union","date":"2016-08-24T16:18:26.000Z","updated":"2017-11-04T11:02:59.000Z","comments":true,"path":"2016/08/25/c/structure-union/","link":"","permalink":"https://xuhaoblog.com/2016/08/25/c/structure-union/","excerpt":"结构体在C语言中，可以使用结构体（Struct）来存放一组不同类型的数据。结构体的定义形式为： 123struct 结构体名&#123; 结构体所包含的变量或数组&#125;; 结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。请看下面的一个栗子： 1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125;;","text":"结构体在C语言中，可以使用结构体（Struct）来存放一组不同类型的数据。结构体的定义形式为： 123struct 结构体名&#123; 结构体所包含的变量或数组&#125;; 结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。请看下面的一个栗子： 1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125;; stu 为结构体名，它包含了 5 个成员，分别是 name、num、age、group、score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。 注意大括号后面的分号“；”不能少哦~ 结构体也是一种数据类型，它由我们自己来定义，可以包含多个其他类型的数据。像int、float、char 等是由C语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可以包含多个基本类型的数据，也可以包含其他的结构体。 结构体变量既然结构体是一种数据类型，那么就可以用它来定义变量。例如： 1struct stu stu1, stu2; 定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字struct不能少。 还可以在定义结构体的同时定义结构体变量： 1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2; 如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示： 1234567struct&#123; //没有写 stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2; 这样的写法很简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量了。 理论上讲结构体的各个成员在内存中是连续存储的，和数组非常类似，例如上面的结构体变量 stu1、stu2 的内存分布如下图所示，共占用 4+4+4+1+4 = 17 个字节。但是在编译器的具体实现中，各个成员之间可能会存在空隙，C语言中，结构体大小的内存分配，参考于这片文章：C语言中结构体大小计算即存储分配 这里我在做下总结： 运算符sizeof可以计算出给定类型的大小，对于32位系统来说，sizeof(char) = 1; sizeof(int) = 4。基本数据类型的大小很好计算，我们来看一下如何计算构造数据类型的大小。 C语言中的构造数据类型有三种：数组、结构体和共用体。 数组是相同类型的元素的集合，只要会计算单个元素的大小，整个数组所占空间等于基础元素大小乘上元素的个数。 结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。看下面这样的一个结构体： 123456 struct stu1 &#123; int i; char c; int j; &#125;； 先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址 的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏 移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成 员的大小（4+1）,其值为5。 实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 二、结构体大小必须是所有成员大小的整数倍。 对照第一条，上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。 对照第二条，结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。 再看一个满足第一条，不满足第二条的情况： 12345 struct stu2 &#123; int k; short t; &#125;； 成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不 是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。由此可见，大家在定义结构体类型时需要考虑 到字节对齐的情况，不同的顺序会影响到结构体的大小。对比下面两种定义顺序 12345678910111213 struct stu3 &#123; char c1; int i; char c2; &#125; struct stu4 &#123; char c1; char c2; int i; &#125; 虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8。 如果结构体中的成员又是另外一种结构体类型时应该怎么计算呢？只需把其展开即可。但有一点需要注意，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。看下面的例子： 1234567891011 struct stu5 &#123; short i; struct&#123; char c; int j; &#125; ss; int k; &#125; 结构体stu5的成员ss.c的偏移量应该是4，而不是2。整个结构体大小应该是16。 如何给结构体变量分配空间由编译器决定，以上情况针对的是Linux下的GCC。其他平台的C编译器可能会有不同的处理，看到这里估计还是有些同学不太明白，多看几遍，领悟领悟，就好啦！ 成员的获取和赋值结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标[ ]获取单个元素，结构体使用点号.获取单个成员。获取结构体成员的一般格式为： 1结构体变量名.成员名; 通过上面的格式就可以获取成员的值，和给成员赋值，看下面的栗子： 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩 &#125; stu1; //给结构体成员赋值 stu1.name = \"haozi\"; stu1.num = 12; stu1.age = 18; stu1.group = 'A'; stu1.score = 136.5; //读取结构体成员的值 printf(\"%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\\n\", stu1.name, stu1.num, stu1.age, stu1.group, stu1.score); return 0;&#125; 运行结果：haozi的学号是12，年龄是18，在A组，今年的成绩是136.5！除了这种方式赋值外，还可以在定义的时候赋值： 1234567struct&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1, stu2 = &#123; \"haozi\", 12, 18, 'A', 136.5 &#125;; 不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。 结构体与指针指针也可以指向一个结构体，定义的形式一般为： 1struct 结构体名 *变量名; 看例子：12345678910111213141516struct Man&#123; char name[20]; int age;&#125;;void main()&#123; struct Man m1 = &#123;\"Jack\",30&#125;; //结构体指针 struct Man *p = &amp;m1; printf(\"%s,%d\\n\", m1.name, m1.age); printf(\"%s,%d\\n\",(*p).name,(*p).age); //“-&gt;”（箭头）是“(*p).”简写形式 printf(\"%s,%d\\n\", p-&gt;name, p-&gt;age); //(*env)-&gt; system(\"pause\");&#125; 编译出的结果是： 1234Jack,30Jack,30Jack,30请按任意键继续. . . 上面代码：printf(“%s,%d\\n”, m1.name, m1.age);还可以换成： printf(“%s,%d\\n”, （*p）.name, m1.age);或者 printf(“%s,%d\\n”, p-&gt;name, m1.age);其运行结果还是一样的。 获取结构体成员通过结构体指针可以获取结构体成员，一般形式为： 1(*pointer).memberName 或者： 1pointer-&gt;memberName 联合体（共用体）结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为： 123union 共用体名&#123; 成员列表&#125;; 共用体有时也被成为联合体； 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 共用体也是一种自定义类型，可以通过它来创建变量，例如： 123456union data&#123; int n; char ch; double f;&#125;;union data a, b, c; 上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量： 12345union data&#123; int n; char ch; double f;&#125; a, b, c; 共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存，请看下面的栗子： 12345678910111213141516#include&lt;stdio.h&gt; union var&#123; long j; int i; &#125;; main()&#123; union var v; v.j = 5; printf(\"v.j is %d\\n\",v.i); v.i = 6; //最后一次赋值有效 printf(\"now v.j is %ld! the address is %p\\n\",v.j,&amp;v.j); printf(\"now v.i is %d! the address is %p\\n\",v.i,&amp;v.i); system(\"pause\");&#125; 编译并运行结果： 123v.j is 5 now v.j is 6! the address is 0xbfad1e2c now v.i is 6! the address is 0xbfad1e2c 这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。 CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C语言（五）内存分配与释放","slug":"c/memory_allocation","date":"2016-08-23T05:10:26.000Z","updated":"2017-11-04T11:02:43.000Z","comments":true,"path":"2016/08/23/c/memory_allocation/","link":"","permalink":"https://xuhaoblog.com/2016/08/23/c/memory_allocation/","excerpt":"首先我们来科普一下： 什么是堆？说到堆，又忍不住说到了栈！什么是 栈？1、什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。2、什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。","text":"首先我们来科普一下： 什么是堆？说到堆，又忍不住说到了栈！什么是 栈？1、什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。2、什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。 C语言程序编译的内存分配，堆与栈的区别： 栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。再强调一次，记得要释放！ 栈区(stack) : //windows下，栈内存分配2M（确定的常数），超出了限制，提示stack overflow错误 //编译器自动分配释放，主要存放函数的参数值，局部变量值等； 堆区(heap)：程序员手动分配释放，操作系统80%内存 全局区或静态区：存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区和全局未初始化区； 字符常量区：常量字符串放与此，程序结束时由系统释放； 程序代码区：存放函数体的二进制代码。 栗子： 12345678910111213int a=0; //全局初始化区char *p1; //全局未初始化区void main()&#123; int b; //栈 char s[]=\"bb\"; //栈 char *p2; //栈 char *p3=\"123\"; //其中，“123\\0”常量区，p3在栈区 static int c=0; //全局区 p1=(char*)malloc(10); //10个字节区域在堆区 strcpy(p1,\"123\"); //\"123\\0\"在常量区，编译器 可能 会优化为和p3的指向同一块区域 &#125; 栈内存 1234void stackFun()&#123; int a[1024]; //栈内存自动释放&#125; 堆内存 123456789void heapFun()&#123; //40M内存 //字节 //void *任意类型的指针 int* p = malloc(1024 * 1024 * 10 * sizeof(int)); //释放 free(p);&#125; 123456789void main()&#123; //在堆内存上，分配40M的内存 while (1)&#123; Sleep(1000); stackFun(); &#125; getchar();&#125; 创建一个数组，动态指定数组的大小（在程序运行过长中，可以随意的开辟指定大小的内存，以供使用，相当于Java中的集合）静态内存分配，分配内存大小的是固定，问题：1.很容易超出栈内存的最大值 2.为了防止内存不够用会开辟更多的内存，容易浪费内存 动态内存分配，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用（活水） 函数：calloc() 分配内存空间并初始化calloc() 函数用来动态地分配内存空间并初始化为 0，其原型为： 1void* calloc (size_t num, size_t size); calloc() 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。 函数：malloc() 动态地分配内存空间 malloc() 函数用来动态地分配内存空间（如果你不了解动态内存分配，请查看：C语言动态内存分配及变量存储类别），其原型为： 1void* malloc (size_t size); 应用在程序中代码如下：12345678910111213141516171819202122232425void main()&#123; //静态内存分配创建数组，数组的大小是固定的 //int i = 10; //int a[i]; int len; printf(\"输入数组的长度：\"); scanf(\"%d\",&amp;len); //开辟内存，大小len*4字节 int* p = malloc(len * sizeof(int)); //p是数组的首地址，p就是数组的名称 //给数组元素赋值（使用这一块刚刚开辟出来的内存区域） int i = 0; for (; i &lt; len - 1; i++)&#123; p[i] = rand() % 100; printf(\"%d,%#x\\n\", p[i], &amp;p[i]); &#125; //手动释放内存 //free()释放动态分配的内存空间 free(p); getchar();&#125; realloc 重新分配内存 12345678910111213141516171819202122void main()&#123; int len; printf(\"第一次输入数组的长度：\"); scanf(\"%d\", &amp;len); //int* p = malloc(len * sizeof(int)); int* p = calloc(len, sizeof(int)); int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf(\"%d,%#x\\n\", p[i], &amp;p[i]); &#125; int addLen; printf(\"输入数组增加的长度：\"); scanf(\"%d\", &amp;addLen); //内存不够用，扩大刚刚分配的内存空间 //1.原来内存的指针 2.内存扩大之后的总大小 int* p2 = realloc(p, sizeof(int) * (len + addLen)); if (p2 == NULL)&#123; printf(\"重新分配失败，世界那么大，容不下我。。。\"); &#125; 新分配内存的两种情况： //缩小，缩小的那一部分数据会丢失 //扩大，（连续的） 1.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针 2.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据库释放掉，返回新的内存地址 3.如果申请失败，返回NULL，原来的指针仍然有效1234567891011121314151617181920//接着上面的代码重新赋值 i = 0; printf(\"--------------------------\\n\"); for (; i &lt; len + addLen; i++)&#123; p2[i] = rand() % 200; printf(\"%d,%#x\\n\", p2[i], &amp;p2[i]); &#125; //手动释放内存 if (p != NULL)&#123; free(p); p = NULL; &#125; if (p2 != NULL)&#123; free(p2); p2 = NULL; &#125; getchar();&#125; 内存分配的几个注意细节1.不能多次释放；2.释放完之后（指针仍然有值），给指针置NULL，标志释放完成；3.内存泄露（p重新赋值之后，再free，并没有真正释放内存）； 12345678910111213141516171819void main()&#123; int len; printf(\"输入数组的长度：\"); scanf(\"%d\", &amp;len); int* p = malloc(len * sizeof(int)); int i = 0; for (; i &lt; len; i++)&#123; p[i] = rand() % 100; printf(\"%d,%#x\\n\", p[i], &amp;p[i]); &#125; if (p != NULL)&#123; free(p); p = NULL; &#125; getchar();&#125; 以上就是C语言中对内存的分配与释放，常用的几个函数~ CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C语言（四）指针概念的理解","slug":"c-pointers","date":"2016-08-22T06:41:06.000Z","updated":"2017-04-07T10:10:10.000Z","comments":true,"path":"2016/08/22/c-pointers/","link":"","permalink":"https://xuhaoblog.com/2016/08/22/c-pointers/","excerpt":"前言最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了） 指针 我们通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有必要的。正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：","text":"前言最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了） 指针 我们通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有必要的。正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： 123456789101112#include &lt;stdio.h&gt;int main ()&#123; int var1; char var2[10]; printf(\"var1 变量的地址： %x\\n\", &amp;var1 ); printf(\"var2 变量的地址： %x\\n\", &amp;var2 ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12var1 变量的地址： bff5a400var2 变量的地址： bff5a3f6 通过上面的栗子，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针吧！ 什么是指针？指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *name; 这里的type 是指针的基类型，它必须是一个有效的 C 数据类型，name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针？ 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 123456789101112131415161718#include &lt;stdio.h&gt;//指针//指针存储的是变量的内存地址//内存地址，系统给数据分配的编号（门牌号）void main()&#123; int i = 90; //指针变量，创建一个int类型的指针 int* p = &amp;i; //p的值就是i这个变量的内存地址 printf(\"%#x\\n\",p); float f = 89.5f; //创建一个float类型的指针 float *fp = &amp;f; printf(\"%#x\\n\", fp); system(\"pause\");&#125; 上面的代码被编译和执行时，运行的结果： 1230xeffb300xeffb18请按任意键继续. . . 对指针存的地址指向的变量进行操作 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void change(int* p)&#123; *p = 300;&#125;//变量名，对内存空间上的一段数据的抽象void main()&#123; int i = 90; //i = 89; //创建一个int类型的指针 int *p = &amp;i; //输出地址 printf(\"p的地址：%#x\\n\",&amp;p); printf(\"i的地址：%#x\\n\",&amp;i); printf(\"i的值为：%d\\n\", i); //间接赋值 i = 200; //对p存的地址指向的变量进行操作 //*p = 200; //change(p); change(&amp;i); // int *p = &amp;i; printf(\"i的值为：%d\\n\",i); system(\"pause\");&#125; 上面代码编译执行结果如下： 12345p的地址：0x6ffdb0i的地址：0x6ffdbci的值为：90i的值为：300请按任意键继续. . . 通过上面栗子，我们可以看出，指针所指向的变量值已经被更改了。 C中的NULL 指针在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序： 12345678910#include &lt;stdio.h&gt;int main ()&#123; int *ptr = NULL; printf(\"ptr 的值是 %x\\n\", ptr ); return 0;&#125; 运行结果为： 1ptr 的值是 0 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。如需检查一个空指针，您可以使用 if 语句，如下所示： 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; char *s = \"hello\"; if (!s) &#123; fprintf(stderr, \"s is null\\n\"); &#125; else &#123; fprintf(stderr, \"%s\\n\", s); &#125; if (s == NULL) &#123; fprintf(stderr, \"s is null\\n\"); &#125; else &#123; fprintf(stderr, \"%s\\n\", s); &#125; return 0;&#125; 这两种方法都能判断字符指针是否为空，但推荐使用前者。”NULL” 的本质是个宏，并非是个常量，C99 中甚至可以自行定义，故尽量避免使用它去判断，当 !s 与 s == NULL 表示同一含义的时候，使用前者吧！ C中的二级指针（多级指针）指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int 、double 、char * 等。 如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示： 用代码表示为： 123int a =100;int *p1 = &amp;a;int **p2 = &amp;p1; 指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号 。p1 是一级指针，指向普通类型的数据，定义时有一个 ；p2 是二级指针，指向一级指针 p1，定义时有两个*。 如果再定义一个三级指针 p3，让它指向 p2，那么可以这样写： 1int ***p3 = &amp;p2; 四级指针： 1int ****p4 = &amp;p3; 等等，以此类推。。。不过，经常使用的也就是一级指针和二级指针了。在获取指针指向的数据时，一级指针加一个 ，二级指针加两个 ，三级指针加三个 *，以此类推，请看代码： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int a =100; int *p1 = &amp;a; int **p2 = &amp;p1; int ***p3 = &amp;p2; printf(\"%d, %d, %d, %d\\n\", a, *p1, **p2, ***p3); printf(\"&amp;p2 = %#X, p3 = %#X\\n\", &amp;p2, p3); printf(\"&amp;p1 = %#X, p2 = %#X, *p3 = %#X\\n\", &amp;p1, p2, *p3); printf(\" &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\\n\", &amp;a, p1, *p2, **p3); return 0;&#125; 编译并运行结果如下： 以三级指针 p3 为例来分析上面的代码。** p3等价于 ( ( p3))。 p3 得到的是 p2 的值，也即 p1 的地址； ( p3) 得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后， ( *(p3)) 得到的才是 a 的值。 假设 a、p1、p2、p3 的地址分别是 0X00A0、0X1000、0X2000、0X3000，它们之间的关系可以用下图来描述： 方框里面是变量本身的值，方框下面是变量的地址。 C中指针的运算指针变量保存的是地址，本质上是一个整数，可以进行部分运算，例如加法、减法、比较等，请看下面的代码： 1234567891011121314151617181920#include &lt;stdio.h&gt;//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式void main()&#123; //数组在内存中连续存储 int ids[] = &#123; 78, 90, 23, 65, 19 &#125;; //数组变量名：ids就是数组的首地址 printf(\"%#x\\n\",ids); printf(\"%#x\\n\",&amp;ids); printf(\"%#x\\n\",&amp;ids[0]); //指针变量 int *p = ids; printf(\"%d\\n\",*p); //指针的加法 p++; //p++向前移动sizeof(数据类型)个字节 printf(\"p的值:%#x\\n\", p); //p--; printf(\"%d\\n\", *p); getchar();&#125; 编译并运行的结果如下： 1234560x5ff7d00x5ff7d00x5ff7d078p的值:0x5ff7d490 从上面的栗子来看，数组变量名：ids就是数组的首地址，指针的加法，p++就是向前移动了sizeof(数据类型)个字节。我们知道，数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，不过C语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。 下面举一个栗子，通过指针获取下一个变量的地址： 12345678910#include &lt;stdio.h&gt;int main()&#123; int a = 1, b = 2, c = 3; int *p = &amp;c; int i; for(i=0; i&lt;8; i++)&#123; printf(\"%d, \", *(p+i) ); &#125; return 0;&#125; 编译并运行结果如下： 13, -858993460, -858993460, 2, -858993460, -858993460, 1, -858993460, 可以看出变量 a、b、c 并不挨着，它们中间还有其他的数据。 指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。所以总结出，不要对指向普通变量的指针进行加减运算；另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。 C中的指针数组如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为： 1dataType *arrayName[length]; ]的优先级高于*，该定义形式应该理解为： 1dataType *(arrayName[length]); 括号里面说明arrayName是一个数组，包含了length个元素，括号外面说明每个元素的类型为dataType *。 除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的栗子： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a = 16, b = 932, c = 100; //定义一个指针数组 int *arr[3] = &#123;&amp;a, &amp;b, &amp;c&#125;;//也可以不指定长度，直接写作 int *parr[] //定义一个指向指针数组的指针 int **parr = arr; printf(\"%d, %d, %d\\n\", *arr[0], *arr[1], *arr[2]); printf(\"%d, %d, %d\\n\", **(parr+0), **(parr+1), **(parr+2)); return 0;&#125; 编译并运行结果如下： 1216, 932, 10016, 932, 100 arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。 parr 是指向数组 arr 的指针，确切地说是指向 arr 第一个元素的指针，它的定义形式应该理解为int ( parr)，括号中的 表示 parr 是一个指针，括号外面的int 表示 parr 指向的数据的类型。arr 第一个元素的类型为 int ， 所以在定义 parr 时要加两个 （星号）（MD语法自动识别其他的格式了）。 第一个 printf() 语句中，arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 才能取得它指向的数据，也即 arr[i] 的形式。 第二个 printf() 语句中，parr+i 表示第 i 个元素的地址， (parr+i) 表示获取第 i 个元素的值（该元素是一个指针），*(parr+i) 表示获取第 i 个元素指向的数据。 通过指针给数组赋值，下面是一个简单的栗子： 12345678910111213141516171819#include &lt;stdio.h&gt;void main()&#123; int uids[5]; //高级写法 //int i = 0; //for (; i &lt; 5; i++)&#123; // uids[i] = i; //&#125; //早些版本的写法 int* p = uids; printf(\"%#x\\n\",p); int i = 0; //i是数组元素的值 for (; p &lt; uids + 5; p++)&#123; *p = i; i++; &#125; getchar();&#125; C中的指针与二维数组二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例： 1int a[3][4] = &#123; &#123;0, 1, 2, 3&#125;, &#123;4, 5, 6, 7&#125;, &#123;8, 9, 10, 11&#125; &#125;; 从概念上来理解，数组a 的分布如下： 1230 1 2 34 5 6 78 9 10 11 但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存： C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。 C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0][0]、a[0][1]、a[0][2]、a[0][3]。 假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示： 为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p： 1int (*p)[4] = a; int *p[4]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。 int (*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。 123区分int *p[n]; 和int (*p)[n]; 就要看运算符的优先级了。int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。 对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。 下面我们就来实现如何使用指针 p 来访问二维数组中的每个元素。按照上面的定义： p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。 *(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点： 1234567#include &lt;stdio.h&gt;int main()&#123; int a[3][4] = &#123; &#123;0, 1, 2, 3&#125;, &#123;4, 5, 6, 7&#125;, &#123;8, 9, 10, 11&#125; &#125;; int (*p)[4] = a; printf(\"%d\\n\", sizeof(*(p+1))); return 0;&#125; 编译并运行结果为： 116 那么，*(p+1)+1表示第 1 行第 1 个元素的地址。这个如何理解呢？（注意，这里的小细节） 1*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、&amp; 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。 1* ( *(p+1)+1) 表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。 根据上面的推论，推出以下等价关系： 123a+i == p+ia[i] == p[i] == *(a+i) == *(p+i)a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j) 可能有点绕，不好理解，不过没关系，多看几遍，相信你是可以的。 栗子：使用指针遍历二维数组123456789101112#include &lt;stdio.h&gt;int main()&#123; int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;; int(*p)[4]; int i,j; p=a; for(i=0; i&lt;3; i++)&#123; for(j=0; j&lt;4; j++) printf(\"%2d \",*(*(p+i)+j)); printf(\"\\n\"); &#125; return 0;&#125; 编译并运行的结果如下： 1230 1 2 34 5 6 78 9 10 11 指针数组和二维数组指针的区别： 指针数组和二维数组指针在定义时非常相似，只是括号的位置不同： 12int *(p1[5]); //指针数组，可以去掉括号直接写作 int *p1[5];int (*p2)[5]; //二维数组指针，不能去掉括号 指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。 C中的函数指针一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。 函数指针的定义形式为： 1returnType (*pointerName)(param list); returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。 注意： ( )的优先级高于，第一个括号不能省略，如果写作returnType pointerName(paramlist);就成了函数原型，它表明函数的返回值类型为returnType *。 下面写一个简单的栗子： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int msg(char* msg,char* title)&#123; MessageBox(0,msg,title,0); return 0;&#125;void main()&#123; //msg(); printf(\"%#x\\n\",msg); printf(\"%#x\\n\",&amp;msg); //函数指针 //函数返回值类型，函数指针的名称，函数的参数列表 int(*fun_p)(char* msg, char* title) = msg; fun_p(\"消息内容\",\"标题\"); getchar();&#125; 编译并运行结果如下： 上面对msg函数进行了调用，fun_p是一个函数指针。 总结：指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。 常见的指针含义： 123456- int *p; p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。- int **p; p 为二级指针，指向 int * 类型的数据。- int *p[n]; p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);- int (*p)[n]; p 为二维数组指针。- int *p(); p 是一个函数，它的返回值类型为 int *。- int (*p)(); p 是一个函数指针，指向原型为 int func() 的函数。 以上就是通过学习对指针的概念的理解，不能再写了，不然又是长篇大论，很难让读者看完，（我也不喜欢）。 CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。转载请注明出处：http://blog.csdn.net/u011974987/article/details/52270018个人主页：xuhaoblog.com","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C语言（三）字符串处理函数","slug":"c/language/string","date":"2016-08-13T11:30:00.000Z","updated":"2017-11-04T11:02:09.000Z","comments":true,"path":"2016/08/13/c/language/string/","link":"","permalink":"https://xuhaoblog.com/2016/08/13/c/language/string/","excerpt":"C语言提供了丰富的字符串处理函数，例如字符串的输入、输出、合并、修改、比较、转换、复制、搜索等，使用这些现成的函数可大大减轻编程的负担。 用于输入输出的字符串函数，例如printf、puts、scanf、gets等，使用时应包含头文件stdio.h，使用其它字符串函数则应包含头文件string.h。","text":"C语言提供了丰富的字符串处理函数，例如字符串的输入、输出、合并、修改、比较、转换、复制、搜索等，使用这些现成的函数可大大减轻编程的负担。 用于输入输出的字符串函数，例如printf、puts、scanf、gets等，使用时应包含头文件stdio.h，使用其它字符串函数则应包含头文件string.h。 1.字符串长度函数strlenstrlen 是 string length 的缩写，用来获得字符串的长度。所谓长度，就是包含多少个字符（不包括字符串结束标志 ‘\\0’）。语法格式为： 1strlen(arrayName); strlen 将返回字符串的长度，它是一个整数。请看下面的例子： 12345678#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char str[]=\"C language\"; int len = strlen(str); printf(\"The lenth of the string is %d\\n\", len); return 0;&#125; 运行结果： 1The lenth of the string is 10 需要说明的是，strlen 会从字符串的第 0 个字符开始计算，直到遇到字符串结束标志 ‘\\0’。将上面代码中的 str 改为： 1char str[]=\"C \\0language\"; 那么输出结果就是：The lenth of the string is 2 2.字符串连接函数 strcatstrcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为： 1strcat(arrayName1, arrayName2); arrayName1、arrayName2 为需要拼接的字符串。 strcat 将把 arrayName2 连接到 arrayName1 后面，并删去 arrayName1 最后的结束标志 ‘\\0’。这就意味着，arrayName1 的长度要足够，必须能够同时容纳 arrayName1 和 arrayName2，否则会越界。 strcat 返回值为 arrayName1 的首地址。请看下面的例子： 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char str1[40]=\"My name is \"; char str2[20]; printf(\"Input your name:\"); gets(str2); strcat(str1,str2); puts(str1); return 0;&#125; 运行结果： 12Input your name: xuhaoMy name is xuhao 3.字符串复制函数strcpystrcpy 是 string copy 的缩写，意思是字符串复制，语法格式为： 1strcpy(arrayName1, arrayName2); strcpy 会把 arrayName2 中的字符串拷贝到 arrayName1 中，串结束标志 ‘\\0’ 也一同拷贝。请看下面的例子： 123456789#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char str1[15], str2[]=\"C Language\"; strcpy(str1, str2); puts(str1); printf(\"\\n\"); return 0;&#125; 运行结果： C Language strcat 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。 4.字符串比较函数strcmpstrcmp 是 string compare 的缩写，意思是字符串比较，语法格式为： 1strcmp(arrayName1, arrayName2); arrayName1 和 arrayName2 是需要比较的两个字符串。 字符本身没有大小之分，strcmp() 是以各个字符在ASCII 码表上对应的数值进行比较的。strcmp() 首先将 arrayName1 中第0个字符的 ASCII 码值减去 arrayName2 中第0个字符的 ASCII 码值，若差值为 0，则说明两个字符相同，再继续比较下个字符，若差值不为 0 则将差值返回。例如字符串”Ac”和”ba”比较则会返回字符”A”(65)和’b’(98)的差值(－33)。 返回值：若 arrayName1 和 arrayName2 相同，则返回0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于0 的值。 下面对4组字符串进行比较。 12345678910111213#include &lt;string.h&gt;main()&#123; char *a = \"AaBbCc\"; char *b = \"AbCdEf\"; char *c = \"aacdef\"; char *d = \"AaBbCc\"; printf(\"strcmp(a, b) : %d\\n\", strcmp(a, b)); printf(\"strcmp(a, c) : %d\\n\", strcmp(a, c)); printf(\"strcmp(a, d) : %d\\n\", strcmp(a, d)); getchar();&#125; 运行结果： 123strcmp(a, b) : -1strcmp(a, c) : -1strcmp(a, d) : 0 CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C语言（二）有符号和无符号的理解","slug":"c/language/signed","date":"2016-08-07T07:43:20.000Z","updated":"2017-11-04T11:02:20.000Z","comments":true,"path":"2016/08/07/c/language/signed/","link":"","permalink":"https://xuhaoblog.com/2016/08/07/c/language/signed/","excerpt":"1.你自已决定是否需要有正负：就像我们必须决定某个量使用整数还是实数，使用多大的范围数一样，我们必须自已决定某个量是否需要正负。如果这个量不会有负值，那么我们可以定它为带正负的类型。 在计算机中，可以区分正负的类型，称为有符类型（signed），无正负的类型（只有正值），称为无符类型。 （unsigned）数值类型分为整型或实型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。 比如有两个量，年龄和库存，我们可以定前者为无符的字符类型，后者定为有符的整数类型。 2.使用二制数中的最高位表示正负: 首先得知道最高位是哪一位？1个字节的类型，如字符类型，最高位是第7位，2个字节的数，最高位是第15位，4个字节的数，最高位是第31位。不同长度的数值类型，其最高位也就不同，但总是最左边的那位（如下示意）。字符类型固定是1个字节，所以最高位总是第7位。","text":"1.你自已决定是否需要有正负：就像我们必须决定某个量使用整数还是实数，使用多大的范围数一样，我们必须自已决定某个量是否需要正负。如果这个量不会有负值，那么我们可以定它为带正负的类型。 在计算机中，可以区分正负的类型，称为有符类型（signed），无正负的类型（只有正值），称为无符类型。 （unsigned）数值类型分为整型或实型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。 比如有两个量，年龄和库存，我们可以定前者为无符的字符类型，后者定为有符的整数类型。 2.使用二制数中的最高位表示正负: 首先得知道最高位是哪一位？1个字节的类型，如字符类型，最高位是第7位，2个字节的数，最高位是第15位，4个字节的数，最高位是第31位。不同长度的数值类型，其最高位也就不同，但总是最左边的那位（如下示意）。字符类型固定是1个字节，所以最高位总是第7位。 (红色为最高位) 单字节数： 11111111双字节数：11111111 11111111四字节数：11111111 11111111 11111111 11111111当我们指定一个数量是无符号类型时，那么其最高位的1或0，和其它位一样，用来表示该数的大小。当我们指定一个数量是无符号类型时，此时，最高数称为“符号位”。为1时，表示该数为负值，为0时表示为正值。3.无符号数和有符号数的范围区别: 无符号数中，所有的位都用于直接表示该值的大小。有符号数中最高位用于表示正负，所以，当为正值时，该数的最大值就会变小。我们举一个字节的数值对比：无符号数： 11111111 值：255有符号数： 01111111 值：127eg：（本屌实在不知道怎么用md语法来打出数学公式，2的幂次方）同样是一个字节，无符号数的最大值是255，而有符号数的最大值是127。原因是有符号数中的最高位被挪去表示符号了。并且，我们知道，最高位的权值也是最高的（对于1字节数来说是2的7次方=128），所以仅仅少于一位，最大值一下子减半。不过，有符号数的长处是它可以表示负数。因此，虽然它的在最大值缩水了，却在负值的方向出现了伸展。我们仍一个字节的数值对比：无符号数： 0 —————– 255有符号数： -128 ——— 0 ———- 127同样是一个字节，无符号的最小值是 0 ，而有符号数的最小值是-128。所以二者能表达的不同的数值的个数都一样是256个。只不过前者表达的是0到255这256个数，后者表达的是-128到+127这256个数。一个有符号的数据类型的最小值是如何计算出来的呢？有符号的数据类型的最大值的计算方法完全和无符号一样，只不过它少了一个最高位（见第3点）。但在负值范围内，数值的计算方法不能直接使用1 26 + 1 25 的公式进行转换。在计算机中，负数除为最高位为1以外，还采用补码形式进行表达。所以在计算其值前，需要对补码进行还原。 这里，先直观地看一眼补码的形式：在10进制中：1 表示正1，而加上负号：-1 表示和1相对的负值。那么，我们会很容易认为在2进制中（1个字节）： 0000 0001 表示正1，则高位为1后：1000 0001应该表示-1。然而，事实上计算机中的规定有些相反，请看下表：|二进制（1字节）| 十进制值 ||:——: | —— ||10000000 | -128 ||10000001 | -127 ||10000010 | -126 ||10000011 | -125 ||10000100 | -124 || …… | …… ||11111110 | -2 ||11111111 | -1 |首先我们看到，从-1到-128，其二进制的最高位都是1，正如我们前面说的，负数最高位为1，然后我们觉得有点奇怪了，1000 0000 并没有用来表示 0；而 1000 0001也不是拿来直观地表示-1，事实上，-1用1111 1111来表示。怎么理解这个问题呢？先问一句是-1大还是-128大？当然是-1大，那么，1111 1111 -1是什么呢？ 和现实中的计算结果完全一致。1111 1111 -1=1111 1110，而1111 1110 就是-2，就这样一直减下去，当见到只剩最高位用于表示符号的1意外，其他低位全为0时，就是最小的负值，在一字节中，最小的负值是1000 0000，也就是-128。我们以-1位例，来看看不同字节数的整数中，如何表达-1这个数；| 字节数 | 二进制值 | 十进制值 ||:——: | —— | —— ||单字节数 | 11111111 | -1 ||双字节数 | 11111111 11111111 |-1 ||四字节数| 11111111 11111111 11111111 11111111 | -1 |可能有些人看到这里，就已经混了，为什么呢？1111 1111 有时表示255，有时又表示-1？所以我再强调 前面说的第二点，你自己决定一个数是有符号还是无符号的，写程序时，指定一个量是有符号的，那么当这个量的二进制各位上的数都是1时，它表示的数就是-1；相反，如果事先声明这个量是无符号的， 此时它表示的就是该量允许的最大值，对于一个字节的数来说，最大值就是255。我们已经知道计算机中，所有数据最终都是使用二进制数表达。 也已经学会如何将一个10进制数如何转换为二进制数。 不过，我们仍然没有学习一个负数如何用二进制表达。 比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：100000000 00000000 00000000 000001015转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。 现在想知道，-5在计算机中如何表示？ 在计算机中，负数以其正值的补码形式表达。 什么叫补码呢？这得从原码，反码说起。原码：一个整数，按照绝对值大小转换成的二进制数，最高为为符号位，称为原码。 红色为符号位比如：1200000000 00000000 00000000 00000101 是 5的原码。 10000000 00000000 00000000 00000101 是-5的原码。反码： 将二进制除符号位数按位取反，所得的新二进制数称为原二进制数的反码。 正数的反码为原码，负数的反码是原码符号位外按位取反。 取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）正数：正数的反码与原码相同。 负数：负数的反码，符号位为“1”，数值部分按位取反。 比如：将10000000 00000000 00000000 00000101除符号位每一位取反，得11111111 11111111 11111111 11111010。 这时候我们称：11111111 11111111 11111111 11111010 是 10000000 00000000 00000000 00000101 的反码。 反码是相互的， 所以也可称：11111111 11111111 11111111 11111010 和 10000000 00000000 00000000 00000101 互为反码。补码： 反码加1称为补码。 （如果反码最后一位是1得话就向前加1） 1. 正数：正数的补码和原码相同。 2. 负数：按照规则来也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 11111111 11111111 11111111 11111010 是 10000000 00000000 00000000 00000101（-5） 的反码。加1得11111111 11111111 11111111 11111011所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。再举一例，我们来看整数-1在计算机中如何表示。假设这也是一个int类型，那么： 1、先取-1的原码： 10000000 00000000 00000000 00000001 2、除符号位取反得反码： 11111111 11111111 11111111 11111110 3、加1得补码： 11111111 11111111 11111111 11111111 可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF。 计算机中带有符号数用补码表示的优点：1、负数的补码与对应正数的补码之间的转换可以用同一种方法——求补运算完成，可以简化硬件；2、可将减法变为加法，省去减法器；3、无符号数及带符号数的加法运算可以用同一电路完成。 可得出一种心算求补的方法——从最低位开始至找到的第一个1均不变，符号位不变，这之间的各位“求反”(该方法仅用于做题） 方法 例子1 列子2 1,从右边开始，找到第一个“1” 10101001 10101100 2,从这个“1”之后开始到最左边取反（不包括符号位，也就是最高位） 11010111 11010100 注意：（如果反码最后一位是1得话就向前加1） CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 查找资料学习理解并整理下来。希望大家能提出宝贵意见，一起学习。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"C语言（一）的基本数据类型","slug":"c-language","date":"2016-08-06T23:00:33.000Z","updated":"2017-04-07T10:10:10.000Z","comments":true,"path":"2016/08/07/c-language/","link":"","permalink":"https://xuhaoblog.com/2016/08/07/c-language/","excerpt":"C语言helloworld 1.声明头文件，相当于java的导包。 12 //只有函数的声明，编译时会去找到函数的实现#include &lt;stdio.h&gt;","text":"C语言helloworld 1.声明头文件，相当于java的导包。 12 //只有函数的声明，编译时会去找到函数的实现#include &lt;stdio.h&gt; 2.写main()方法 123main()&#123; printf(\"hello from c\\n\"); //\\n换行 &#125; 3.为了观察程序执行的结果，需要调用windows系统的一个指令 12//等待输入system(\"pause\"); 或者getchar(); C语言的基本数据类型 C语言的数据类型： java语言的8大基本类型 int 4byte 32位 byte 1byte 8位 short 2byte 16位 long 8byte 64位 float 4byte 32位 double 8byte 64位 boolean 1byte 8位 char 2byte 16位 c语言的基本数据类型 sizeof();获取一个数据类型的长度 char 1byte 8位 和java不同 long 4byte 32位和java不同 int 4byte 32位 和java一致 float 4byte 32位 和java一致 double 8byte 64位和java一致 short 2byte 16位 还可以表示java里面的char 在c语言里面没有boolean类型，0假 非0真 在c语言里面没有byte类型 可以用char表示byte类型。 代码如下： 12345678910111213141516171819202122232425262728/**char, int, float, double, long, short and 组合关键字signed, unsigned, voidsizeof();获取一个数据类型的长度 **/#include &lt;stdio.h&gt;main()&#123; printf(\"char的占据的byte为%d \\n\",sizeof(char)); printf(\"int的占据的byte为%d \\n\",sizeof(int)); printf(\"float的占据的byte为%d \\n\",sizeof(float)); printf(\"double的占据的byte为%d \\n\",sizeof(double)); printf(\"long的占据的byte为%d \\n\",sizeof(long)); printf(\"short的占据的byte为%d \\n\",sizeof(short)); printf(\"signed int的占据的byte为%d \\n\",sizeof(signed int)); // -2的31次方~ 2的31次方-1 printf(\"unsigned int的占据的byte为%d \\n\",sizeof(unsigned int)); //0~ 2的32次方-1 printf(\"int*占据的byte为%d \\n \" ,sizeof(int*)); printf(\"char*占据的byte为%d \\n \" ,sizeof(char*)); printf(\"float*占据的byte为%d \\n \" ,sizeof(float*)); printf(\"double*占据的byte为%d \\n \" ,sizeof(double*)); printf(\"long*占据的byte为%d \\n \" ,sizeof(long*)); printf(\"short*占据的byte为%d \\n \" ,sizeof(short*)); system(\"pause\"); &#125; 运行结果如下： CSDN 更多系列相关文章传送门：C语言（一）基本数据类型C语言（二）有符号数和无符号数的理解C语言（三）字符串处理函数C语言（四）指针概念的理解C语言（五）内存的分配与释放C语言（六）结构体和联合体C语言（七）文件的相关操作 学习理解并整理下来的笔记。希望大家能够指点或提出宝贵意见，谢谢！一起学习。个人主页：xuhaoblog.com","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://xuhaoblog.com/tags/C-C/"},{"name":"编程语言","slug":"编程语言","permalink":"https://xuhaoblog.com/tags/编程语言/"}]},{"title":"Android 性能检测工具","slug":"performance_tests","date":"2016-06-27T06:34:00.000Z","updated":"2017-11-04T10:59:16.000Z","comments":true,"path":"2016/06/27/performance_tests/","link":"","permalink":"https://xuhaoblog.com/2016/06/27/performance_tests/","excerpt":"Android常见问题 内存泄漏：不使用的内存空间(对象)一直被引用着没有得到释放。 内存抖动：短时间内大量创建对象又在短时间内频繁触发GC导致内存波动很大，android虚拟机执行GC操作时需要耗费CPU性能频繁GC会到来严重的性能问题。内存抖动是因为大量的对象被创建又在短时间内马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。","text":"Android常见问题 内存泄漏：不使用的内存空间(对象)一直被引用着没有得到释放。 内存抖动：短时间内大量创建对象又在短时间内频繁触发GC导致内存波动很大，android虚拟机执行GC操作时需要耗费CPU性能频繁GC会到来严重的性能问题。内存抖动是因为大量的对象被创建又在短时间内马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。 内存溢出：内存泄漏到一定程度超出系统给进程分配的内存大小就会造成内存溢出程序奔溃，或者加载一个或多个大型文件(图片)到内存中也会导致内存溢出。 ANR：应用无响应，代码效率过低或者在主线程执行耗时操作。 内存监控工具 adb shell dumpsys meminfo：内存泄露检测和改善。 Memory Monitor：查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号。 Allocation Tracker：使用此工具来追踪内存的分配。 Heap Viewer：实时查看App分配的内存大小和空闲内存大小，发现Memory Leaks Heap Snapshot：获取Java堆内存详细信息，可以分析出内存泄漏的问题 Memory Analyzer Tool：MAT一款详细分析Java堆内存的工具，该工具非常强大，为了使用该工具，我们需要hprof文件，该文件我们在之前的Heap Snapshot工具的时候，我们就生成了该文件。但是该文件不能直接被MAT使用，需要进行一步转化，可以使用hprof-conv命令来转化，但是Android Studio可以直接转化。 性能监控工具 Profile GPU Rendering：连续多帧每一帧的刷新时间都超过16ms就应该被视为性能问题。 Profile GPU Rendering : M Update：Profile GPU Rendering的升级版。 TraceView：从代码层面分析性能问题，针对每个方法来分析，比如当我们发现我们的应用出现卡顿的时候，我们可以来分析出现卡顿时在方法的调用上有没有很耗时的操作，关注以下两个问题： 调用次数不多，但是每一次执行都很耗时 方法耗时不大，但是调用次数太多 Systrace：计算容器的性能并发现性能的瓶颈。 GPU Monitor：分析GPU的性能，实时查看绘制每一帧所花费的时间，与Profile GPU Rendering差不多。 Strict Mode：UI线程被阻塞超过5秒，就会出现ANR，这太糟糕了。防止程序出现ANR是很重要的事情，那么如何找出程序里面潜在的坑，预防ANR呢？很多大部分情况下执行很快的方法，但是他们有可能存在巨大的隐患，这些隐患的爆发就很容易导致ANR。Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过StrictMode API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。 LINT：Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具。例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -&gt; Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。Lint的功能非常强大，他能够扫描各种问题。当然我们可以通过Android Studio设置找到Lint，对Lint做一些定制化扫描的设置，可以选择忽略掉那些不想Lint去扫描的选项，我们还可以针对部分扫描内容修改它的提示优先级。建议把与内存有关的选项中的严重程度标记为红色的Error，对于Layout的性能问题标记为黄色Warning。 Monkey：Monkey是可以运行在模拟器里或实际设备中的程序。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。 其他工具：其他性能检测工具 网络监控工具 Network monitor：实时监控上传和接收的网速","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"https://xuhaoblog.com/tags/性能优化/"}]},{"title":"Android 自定义一款炫酷的加载控件","slug":"Android-custom-loadingview","date":"2016-05-13T14:13:33.000Z","updated":"2017-11-04T11:00:07.000Z","comments":true,"path":"2016/05/13/Android-custom-loadingview/","link":"","permalink":"https://xuhaoblog.com/2016/05/13/Android-custom-loadingview/","excerpt":"概述：在设计应用的时候，我们应该热爱极简主义，简单就是好的，对于很多用户来说，复杂的东西并不受欢迎。我要实现的是根据不同的情况去显示不同的加载效果，随用随调，效果是借鉴于某一项目的效果，我认为有必要提取出来改善封装一下，供以后使用。情况大致分为：加载中、无网络、无数据、加载失败等；","text":"概述：在设计应用的时候，我们应该热爱极简主义，简单就是好的，对于很多用户来说，复杂的东西并不受欢迎。我要实现的是根据不同的情况去显示不同的加载效果，随用随调，效果是借鉴于某一项目的效果，我认为有必要提取出来改善封装一下，供以后使用。情况大致分为：加载中、无网络、无数据、加载失败等； 预览下效果图 我们怎么实现这种效果呢view_loading.xml的布局如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:id=\"@+id/lin_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:visibility=\"gone\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/img_loading\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:src=\"@drawable/loading_animation\" /&gt; &lt;TextView android:id=\"@+id/tv_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"16dp\" android:layout_gravity=\"center_horizontal\" android:textSize=\"14sp\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=\"@+id/lin_load\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:gravity=\"center\" android:orientation=\"vertical\" android:visibility=\"visible\" &gt; &lt;ImageView android:id=\"@+id/iv_load\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;TextView android:id=\"@+id/tv_load\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:id=\"@+id/btn_load\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" android:layout_gravity=\"center_horizontal\" android:textSize=\"14sp\" /&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; 从布局来看，我分了两个部分，一个是加载中，另外一个是带有ImagView、文字和按钮的布局，有人看到这，就会说，哇靠，这不是很简单吗？根据不同的情况去设置Visibility的值就好了啊，没错，原理就是这样。 XHLoadingView.java的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346package com.woyou.loadingdemo.widget;import android.content.Context;import android.graphics.drawable.AnimationDrawable;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import com.woyou.loadingdemo.LoadingState;import com.woyou.loadingdemo.R;/** * Created by Xiho on 11:21. */public class XHLoadingView extends FrameLayout &#123; private Context mContext; // 加载中的布局 private LinearLayout mLinearLoad; //其他加载的布局 private LinearLayout mLinearLoading; private TextView mTvLoading; private TextView mTvLoad; private ImageView mIvLoading; private ImageView mIvLoad; private Button mBtnLoad; private LoadingState mState; private AnimationDrawable animation; public XHLoadingView(Context context) &#123; super(context); mContext = context; &#125; public XHLoadingView(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; &#125; public XHLoadingView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mContext = context; &#125; public XHLoadingView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); mContext = context; &#125; public void build()&#123; LayoutInflater.from(mContext).inflate(R.layout.view_loading, this, true); mLinearLoading = (LinearLayout) findViewById(R.id.lin_loading); mLinearLoad = (LinearLayout) findViewById(R.id.lin_load); mIvLoading = (ImageView) findViewById(R.id.img_loading); mIvLoad = (ImageView) findViewById(R.id.iv_load); mTvLoading = (TextView) findViewById(R.id.tv_loading); mTvLoad = (TextView) findViewById(R.id.tv_load); mBtnLoad = (Button) findViewById(R.id.btn_load); mBtnLoad.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; setState(LoadingState.STATE_LOADING); mOnRetryListener.onRetry(); &#125; &#125;); &#125; @Override public void setVisibility(int visibility) &#123; super.setVisibility(visibility); if(View.GONE==visibility &amp;&amp; mState==LoadingState.STATE_LOADING &amp;&amp; animation!=null&amp;&amp;animation.isRunning())&#123; animation.stop(); &#125; &#125; /** * 加载中提示文字 */ private String mLoadingText; private int mLoadingIcon; public XHLoadingView withLoadingIcon(int resId)&#123; mLoadingIcon = resId; return this; &#125; /** * 加载数据为空提示文字 */ private String mLoadEmptyText; private int mLoadEmptyIcon; public XHLoadingView withEmptyIcon(int resId)&#123; mLoadEmptyIcon = resId; return this; &#125; /** * 无网络提示 */ private String mLoadNoNetworkText; private int mNoNetworkIcon; public XHLoadingView withNoNetIcon(int resId)&#123; mNoNetworkIcon = resId; return this; &#125; private OnRetryListener mOnRetryListener; /** * 定义重试的的接口 */ public interface OnRetryListener &#123; void onRetry(); &#125; public XHLoadingView withOnRetryListener(OnRetryListener mOnRetryListener)&#123; this.mOnRetryListener = mOnRetryListener; return this; &#125; /** * 设置加载的状态 * @param state */ public void setState(LoadingState state)&#123; if(mState==state)&#123; return; &#125;else if(state==LoadingState.STATE_LOADING)&#123; mLinearLoading.setVisibility(VISIBLE); mLinearLoad.setVisibility(GONE); &#125;else if(state!=LoadingState.STATE_LOADING)&#123; mLinearLoading.setVisibility(GONE); mLinearLoad.setVisibility(VISIBLE); if(animation!=null &amp;&amp; mState==LoadingState.STATE_LOADING) animation.stop(); &#125; changeState(state); &#125; public boolean btnEmptyEnable = true; public boolean btnErrorEnable = true; public boolean btnNoNetworkEnable = true; public XHLoadingView withBtnNoNetEnnable(boolean ennable) &#123; btnNoNetworkEnable = ennable; return this; &#125; public XHLoadingView withBtnErrorEnnable(boolean ennable) &#123; btnErrorEnable = ennable; return this; &#125; public XHLoadingView withBtnEmptyEnnable(boolean ennable) &#123; btnEmptyEnable = ennable; return this; &#125; /** * 改变状态 * @param state */ private void changeState(LoadingState state) &#123; switch (state) &#123; //加载中 case STATE_LOADING: mState = LoadingState.STATE_LOADING; mIvLoading.setImageResource(mLoadingIcon); mTvLoading.setText(mLoadingText); if (animation == null) &#123; animation = (AnimationDrawable) mIvLoading.getDrawable(); &#125; if (animation != null) animation.start(); break; //数据为空 case STATE_EMPTY: mState = LoadingState.STATE_EMPTY; mIvLoad.setImageResource(mLoadEmptyIcon); mTvLoad.setText(mLoadEmptyText); if (btnEmptyEnable) &#123; mBtnLoad.setVisibility(VISIBLE); mBtnLoad.setText(btn_empty_text); &#125; else &#123; mBtnLoad.setVisibility(GONE); &#125; break; //加载失败 case STATE_ERROR: mState = LoadingState.STATE_ERROR; mIvLoad.setImageResource(mErrorIco); mTvLoad.setText(mLoadErrorText); if (btnErrorEnable) &#123; mBtnLoad.setVisibility(VISIBLE); mBtnLoad.setText(btn_error_text); &#125; else &#123; mBtnLoad.setVisibility(GONE); &#125; break; //无网络 case STATE_NO_NET: mState = LoadingState.STATE_NO_NET; mIvLoad.setImageResource(mNoNetworkIcon); mTvLoad.setText(mLoadNoNetworkText); if (btnNoNetworkEnable) &#123; mBtnLoad.setVisibility(VISIBLE); mBtnLoad.setText(btn_nonet_text); &#125; else &#123; mBtnLoad.setVisibility(GONE); &#125; break; &#125; &#125; /** * 后台或者本地出现错误提示 */ private String mLoadErrorText; private int mErrorIco; public XHLoadingView withErrorIco(int resId) &#123; mErrorIco = resId; return this; &#125; /** * 加载空数据 * @param resId * @return */ public XHLoadingView withLoadEmptyText(int resId) &#123; mLoadEmptyText = getResources().getString(resId); return this; &#125; public XHLoadingView withLoadEmptyText(String mLoadEmptyText) &#123; this.mLoadEmptyText = mLoadEmptyText; return this; &#125; /** * 无网络时候加载文字 * @param resId * @return */ public XHLoadingView withLoadNoNetworkText(int resId) &#123; mLoadNoNetworkText = getResources().getString(resId); return this; &#125; public String btn_empty_text = \"重试\"; public String btn_error_text = \"重试\"; public String btn_nonet_text = \"重试\"; /** * 数据为空的Button的文字提示 * @param text * @return */ public XHLoadingView withBtnEmptyText(String text) &#123; this.btn_empty_text = text; return this; &#125; /** * 加载错误的Button的文字提示 * @param text * @return */ public XHLoadingView withBtnErrorText(String text) &#123; this.btn_error_text = text; return this; &#125; /** * 加载错误的文字提示 * @param resId * @return */ public XHLoadingView withLoadErrorText(int resId) &#123; this.mLoadErrorText = getResources().getString(resId); return this; &#125; public XHLoadingView withLoadErrorText(String mLoadedErrorText) &#123; this.mLoadErrorText = mLoadedErrorText; return this; &#125; /** * 加载无网络的Button的文字提示 * @param text * @return */ public XHLoadingView withBtnNoNetText(String text) &#123; this.btn_nonet_text = text; return this; &#125; /** * 加载没有网路的文字提示 * @param mLoadedNoNetText * @return */ public XHLoadingView withLoadNoNetworkText(String mLoadedNoNetText) &#123; this.mLoadNoNetworkText = mLoadedNoNetText; return this; &#125; public XHLoadingView withLoadingText(int resId) &#123; this.mLoadingText = getResources().getString(resId); return this; &#125; public XHLoadingView withLoadingText(String mLoadingText) &#123; this.mLoadingText = mLoadingText; return this; &#125;&#125; 针对不同的情况作了不同的处理，然后我们在需要的Activity调用。 123456789101112131415161718192021222324252627282930313233343536373839 private XHLoadingView mLoadingView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_display); mLoadingView = (XHLoadingView) findViewById(R.id.lv_loading); mLoadingView.withLoadEmptyText(\"≥﹏≤ , 啥也木有 !\").withEmptyIcon(R.drawable.disk_file_no_data).withBtnEmptyEnnable(false) .withErrorIco(R.drawable.ic_chat_empty).withLoadErrorText(\"(῀( ˙᷄ỏ˙᷅ )῀)ᵒᵐᵍᵎᵎᵎ,我家程序猿跑路了 !\").withBtnErrorText(\"臭狗屎!!!\") .withLoadNoNetworkText(\"你挡着信号啦o(￣ヘ￣o)☞ᗒᗒ 你走\").withNoNetIcon(R.drawable.ic_chat_empty).withBtnNoNetText(\"网弄好了，重试\") .withLoadingIcon(R.drawable.loading_animation).withLoadingText(\"加载中...\").withOnRetryListener(new XHLoadingView.OnRetryListener() &#123; @Override public void onRetry() &#123; SnackbarUtil.show(mLoadingView,\"已经在努力重试了\",0); &#125; &#125;).build(); &#125;........ //加载中 mLoadingView.setVisibility(View.VISIBLE); mLoadingView.setState(LoadingState.STATE_LOADING); //空数据 mLoadingView.setVisibility(View.VISIBLE); mLoadingView.setState(LoadingState.STATE_EMPTY) //无网络 mLoadingView.setVisibility(View.VISIBLE); mLoadingView.setState(LoadingState.STATE_NO_NET); //加载错误 mLoadingView.setVisibility(View.VISIBLE); mLoadingView.setState(LoadingState.STATE_ERROR);....... &#125; 源码中注释详细，就不用再做过多的解释了吧！ 完整代码：XHLoadingView 希望您能指出宝贵意见，谢谢。","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"}]},{"title":"基于Hexo+GitHub Pages 搭建个人博客教程","slug":"hexo-github-pages","date":"2016-05-06T07:44:04.000Z","updated":"2017-11-04T11:09:44.000Z","comments":true,"path":"2016/05/06/hexo-github-pages/","link":"","permalink":"https://xuhaoblog.com/2016/05/06/hexo-github-pages/","excerpt":"摘要 :这是一篇有关如何使用Github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，域名注册，以及域名的绑定等功能。","text":"摘要 :这是一篇有关如何使用Github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，域名注册，以及域名的绑定等功能。 前言：就在一个多月前，我经过百般折腾花了三天时间搭建了一个属于自己的博客，我觉得还是很有必要把整个过程写下来，作为以后的备用，并且还能分享出来供大家学习使用，作为一个程序猿，或者希望在程序猿的道路上有所发展的骚年们，相信都应该有一个属于自己的技术博客吧！至于为什么，自己去体会；废话不多说，直奔主题~ (Tip：以下部分博客链接可能失效！！！） 一、系统环境配置要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！ 安装Node.js：下载Node.js参考地址：安装Node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。 安装Git： 下载地址：点击下载Git（这个地方可能要翻墙，如果你是windows 64位的，直接点击这里下载我分享的） 安装教程：如何在windows下安装Git Git入门教程：Pro Git（中文版） Git基本操作：Git常用的基本命令 二、安装HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 回到桌面点击右键，选择Bit Bash Here，如图： 然后输入一下安装hexo命令： 1npm install -g hexo-cli 最后会出现大概这么一条信息 说明hexo 已经安装成功了。（这个是针对Windows用户，Mac用户请参考官方文档） 接下来，我们选择一个硬盘目录作为存放文件的路径，例如我手动在E 盘目录下建了一个blog的文件夹，然后执行以下命令完成hexo 的初始化。 1hexo init e:\\blog 然后进入该目录： 1cd e:\\blog 执行以下命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包： 1npm install 然后生成部署文件，启动本地服务 123$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看$ hexo g # 或者hexo generate Hexo 几个常用的命令： 12345hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署博客到远端服务器hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面 可以简写成： 1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 都是这些单词的首字母，更多的命令用法，可以参考Hexo官网 现在我们打开http://localhost:4000/ 就可以看到我们刚才搭建的本地博客了，Hexo会默认生成一个Hello World的博文。 以后每次新建文章或者修改，就可以先在本地预览，如果觉得没什么问题了之后再deploy到GitHub Pages上。接下来，就介绍GitPages是什么。 三、Github Pages设置1、Github的优点GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。GitHub可以免费使用，并且快速稳定。Github上面的世界很精彩，用久了你的眼界会开阔很多。 2、什么是Github Pages?Github Pages可以被认为是用户编写的、托管在github上的静态网页。GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 3、为什么要使用Github Pages可以绑定你的域名(但暂时貌似只能绑定一个)。简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦. 注册GitHub账号在创建博客之前，当然必须有GitHub的帐号，该帐号将用来创建项目，默认的域名username.github.com/projectName中的username也要用到这个帐号。 注意：下面涉及到的一些命令凡是更用户名和项目名有关的一律会用这里的username和projectName代替，注意替换访问：http://www.github.com/ 注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。 创建项目仓库在创建博客之前，还需要用已有的帐号创建一个项目，上面那个链接的projectName将是这里即将创建的项目名称。在Git中，项目被称为仓库(Repository)，仓库顾名思义，当然可以包含代码或者非代码。将来我们的网页或者模板实际上都是保存在这个仓库中的。 登录后，访问https://github.com/new，创建仓库如下图： 每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 创建了仓库后，我们就需要管理它，无论是管理本地仓库还是远程仓库都需要Git客户端；Git客户端实际上十分强大，它本身就可以offline的创建本地仓库，而本地仓库和远程仓库之间的同步也是通过Git客户端完成的。 配置SSH上传文件需要配置ssh key，不然无法上传。首先先检查一下本地是否已经存在ssh key,在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。1ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件： 设置name和emai12git config --global user.name \"&lt;your name&gt;\"git config --global user.email \"&lt;your email&gt;\" 需要注意的是这里的name是随意的，邮箱是你的联系邮箱，与github上的邮箱没有什么联系（不过我都是同一个邮箱）。 生成ssh 密钥输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车： 1ssh-keygen -t rsa -C \"XXXXX@qq.com\" 一路按回车键即可，如果设置了密码请记住。这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub 获取Key1$ cat ~/.ssh/id_rsa.pub 然后拷贝key 在Github上添加SSH密钥在https://github.com/settings/keys下 add new ssh key 然后title随便取个名字，key 就是上面我们拷贝的内容，好了，最后我们测试一下看是否配置成功。 输入以下命令： 1ssh git@github.com 成功的话会显示以下的大致内容： 123456The authenticity of host 'github.com (192.30.252.128)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,192.30.252.128' (RSA) to the list of known hosts.Hi git-xuhao! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 四、部署到GitHub配置_config.yml 编辑E:\\hexo 下的_config.yml，修改 Deployment部分1234567# Deployment## Docs: https://hexo.io/docs/deployment.html# ssh://git@github.com/git-xuhao/git-xuhao.github.iodeploy: type: git repo: ssh://git@github.com/git-xuhao/git-xuhao.github.io branch: master 其中，repo是我们刚刚建立的远程仓库，换成你自己的仓库，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误。 安装Git包，执行以下命令 1npm install hexo-deployer-git --save 部署到GitHub上，执行以下的命令 1hexo deploy 现在我们可以通过访问 http://git-xuhao.github.io/ 来访问我们自己的博客啦,可以看到我们的博客已成功搭建，接下来就是一些主题的优化和配置呢。 五、Hexo配置文件hexo里面有两个常用到的配置文件，分别是整个博客的配置文件E:\\blog_config.yml和主题的配置文件E:\\hexo\\themes\\next_config.yml，hexo3.0使用的默认主题是landscape，所以你们对应的地址为E:\\hexo\\themes\\landscape_config.yml；hexo提供了很多个主题供你自己选择，使用方法很简单，找到自己喜欢主题Repository，使用Git将主题clone到本地，然后将整个文件夹复制到E:\\blog\\themes文件夹下，将E”\\blog_config.yml里的theme名字改为自己下载的主题的文件夹名就可以了。 配置文件大致说明如下： E:\\blog_config.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思title: blog name #博客名subtitle: Goals determine what you are going to be #副标题description: Goals determine what you are going to be #用于搜索，没有直观表现author: huangjunhui #作者language: zh-CN #语言timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值# URL 暂不配置，使用默认值## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 暂不配置，使用默认值source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局等，使用默认值new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true tab_replace:# Category &amp; Tag 暂不配置，使用默认值default_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式，使用默认值## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章数，0表示不分页pagination_dir: page# Extensions 插件配置，暂时不配置## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/plugins:- hexo-generator-feedtheme: light #使用的主题feed: #之后配置rss会用，此处先不配置这个 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: ssh://git@github.com/git-xuhao/git-xuhao.github.io branch: master 六、如何使用？新建一篇博文可通过以下的命令 1hexo new \"name\" 其中name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件。使用你熟悉的编辑器打开，便可以进行博文的撰写。博文支持MarkDown语法的编写，下面是一个示例文件的内容 1234567891011---title: name date: 2016-04-06 10:34:21permalink: （url中显示的标题）tags: - 开始- 日志categories: - 日志---Hello world，Test！！ 博文写好之后，在每次发布之前，我们要先将写好的博客生成静态文件，执行以下命令 1hexo g 之后生成的文件会放在./public目录下，这便是我们将要部署到GitHub上的全部内容。 静态文件生成之后，便可以部署到GitHub上 1hexo d 然后打开我们的博客 http://git-xuhao.github.io/ 已经可以看到刚刚新建的博文。 七、主题推荐Hexo提供了许多的主题可供我们选择和使用，在./themes目录下存放主题。刚才默认生成的博客用的就是默认的主题landscape，hexo全部主题。知乎上的主题推荐：有哪些好看的 Hexo 主题？（对应的主题一般都有相关的使用说明，这里就不多说咯）我自己使用的是Next主题，xuhao.tech Next主题又有三种风格，这个自己去体验研究吧！ 八丶设置专属域名博客搭建好后，我们可以通过之前设置好的GitHub仓库地址来访问，比如我的：http://git-xuhao.github.io，而且GitHub是免费替我们托管的的，如果我们想要设置自己的专属的域名，我们可以去阿里云购买域名，我们点击添加记录，设置主机记录为@，类型为A，到IP 192.30.252.153（固定值）。 如下图： 按照如上设置完成之后， 可能不会立即生效，等个几分钟，在./source目录下新建文件CNAME（没有后缀名），文件中写上我们要绑定的域名，例如: xuhao.tech，然后执行 1hexo g 生成静态文件，再执行 1hexo d 部署到GitHub上。这时就可以通过http://xuhao.tech访问我们的博客了，怎么样？是不是很简单~不过在搭建的过程中可能遇到一些困难，没关系，耐心的查找问题所在，一切都能解决的。快动手试试吧！ 总结以上就是我采用Hexo+GitHub搭建个人博客的全部流程，但是有些细节性的问题可能表述的不是很明确，在搭建的过程中可能会遇到各种各样的问题，遇到问题，大家可以留言 我尽力所为，或者自行网上查找解决方案，Hexo主题才能大量的前端知识，毕竟我不是搞前端的，对这些知识也是了解很少，为了拥有一个自己的个人网站，也是拼了，最为一个程序员，那肯定是能提高自己的逼格的！哈哈~ 原文出处 学习理解并整理下来的笔记；希望大家能够指点或提出宝贵意见，谢谢！一起学习；","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuhaoblog.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuhaoblog.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://xuhaoblog.com/tags/GitHub/"}]},{"title":"Android 异常退出的生命周期分析","slug":"Android-exception-exit","date":"2016-04-25T11:02:33.000Z","updated":"2017-04-09T15:36:21.000Z","comments":true,"path":"2016/04/25/Android-exception-exit/","link":"","permalink":"https://xuhaoblog.com/2016/04/25/Android-exception-exit/","excerpt":"概述：典型的Activity 生命周期众所周知，就不用多说了吧；我们知道，Activity除了受用户操作所导致的正常的生命周期方法调度，还有一些异常情况，比如当资源相关的系统配置发生了改变以及系统内存不足时，Activity就可能被杀死，下面就来具体分析这两种情况。","text":"概述：典型的Activity 生命周期众所周知，就不用多说了吧；我们知道，Activity除了受用户操作所导致的正常的生命周期方法调度，还有一些异常情况，比如当资源相关的系统配置发生了改变以及系统内存不足时，Activity就可能被杀死，下面就来具体分析这两种情况。 情况一 ： 当一个activity的config改变的时候，Activity就会被杀死然后重建而我们最熟悉的config的改变就是屏幕方向改变，系统语言改变，还有键盘可见改变了等等，系统配置发生了改变，在默认情况下，Activity就会被销毁并且重新创建，当然我们也可阻止系统重新创建我们的Activity。 在默认情况下，如果我们的Activity不做特殊处理，那么当系统配置发生改变后，Activity就会被销毁并重新创建，如图所示： 当系统配置发生改变后，Activiy会被销毁，其onPause、onStop、onDestroy 均会被调用，同时由于Activiy 是在异常情况下终止的，系统会在onStop之前调用onSaveInstanState来保存当前Activiy的状态。所以当出现异常有重要的数据需要恢复的，要在这里做一些数据的保存工作；系统只会帮我们保存视图。 123456@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); //在这里我们可以把我们需要保存的东西给写入Bundle //....... &#125; 然后我们保存的数据就可以在onCreate中来读取了： 1234567@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(savedInstanceState != null)&#123; //TODO 取出数据 &#125; &#125; 另一种就是一个独立的回调了： 1234@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); &#125; 二者的区别是：onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的判断是否为空；但是onCreate不行，这两个方法都可以进行数据恢复，但是Google建议采用onRestoreInstanceState 去恢复数据。 情况二： 资源内存不足导致低优先级的Activity被杀死Activity 按照优先级从高到低，可以分为三种：（1）前台Activity——正在和用户交互的Activity，优先级最高。（2）可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。（3）后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。 当系统内存不足时，系统就会按照上述优先级去杀死目标Activity所在的进程，并通过onSaveInstanState和onRestoreInstanceState 来存储和恢复数据。如果一个进程中没有四大组件在执行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件而独自运行在后台中，这样进程很容易被杀死。建议将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死了。 NOTES：虽然内容很简单，但也是博主辛苦的做了下笔记，转载请注明出处！","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"}]},{"title":"Android TextView 实现文字间距","slug":"android-spacingtextview","date":"2016-04-18T08:35:00.000Z","updated":"2017-11-04T10:56:43.000Z","comments":true,"path":"2016/04/18/android-spacingtextview/","link":"","permalink":"https://xuhaoblog.com/2016/04/18/android-spacingtextview/","excerpt":"概述：Android系统中TextView默认显示中文时会比较紧凑，不是很美观。为了让每行保持一定的行间距，可以设置属性android:lineSpacingExtra或android:lineSpacingMultiplier。但是有时候我们需要在TextView的文本之间有间距，两个字的话，我们可以在xml文件中，用敲空格的方式来实现，如果有很多文本或者是一个变量的文本呢。我们还这样用敲空格的方式来实现吗？oh no~！如何实现行间距和文本间距呢？（请往下看 ↓）。 1、设置TextView的行间距在TextView控件中添加属性：12android:lineSpacingExtra=\"13dp\" //设置行间距android:lineSpacingMultiplier=\"1.2\" //设置行间距的倍数。如”1.2”","text":"概述：Android系统中TextView默认显示中文时会比较紧凑，不是很美观。为了让每行保持一定的行间距，可以设置属性android:lineSpacingExtra或android:lineSpacingMultiplier。但是有时候我们需要在TextView的文本之间有间距，两个字的话，我们可以在xml文件中，用敲空格的方式来实现，如果有很多文本或者是一个变量的文本呢。我们还这样用敲空格的方式来实现吗？oh no~！如何实现行间距和文本间距呢？（请往下看 ↓）。 1、设置TextView的行间距在TextView控件中添加属性：12android:lineSpacingExtra=\"13dp\" //设置行间距android:lineSpacingMultiplier=\"1.2\" //设置行间距的倍数。如”1.2” 2、设置TextView的文本间距 先看下效果图： 自定义的TextView 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.woyou.spacingtextview;import android.content.Context;import android.text.Spannable;import android.text.SpannableString;import android.text.style.ScaleXSpan;import android.util.AttributeSet;import android.widget.TextView;/** * Created by Xiho on 2016/3/7. */public class SpacingTextView extends TextView&#123; private float letterSpacing = LetterSpacing.BIGGEST; private CharSequence originalText = \"\"; public SpacingTextView(Context context) &#123; super(context); &#125; public SpacingTextView(Context context, AttributeSet attrs)&#123; super(context, attrs); originalText = super.getText(); applyLetterSpacing(); this.invalidate(); &#125; public SpacingTextView(Context context, AttributeSet attrs, int defStyle)&#123; super(context, attrs, defStyle); &#125; public float getLetterSpacing() &#123; return letterSpacing; &#125; public void setLetterSpacing(float letterSpacing) &#123; this.letterSpacing = letterSpacing; applyLetterSpacing(); &#125; @Override public void setText(CharSequence text, BufferType type) &#123; originalText = text; applyLetterSpacing(); &#125; @Override public CharSequence getText() &#123; return originalText; &#125; /** * 字距为任何字符串（技术上，一个简单的方法为CharSequence不使用）的TextView */ private void applyLetterSpacing() &#123; if (this == null || this.originalText == null) return; StringBuilder builder = new StringBuilder(); for(int i = 0; i &lt; originalText.length(); i++) &#123; String c = \"\"+ originalText.charAt(i); builder.append(c.toLowerCase()); if(i+1 &lt; originalText.length()) &#123; builder.append(\"\\u00A0\"); &#125; &#125; SpannableString finalText = new SpannableString(builder.toString()); if(builder.toString().length() &gt; 1) &#123; for(int i = 1; i &lt; builder.toString().length(); i+=2) &#123; finalText.setSpan(new ScaleXSpan((letterSpacing+1)/10), i, i+1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; &#125; super.setText(finalText, BufferType.SPANNABLE); &#125; public class LetterSpacing &#123; public final static float NORMAL = 0; public final static float NORMALBIG = (float)0.025; public final static float BIG = (float)0.05; public final static float BIGGEST = (float)0.2; &#125;&#125; 在activity 中使用： 12345678910111213private SpacingTextView mSpacingTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mSpacingTextView = (SpacingTextView) findViewById(R.id.space_text); mSpacingTextView.setText(getResources().getString(R.string.test)); //Or any float. To reset to normal, use 0 or LetterSpacingTextView.Spacing.NORMAL mSpacingTextView.setLetterSpacing(10); &#125; xml 文件如下： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\"com.woyou.spacingtextview.MainActivity\" tools:showIn=\"@layout/activity_main\"&gt; &lt;com.woyou.spacingtextview.SpacingTextView android:id=\"@+id/space_text\" android:layout_width=\"wrap_content\" android:lineSpacingExtra=\"13dp\" android:layout_height=\"wrap_content\" android:text=\"@string/test\" /&gt;&lt;/RelativeLayout&gt; 以上代码使用起来很方便，添加到自己的项目中看下效果。 TextView控件以开源：SpacingTextView如果你想实现TextView的 文本对齐；请参考开源项目：AlignTextView","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"TextView","slug":"TextView","permalink":"https://xuhaoblog.com/tags/TextView/"}]},{"title":"Android 中线程池的分析","slug":"Android 中线程池的分析","date":"2016-04-15T08:25:24.000Z","updated":"2017-11-04T10:57:28.000Z","comments":true,"path":"2016/04/15/Android 中线程池的分析/","link":"","permalink":"https://xuhaoblog.com/2016/04/15/Android 中线程池的分析/","excerpt":"介绍new Thread的弊端及Java四种线程池的使用，对Android同样适用。 1、new Thread的弊端执行一个异步任务你还只是如下new Thread吗？ 123456789new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125; &#125;).start();","text":"介绍new Thread的弊端及Java四种线程池的使用，对Android同样适用。 1、new Thread的弊端执行一个异步任务你还只是如下new Thread吗？ 123456789new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub &#125; &#125;).start(); 那你就out太多了，new Thread的弊端如下： a. 每次new Thread新建对象性能差。b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。c. 缺乏更多功能，如定时执行、定期执行、线程中断。 相比new Thread，Java提供的四种线程池的好处在于： a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。c. 提供定时执行、定期执行、单线程、并发数控制等功能。 2、Java 线程池Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 (1)newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下： 123456789101112131415161718ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; try &#123; Thread.sleep(index * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cachedThreadPool.execute(new Runnable() &#123; @Overridepublic void run() &#123; System.out.println(index);&#125;&#125;);&#125; 线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 (2)newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：123456789101112131415161718ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; fixedThreadPool.execute(new Runnable() &#123; @Overridepublic void run() &#123;try &#123; System.out.println(index); Thread.sleep(2000);&#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;&#125;);&#125; 因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。 定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。 (3)newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下： 12345678ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() &#123; @Overridepublic void run() &#123; System.out.println(\"delay 3 seconds\");&#125;&#125;, 3, TimeUnit.SECONDS); 表示延迟3秒执行。 定期执行示例代码如下： 12345678scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Overridepublic void run() &#123; System.out.println(\"delay 1 seconds, and excute every 3 seconds\");&#125;&#125;, 1, 3, TimeUnit.SECONDS); 表示延迟1秒后每3秒执行一次。 ScheduledExecutorService比Timer更安全，功能更强大 (4)newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下： 1234567891011121314151617ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 10; i++) &#123;final int index = i;singleThreadExecutor.execute(new Runnable() &#123; @Overridepublic void run() &#123; try &#123; System.out.println(index); Thread.sleep(2000);&#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; &#125;);&#125; 结果依次输出，相当于顺序执行各个任务。 现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。 线程池的作用：线程池作用就是限制系统中执行线程的数量。 根 据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。 为什么要用线程池:1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 比较重要的几个类： ExecutorService： 真正的线程池接口。 ScheduledExecutorService： 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。 ThreadPoolExecutor： ExecutorService的默认实现。 ScheduledThreadPoolExecutor： 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 1.newSingleThreadExecutor创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 2.newFixedThreadPool创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 3.newCachedThreadPool创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 4.newScheduledThreadPool创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 实例代码一、固定大小的线程池，newFixedThreadPool：12345678910111213141516171819202122232425262728293031323334353637package app.executors; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; /** * Java线程：线程池 * * @author xiho */ public class Test &#123; public static void main(String[] args) &#123; // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建线程 Thread t1 = new MyThread(); Thread t2 = new MyThread(); Thread t3 = new MyThread(); Thread t4 = new MyThread(); Thread t5 = new MyThread(); // 将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); // 关闭线程池 pool.shutdown(); &#125; &#125; class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \"正在执行。。。\"); &#125; &#125; 输出结果： 12345pool-1-thread-1正在执行。。。 pool-1-thread-3正在执行。。。 pool-1-thread-4正在执行。。。 pool-1-thread-2正在执行。。。 pool-1-thread-5正在执行。。。 改变ExecutorService pool = Executors.newFixedThreadPool(5)中的参数：ExecutorService pool = Executors.newFixedThreadPool(2)，输出结果是： 12345pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-2正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-2正在执行。。。 从以上结果可以看出，newFixedThreadPool的参数指定了可以运行的线程的最大数目，超过这个数目的线程加进去以后，不会运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。 二、单任务线程池，newSingleThreadExecutor：仅仅是把上述代码中的ExecutorService pool = Executors.newFixedThreadPool(2)改为ExecutorService pool = Executors.newSingleThreadExecutor();输出结果： 12345pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 可以看出，每次调用execute方法，其实最后都是调用了thread-1的run方法。 三、可变尺寸的线程池，newCachedThreadPool：与上面的类似，只是改动下pool的创建方式：ExecutorService pool = Executors.newCachedThreadPool(); 输出结果： 12345pool-1-thread-1正在执行。。。 pool-1-thread-2正在执行。。。 pool-1-thread-4正在执行。。。 pool-1-thread-3正在执行。。。 pool-1-thread-5正在执行。。。 这种方式的特点是：可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。 四、延迟连接池，newScheduledThreadPool：1234567891011121314151617181920212223242526272829303132333435public class TestScheduledThreadPoolExecutor &#123; public static void main(String[] args) &#123; ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间就触发异常 @Override publicvoid run() &#123; //throw new RuntimeException(); System.out.println(\"================\"); &#125; &#125;, 1000, 5000, TimeUnit.MILLISECONDS); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间打印系统时间，证明两者是互不影响的 @Override publicvoid run() &#123; System.out.println(System.nanoTime()); &#125; &#125;, 1000, 2000, TimeUnit.MILLISECONDS); &#125;&#125; 输出结果：123456789101112131415================838464454951683866438290348388643830710================839064385138383926438793198400643939383 转载请标注原地址：http://blog.csdn.net/u011974987/article/details/51027795","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xuhaoblog.com/categories/Java基础/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"线程池","slug":"线程池","permalink":"https://xuhaoblog.com/tags/线程池/"},{"name":"java","slug":"java","permalink":"https://xuhaoblog.com/tags/java/"}]},{"title":"Android 网络请求库Retrofit简单使用","slug":"android-retrofit","date":"2016-04-12T08:20:24.000Z","updated":"2017-11-04T10:59:43.000Z","comments":true,"path":"2016/04/12/android-retrofit/","link":"","permalink":"https://xuhaoblog.com/2016/04/12/android-retrofit/","excerpt":"什么是 Retrofit ?Retrofit是一套 RESTful 架构的 Android（Java）客户端实现，基于注解，提供 JSON to POJO（Plain Ordinary Java Object ，简单Java对象），POJO to JSON，网络请求（POST，GET， PUT，DELETE 等）封装。","text":"什么是 Retrofit ?Retrofit是一套 RESTful 架构的 Android（Java）客户端实现，基于注解，提供 JSON to POJO（Plain Ordinary Java Object ，简单Java对象），POJO to JSON，网络请求（POST，GET， PUT，DELETE 等）封装。 既然只是一个网络请求封装库，现在已经有了那么多的大家已经耳熟能详的网络请求封装库了，为什么还要介绍它呢，原因在于 Retrofit 是一套注解形的网络请求封装库，让我们的代码结构更给为清晰。它可以直接解析JSON数据变成JAVA对象，甚至支持回调操作，处理不同的结果。想更详细的了解 Retrofit，可以查看官方文档 。 话不多说，直入主题~~ 一、集成目前我使用的是AndroidStudio,那么在model的build.gradle文件中添加以下引用：123compile 'com.squareup.okhttp3:okhttp:3.2.0' compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3' 说明： Retrofit依赖于okhttp，所以需要集成okhttpAPI返回的数据为JSON格式，在此我使用的是Gson对返回数据解析.请使用最新版的Gson 二、返回的数据格式使用的是百度API的数据接口：名人名言API 该接口的API主机地址为：http://apistore.baidu.com；需要访问的接口：avatardata/mingrenmingyan/lookup； 需要一个key等于apikey的Header和一个keyword等于名人名言的查询关键字,而且该请求为GET请求. 访问该API返回的数据格式如下：123456789101112131415161718192021222324252627&#123; \"total\": 914, \"result\": [ &#123; \"famous_name\": \"布兰登\", \"famous_saying\": \"人生至善，就是对生活乐观，对工作愉快，对事业兴奋。\" &#125;, &#123; \"famous_name\": \"魏书生\", \"famous_saying\": \"抽打自己的鞭子要掌握在自己的手里，在漫长的人生道路的每一步上，都要经常鞭策自警，万不可以为有过一两次抽打就可以沿途平安了。\" &#125;, &#123; \"famous_name\": \"亨·易卜生\", \"famous_saying\": \"夺走了普通人生活的幻想，也就等于夺去了他的幸福\" &#125;, &#123; \"famous_name\": \"佚名\", \"famous_saying\": \"不知道自己走向何方的人，大都是人生的匆匆过客。\" &#125;, &#123; \"famous_name\": \"南丁格尔\", \"famous_saying\": \"人生欲求安全，当有五要。一是清洁空气，二是澄清饮水，三是流通沟渠，四是扫洒屋宇，五是日光充足。\" &#125; ], \"error_code\": 0, \"reason\": \"Succes\"&#125; 三、AndroidStudio插件 GsonFormat我们根据上面API返回的json数据来创建一个FamousInfo数据对象，我们可以利用AndroidStudio插件 GsonFormat 快速，方便的将json数据转为Java 对象，FamousInfo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.woyou.androidsample.bean;import java.util.List;/** * Created by Xiho on 2016/3/14. */public class FamousInfo &#123; /** * total : 227 * result : [&#123;\"famous_name\":\"车尔尼雪夫斯基\",\"famous_saying\":\"非凡的单纯，非凡的明确\\u2014\\u2014这是天才的智慧的最可惊人的品质。\"&#125;,&#123;\"famous_name\":\"约·德莱顿\",\"famous_saying\":\"天才在社会生活中往往显得迟钝而\"&#125;,&#123;\"famous_name\":\"雨果\",\"famous_saying\":\"敢于冲撞命运才是天才\"&#125;,&#123;\"famous_name\":\"卡莱尔\",\"famous_saying\":\"所谓天才，就是比任何人都先抵挡痛苦的经验本领。\"&#125;,&#123;\"famous_name\":\"林肯\",\"famous_saying\":\"卓越的天才不屑走一条人家走过的路。他寻找迄今没有开拓过的地区。\"&#125;,&#123;\"famous_name\":\"席勒\",\"famous_saying\":\"产生天才的土壤比天才还要难找\"&#125;,&#123;\"famous_name\":\"爱因斯坦\",\"famous_saying\":\"任何天才不能在孤独的状态中发展\"&#125;,&#123;\"famous_name\":\"民谚\",\"famous_saying\":\"名人的古怪行为是天才的标志，凡人的古怪行为是神经出了毛病\"&#125;,&#123;\"famous_name\":\"鲁迅\",\"famous_saying\":\"哪里有天才，我是把别人喝咖啡的工夫都用在了工作上了。\"&#125;,&#123;\"famous_name\":\"塞涅夫\",\"famous_saying\":\"没有某些发狂的劲头，就没有天才。\"&#125;,&#123;\"famous_name\":\"狄德罗\",\"famous_saying\":\"精神的浩瀚想象的活跃心灵的勤奋：就是天才。\"&#125;,&#123;\"famous_name\":\"爱默生\",\"famous_saying\":\"平凡的人希望，天才的人创造。\"&#125;,&#123;\"famous_name\":\"契诃夫\",\"famous_saying\":\"真正的天才是常常隐藏在群众里面，绝不挤向人前去露脸的。\"&#125;,&#123;\"famous_name\":\"别林斯基\",\"famous_saying\":\"任何天才，不经过艰苦不断的劳动，不经过最使空想家头疼和懊恼的最初纯物质和机械的劳动，就无法精通任何种类的艺术。\"&#125;,&#123;\"famous_name\":\"杨格\",\"famous_saying\":\"我愿意以天才比美德，以学问比财富。如美德越少的人，越需要财富，天才越低的人，越需要学问。\"&#125;,&#123;\"famous_name\":\"巴尔扎克\",\"famous_saying\":\"职业尽管不同，但天才的品德并无分别。\"&#125;,&#123;\"famous_name\":\"恩格斯\",\"famous_saying\":\"逆境使天才脱颖而出，顺境会埋没\"&#125;,&#123;\"famous_name\":\"巴尔扎克\",\"famous_saying\":\"破坏的人和建设的人，两者都是意志的现象：一个是准备工作，另一个是完成工作；前者好像是一个恶的天才，后者似乎是一个善的天才；对这一个给予光荣，对另一个给予忘却。恶者哇啦哇啦，把庸俗的人们从梦里惊醒，对他佩服得五体投地，可是善者却一直默不作声。\"&#125;,&#123;\"famous_name\":\"培根\",\"famous_saying\":\"如果孩子确有某种超群的天才，那当然应该扶植发展。但就一般情况说，下面这句格言很有用的：\\u201c长期的训练会通过适应化难为易。\\u201d\"&#125;,&#123;\"famous_name\":\"爱迪生\",\"famous_saying\":\"天才是百分之一的灵感，百分之九十九的血汗。\"&#125;] * error_code : 0 * reason : Succes */ private int total; private int error_code; private String reason; /** * famous_name : 车尔尼雪夫斯基 * famous_saying : 非凡的单纯，非凡的明确——这是天才的智慧的最可惊人的品质。 */ private List&lt;ResultEntity&gt; result; public void setTotal(int total) &#123; this.total = total; &#125; public void setError_code(int error_code) &#123; this.error_code = error_code; &#125; public void setReason(String reason) &#123; this.reason = reason; &#125; public void setResult(List&lt;ResultEntity&gt; result) &#123; this.result = result; &#125; public int getTotal() &#123; return total; &#125; public int getError_code() &#123; return error_code; &#125; public String getReason() &#123; return reason; &#125; public List&lt;ResultEntity&gt; getResult() &#123; return result; &#125; public static class ResultEntity &#123; private String famous_name; private String famous_saying; public void setFamous_name(String famous_name) &#123; this.famous_name = famous_name; &#125; public void setFamous_saying(String famous_saying) &#123; this.famous_saying = famous_saying; &#125; public String getFamous_name() &#123; return famous_name; &#125; public String getFamous_saying() &#123; return famous_saying; &#125; &#125;&#125; 四、实现过程首先， 按照官方的说明，我们需要创建一个接口，返回 Call；如下：12345@GET(\"/avatardata/mingrenmingyan/lookup\") Call&lt;FamousInfo&gt; getFamousResult(@Header(\"apiKey\") String apiKey, @Query(\"keyword\") String keyword, @Query(\"page\") int page, @Query(\"rows\") int rows); 这里我们使用的是Retrofit 提供注解的方式来定义接口的 @get后面我们填写需要访问对应的接口地址 @Header用来添加Header @Query用来添加查询关键字 现在接口定义好了，我们来 定义Retrofit 网络接口服务的包装类 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.woyou.androidsample;import android.content.Context;import retrofit2.GsonConverterFactory;import retrofit2.Retrofit;/** * Retrofit 网络接口服务的包装类 * Created by Xiho on 2016/3/14. */public class RetrofitWrapper &#123; private static RetrofitWrapper instance; private Context mContext; private Retrofit retrofit; private RetrofitWrapper() &#123; //1.创建Retrofit对象 retrofit = new Retrofit.Builder().baseUrl(Constant.BASEURL) // 定义访问的主机地址 .addConverterFactory(GsonConverterFactory.create()) //解析方法 .build(); &#125; /** * 单例模式 * * @return */ public static RetrofitWrapper getInstance() &#123; if (instance == null) &#123; synchronized (RetrofitWrapper.class)&#123; if (instance==null)&#123; instance = new RetrofitWrapper(); &#125; &#125; &#125; return instance; &#125; public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; return retrofit.create(service); &#125;&#125;/** * Created by Xiho on 2016/3/14. */public class Constant &#123; public static String BASEURL=\"http://apis.baidu.com\"; //服务器地址 public static String APIKEY=\"4c4f0c3c49e09d5578ae0ba49fa84a97\";&#125; 网络服务的包装类定义好了之后，在定义一个访问的Model（个人编码风格，其实可以更简洁点）。 1234567891011121314151617181920212223242526272829303132public class FamousInfoModel &#123; private static FamousInfoModel famousInfoModel; private FamousService mFamousService; /** * 单例模式 * * @return */ public static FamousInfoModel getInstance(Context context) &#123; if (famousInfoModel == null) &#123; famousInfoModel = new FamousInfoModel(context); &#125; return famousInfoModel; &#125; private FamousInfoModel(Context context) &#123; mFamousService = (FamousService) RetrofitWrapper.getInstance().create(FamousService.class); &#125; /** * 查询名人名言 * * @param famousInfoReq * @return */ public Call&lt;FamousInfo&gt; queryLookUp(FamousInfoReq famousInfoReq) &#123; Call&lt;FamousInfo&gt; infoCall = mFamousService.getFamousResult(famousInfoReq.apiKey, famousInfoReq.keyword, famousInfoReq.page, famousInfoReq.rows); return infoCall; &#125;&#125; 五、如何使用构建好接口以后,可以使用了! 使用分为四步: 创建Retrofit对象 创建访问API的请求 发送请求 处理结果主要代码如下：1234567891011121314151617181920212223242526272829FamousInfoModel famousInfoModel =FamousInfoModel.getInstance(getApplicationContext());// 获取事件 private void initEvent() &#123; mSerachBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //创建访问的API请求 Call&lt;FamousInfo&gt; callFamous= famousInfoModel.queryLookUp(initParams()); //发送请求 callFamous.enqueue(new Callback&lt;FamousInfo&gt;() &#123; @Override public void onResponse(Call&lt;FamousInfo&gt; call, Response&lt;FamousInfo&gt; response) &#123; if(response.isSuccess())&#123; FamousInfo result = response.body(); if(result!=null)&#123; List&lt;FamousInfo.ResultEntity&gt; entity = result.getResult(); mTxtContent.setText(\"1、\"+entity.get(0).getFamous_saying()+\"\\n---\"+entity.get(0).getFamous_name()+\"\\n 2、\" +entity.get(1).getFamous_saying()+\"\\n---\"+entity.get(1).getFamous_name()); &#125; &#125; &#125; @Override public void onFailure(Call&lt;FamousInfo&gt; call, Throwable t) &#123; &#125; &#125;); &#125; &#125;); &#125; 最后运行的效果图如下： 搜索的结果我只是显示了其中一部分，只用来使用Retrofit 这个框架，没有很具体去做一些处理啦，后面还会用一些其他的库，还会使用本Demo 来进行测试，所以这次就简单写了下。 附上源码：AndroidRetrofitSample 六、扩展阅读 Retrofit: Retrofit 官方文档：http://square.github.io/retrofit/ Retrofit 使用介绍：http://www.cnblogs.com/angeldevil/p/3757335.html Retrofit 离线缓存策略：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0115/3873.html","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"网络请求","slug":"网络请求","permalink":"https://xuhaoblog.com/tags/网络请求/"}]},{"title":"Android 切换系统语言源码分析（上）","slug":"android-change-language_01","date":"2016-04-12T04:05:24.000Z","updated":"2017-11-04T10:58:31.000Z","comments":true,"path":"2016/04/12/android-change-language_01/","link":"","permalink":"https://xuhaoblog.com/2016/04/12/android-change-language_01/","excerpt":"概述：以前了解Android的多语言实现很简单，可以在不同的语言环境下使用不同的资源，就做好相应的语言适配就好，但是一直没有实际使用过。 最近公司的项目要用到多国语言切换，并且还是和手机上系统设置里面的语言切换功能一样，于是就上网查了下资料。一般都是在应用类实现多国语言切换，这个是很简单。而我想切换整个系统的语言。由于谷歌没有把系统设置里面的接口给开放出来，所以就只好去查看它的源码了~","text":"概述：以前了解Android的多语言实现很简单，可以在不同的语言环境下使用不同的资源，就做好相应的语言适配就好，但是一直没有实际使用过。 最近公司的项目要用到多国语言切换，并且还是和手机上系统设置里面的语言切换功能一样，于是就上网查了下资料。一般都是在应用类实现多国语言切换，这个是很简单。而我想切换整个系统的语言。由于谷歌没有把系统设置里面的接口给开放出来，所以就只好去查看它的源码了~ android语言切换是在： 1packages/apps/Settings/com/android/settings/LocalePicker.java 的updateLocale()函数中调用，源码如下：1234567891011121314151617181920/** * Requests the system to update the system locale. Note that the system looks halted for a while during the Locale migration, so the caller need to take care of it. */ public static void updateLocale(Locale locale) &#123; try &#123; IActivityManager am = ActivityManagerNative.getDefault(); Configuration config = am.getConfiguration(); config.locale = locale; // indicate this isn't some passing default - the user wants this remembered config.userSetLocale = true; am.updateConfiguration(config); // Trigger the dirty bit for the Settings Provider. BackupManager.dataChanged(\"com.android.providers.settings\"); &#125; catch (RemoteException e) &#123; // Intentionally left blank &#125; &#125; 从注释可以看出, 只要本地local改变就会调用该函数. 查看ActivityManagerNative的getDefault()可以看到, 该函数返回的是远程服务对象ActivityManagerServices.java在本地的一个代理. 最终调用的是ActivityManagerService.java中的updateConfiguration()函数. 12345678910111213141516171819202122public void updateConfiguration(Configuration values) &#123; enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, \"updateConfiguration()\"); synchronized(this) &#123; if (values == null &amp;&amp; mWindowManager != null) &#123; // sentinel: fetch the current configuration from the window manager values = mWindowManager.computeNewConfiguration(); &#125; if (mWindowManager != null) &#123; mProcessList.applyDisplaySize(mWindowManager); &#125; final long origId = Binder.clearCallingIdentity(); if (values != null) &#123; Settings.System.clearConfiguration(values); &#125; updateConfigurationLocked(values, null, false, false); Binder.restoreCallingIdentity(origId); &#125; &#125; 该函数, 首先进行的是权限的校验. 然后调用updateConfigurationLocked()函数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * Do either or both things: (1) change the current configuration, and (2) * make sure the given activity is running with the (now) current * configuration. Returns true if the activity has been left running, or * false if &lt;var&gt;starting&lt;/var&gt; is being destroyed to match the new * configuration. * @param persistent TODO */ public boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean persistent, boolean initLocale) &#123; int changes = 0; boolean kept = true; if (values != null) &#123; Configuration newConfig = new Configuration(mConfiguration); changes = newConfig.updateFrom(values); if (changes != 0) &#123; if (DEBUG_SWITCH || DEBUG_CONFIGURATION) &#123; Slog.i(TAG, \"Updating configuration to: \" + values); &#125; EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes); if (values.locale != null &amp;&amp; !initLocale) &#123; saveLocaleLocked(values.locale, !values.locale.equals(mConfiguration.locale), values.userSetLocale, values.simSetLocale); &#125; mConfigurationSeq++; if (mConfigurationSeq &lt;= 0) &#123; mConfigurationSeq = 1; &#125; newConfig.seq = mConfigurationSeq; mConfiguration = newConfig; Slog.i(TAG, \"Config changed: \" + newConfig); final Configuration configCopy = new Configuration(mConfiguration); AttributeCache ac = AttributeCache.instance(); if (ac != null) &#123; ac.updateConfiguration(configCopy); &#125; // Make sure all resources in our process are updated // right now, so that anyone who is going to retrieve // resource values after we return will be sure to get // the new ones. This is especially important during // boot, where the first config change needs to guarantee // all resources have that config before following boot // code is executed. mSystemThread.applyConfigurationToResources(configCopy); if (persistent &amp;&amp; Settings.System.hasInterestingConfigurationChanges(changes)) &#123; Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG); msg.obj = new Configuration(configCopy); mHandler.sendMessage(msg); &#125; for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); try &#123; if (app.thread != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Sending to proc \" + app.processName + \" new config \" + mConfiguration); app.thread.scheduleConfigurationChanged(configCopy); &#125; &#125; catch (Exception e) &#123; &#125; &#125; Intent intent = new Intent(Intent.ACTION_CONFIGURATION_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_REPLACE_PENDING); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, false, false, MY_PID, Process.SYSTEM_UID); if ((changes&amp;ActivityInfo.CONFIG_LOCALE) != 0) &#123; broadcastIntentLocked(null, null, new Intent(Intent.ACTION_LOCALE_CHANGED), null, null, 0, null, null, null, false, false, MY_PID, Process.SYSTEM_UID); &#125; &#125; &#125; if (changes != 0 &amp;&amp; starting == null) &#123; // If the configuration changed, and the caller is not already // in the process of starting an activity, then find the top // activity to check if its configuration needs to change. starting = mMainStack.topRunningActivityLocked(null); &#125; if (starting != null) &#123; kept = mMainStack.ensureActivityConfigurationLocked(starting, changes); // And we need to make sure at this point that all other activities // are made visible with the correct configuration. mMainStack.ensureActivitiesVisibleLocked(starting, changes); &#125; if (values != null &amp;&amp; mWindowManager != null) &#123; mWindowManager.setNewConfiguration(mConfiguration); &#125; return kept; &#125; 整个语言切换就在这个函数中完成. 咋一看似乎没感觉到该函数做了哪些事情. 我们首先来看注释: Do either or both things: (1) change the current configuration, and (2)make sure the given activity is running with the (now) current. configuration大概意思是: 这个函数做了两件事情. (1). 改变当前的configuration. 意思就是让改变的configuration更新到当前configuration. (2) 确保所有正在运行的activity都能更新改变后的configuration.(这点是关键.) . 我们按照这个思路看看android是如何更新configuration. 查看代码 , 首先看到 这个函数首先判断values是否为空, 这里values肯定不为空的, 然后changes = newConfig.updateFrom(values); 我们看看updateFrom做了什么操作。 123456789101112131415161718192021222324/** * Copy the fields from delta into this Configuration object, keeping * track of which ones have changed. Any undefined fields in * &lt;var&gt;delta&lt;/var&gt; are ignored and not copied in to the current * Configuration. * @return Returns a bit mask of the changed fields, as per * &#123;@link #diff&#125;. */ public int updateFrom(Configuration delta) &#123; int changed = 0; ... if (delta.locale != null &amp;&amp; (locale == null || !locale.equals(delta.locale))) &#123; changed |= ActivityInfo.CONFIG_LOCALE; locale = delta.locale != null ? (Locale) delta.locale.clone() : null; textLayoutDirection = LocaleUtil.getLayoutDirectionFromLocale(locale); &#125; if (delta.userSetLocale &amp;&amp; (!userSetLocale || ((changed &amp; ActivityInfo.CONFIG_LOCALE) != 0))) &#123; userSetLocale = true; changed |= ActivityInfo.CONFIG_LOCALE; &#125; ... return changed; &#125; 因为语言改变了, 那么 (!locale.equals(delta.locale)) 是true. changed 大于0, 然后return changed. 回到ActivityManagerService.java的updateConfigurationLocked函数, 因为changed不为0 , 所以走if这个流程. 继续看代码。 1234567891011for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); try &#123; if (app.thread != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Sending to proc \" + app.processName + \" new config \" + mConfiguration); app.thread.scheduleConfigurationChanged(configCopy); &#125; &#125; catch (Exception e) &#123; &#125; &#125; 首先看到的是mLurProcesses 是ArrayList类型. LRU : Least Recently Used保存所有运行过的进程. ProcessRecord进程类, 一个apk文件运行时会对应一个进程. app.thread. 此处的thread代表的是ApplicationThreadNative.java类型. 然后调用其scheduleConfigurationChanged(); 查看该函数。 123456789public final void scheduleConfigurationChanged(Configuration config) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); config.writeToParcel(data, 0); mRemote.transact(SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; 又是通过binder调用, 所以 , binder在android中是一个很重要的概念. 此处远程调用的是ActivityThread.java中的私有内部内ApplicationThread。 123456789101112131415 private class ApplicationThread extends ApplicationThreadNative &#123; private static final String HEAP_COLUMN = \"%13s %8s %8s %8s %8s %8s %8s\"; private static final String ONE_COUNT_COLUMN = \"%21s %8d\"; private static final String TWO_COUNT_COLUMNS = \"%21s %8d %21s %8d\"; private static final String TWO_COUNT_COLUMNS_DB = \"%21s %8d %21s %8d\"; private static final String DB_INFO_FORMAT = \" %8s %8s %14s %14s %s\"; ... public void scheduleConfigurationChanged(Configuration config) &#123; updatePendingConfiguration(config); queueOrSendMessage(H.CONFIGURATION_CHANGED, config); &#125; ... &#125; 而ApplicationThread中的handler的CONFIGURATION_CHANGED是调用handleConfigurationChanged()。 123456789101112131415161718final void handleConfigurationChanged(Configuration config, CompatibilityInfo compat) &#123; ArrayList&lt;ComponentCallbacks2&gt; callbacks = null; ... ... applyConfigurationToResourcesLocked(config, compat); ... callbacks = collectComponentCallbacksLocked(false, config); ... if (callbacks != null) &#123; final int N = callbacks.size(); for (int i=0; i&lt;N; i++) &#123; performConfigurationChanged(callbacks.get(i), config); &#125; &#125; 这个函数首先是调用applyConfigurationToResourcesLocked(). 看函数名大概可以猜想到: 将configuration应用到resources.这里configuration改变的是local 本地语言. 那而resources资源包含语言包吗？ 12345678910111213141516171819202122232425262728293031323334353637383940final boolean applyConfigurationToResourcesLocked(Configuration config, CompatibilityInfo compat) &#123; int changes = mResConfiguration.updateFrom(config); DisplayMetrics dm = getDisplayMetricsLocked(null, true); if (compat != null &amp;&amp; (mResCompatibilityInfo == null || !mResCompatibilityInfo.equals(compat))) &#123; mResCompatibilityInfo = compat; changes |= ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE; &#125; ... Resources.updateSystemConfiguration(config, dm, compat); ... Iterator&lt;WeakReference&lt;Resources&gt;&gt; it = mActiveResources.values().iterator(); while (it.hasNext()) &#123; WeakReference&lt;Resources&gt; v = it.next(); Resources r = v.get(); if (r != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Changing resources \" + r + \" config to: \" + config); r.updateConfiguration(config, dm, compat); //Slog.i(TAG, \"Updated app resources \" + v.getKey() // + \" \" + r + \": \" + r.getConfiguration()); &#125; else &#123; //Slog.i(TAG, \"Removing old resources \" + v.getKey()); it.remove(); &#125; &#125; return changes != 0; &#125; Resources.updateSystemConfiguration()清除一部分系统资源, 并且将config更新到Resources, 而Resources包含了一个AssetManager对象, 该对象的核心实现是在AssetManager.cpp中完成的. 然后循环清空mActivityResources资源. 再回到handleConfigurationChanged()函数, 执行完updateSystemConfiguration后, 会循环该进程的所有activity: if (callbacks != null) { final int N = callbacks.size(); for (int i=0; i&lt;N; i++) { performConfigurationChanged(callbacks.get(i), config); } } 再来看performConfigurationChanged的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445private final void performConfigurationChanged( ComponentCallbacks2 cb, Configuration config) &#123; // Only for Activity objects, check that they actually call up to their // superclass implementation. ComponentCallbacks2 is an interface, so // we check the runtime type and act accordingly. Activity activity = (cb instanceof Activity) ? (Activity) cb : null; if (activity != null) &#123; activity.mCalled = false; &#125; boolean shouldChangeConfig = false; if ((activity == null) || (activity.mCurrentConfig == null)) &#123; shouldChangeConfig = true; &#125; else &#123; // If the new config is the same as the config this Activity // is already running with then don't bother calling // onConfigurationChanged int diff = activity.mCurrentConfig.diff(config); if (diff != 0) &#123; // If this activity doesn't handle any of the config changes // then don't bother calling onConfigurationChanged as we're // going to destroy it. if ((~activity.mActivityInfo.getRealConfigChanged() &amp; diff) == 0) &#123; shouldChangeConfig = true; &#125; &#125; &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Config callback \" + cb + \": shouldChangeConfig=\" + shouldChangeConfig); if (shouldChangeConfig) &#123; cb.onConfigurationChanged(config); if (activity != null) &#123; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + activity.getLocalClassName() + \" did not call through to super.onConfigurationChanged()\"); &#125; activity.mConfigChangeFlags = 0; activity.mCurrentConfig = new Configuration(config); &#125; &#125; &#125; 该函数判断configuration是否改变, 如果改变那么shouldChangeConfig为true. 然后调用activity的onConfigurationChange(config); 1234567891011121314151617181920212223242526272829303132/** * Called by the system when the device configuration changes while your * activity is running. Note that this will &lt;em&gt;only&lt;/em&gt; be called if * you have selected configurations you would like to handle with the * &#123;@link android.R.attr#configChanges&#125; attribute in your manifest. If * any configuration change occurs that is not selected to be reported * by that attribute, then instead of reporting it the system will stop * and restart the activity (to have it launched with the new * configuration). * * &lt;p&gt;At the time that this function has been called, your Resources * object will have been updated to return resource values matching the * new configuration. * * @param newConfig The new device configuration. */ public void onConfigurationChanged(Configuration newConfig) &#123; mCalled = true; mFragments.dispatchConfigurationChanged(newConfig); if (mWindow != null) &#123; // Pass the configuration changed event to the window mWindow.onConfigurationChanged(newConfig); &#125; if (mActionBar != null) &#123; // Do this last; the action bar will need to access // view changes from above. mActionBar.onConfigurationChanged(newConfig); &#125; &#125; 查看注释, 大概意思是: 如果你的activity运行 , 设备信息有改变(即configuration改变)时由系统调用. 如果你在manifest.xml中配置了configChnages属性则表示有你自己来处理configuration change. 否则就重启当前这个activity. 而重启之前, 旧的resources已经被清空, 那么就会装载新的资源, 整个过程就完成了语言切换后 , 能够让所有app使用新的语言。 上面这些就是对Android 系统里面的语言切换进行了源码分析，就先分析到这里；有些东西我也不是很看懂，能力有限~ 明天我们再来分析怎么来实现Android 系统语言切换的功能。 Android 切换系统语言功能实现！ O(∩_∩)O~ 打哈欠了睡觉了~ 转载请标明出处： http://blog.csdn.net/u011974987/article/details/50793343","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"语言切换","slug":"语言切换","permalink":"https://xuhaoblog.com/tags/语言切换/"}]},{"title":"Android 切换系统语言功能实现（下）","slug":"android-change-language_02","date":"2016-04-12T04:05:24.000Z","updated":"2017-11-04T10:58:08.000Z","comments":true,"path":"2016/04/12/android-change-language_02/","link":"","permalink":"https://xuhaoblog.com/2016/04/12/android-change-language_02/","excerpt":"概述：简单介绍下这个需求的缘由，这段时间因公司业务需要，其中有一项“设置系统语言”功能，就是在使用APP的过程中，动态的去切换整个Android机器的语言，具体参照手机设置页面有语言切换功能。期初想来是很简单的事情嘛，不就是个简单的资源国际化嘛，strings.xml资源文件一整还不给OK？真正动起手来就真不是这么一回事了，国际化是没问题，但是怎样能更改所有页面的文字资源呢，这是一个问题。下面介绍下网上找的几个方案。 一、API欺骗 烧制到手机中的android.jar包含了Android所需的各种类与方法；而供开发者使用的android.jar只是其中的一部分。API欺骗是指在应用中去模拟未公开的类和方法让应用编译通过并生成APK，然而在应用实际运行中调用的却仍是烧制到手机中真实的android.jar。","text":"概述：简单介绍下这个需求的缘由，这段时间因公司业务需要，其中有一项“设置系统语言”功能，就是在使用APP的过程中，动态的去切换整个Android机器的语言，具体参照手机设置页面有语言切换功能。期初想来是很简单的事情嘛，不就是个简单的资源国际化嘛，strings.xml资源文件一整还不给OK？真正动起手来就真不是这么一回事了，国际化是没问题，但是怎样能更改所有页面的文字资源呢，这是一个问题。下面介绍下网上找的几个方案。 一、API欺骗 烧制到手机中的android.jar包含了Android所需的各种类与方法；而供开发者使用的android.jar只是其中的一部分。API欺骗是指在应用中去模拟未公开的类和方法让应用编译通过并生成APK，然而在应用实际运行中调用的却仍是烧制到手机中真实的android.jar。 二、使用Java反射机制IActivityManager与ActivityManagerNative都是非公开类，使用Java反射去调用其中的方法。 但是这个弊端是显而易见的，上述两种方法都是去更改系统的语言的类型，功能和你去设置页面去设置语言类型的效果一样。发现对当前系统设置了新的Locale后，不单自己的应用语系改变了，系统所有的应用语系都改变了，这正是我们所需要的。折腾了下下这个很2的问题。网上放的方法比较旧， Android5.1的话， 设置后当时生效， 重启后就失效了。 核心代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * TODO&lt;更新系统语言&gt; * * @author Xiho * @versionCode 1 &lt;每次修改提交前+1&gt; */@SuppressWarnings(\"unchecked\")public class LanguageUtils &#123; public static void updateLanguage(Locale locale) &#123; try &#123; Object objIActMag, objActMagNative; Class clzIActMag = Class.forName(\"android.app.IActivityManager\"); Class clzActMagNative = Class .forName(\"android.app.ActivityManagerNative\"); //amn = ActivityManagerNative.getDefault(); Method mtdActMagNative$getDefault = clzActMagNative .getDeclaredMethod(\"getDefault\"); objIActMag = mtdActMagNative$getDefault.invoke(clzActMagNative); // objIActMag = amn.getConfiguration(); Method mtdIActMag$getConfiguration = clzIActMag .getDeclaredMethod(\"getConfiguration\"); Configuration config = (Configuration) mtdIActMag$getConfiguration .invoke(objIActMag); // set the locale to the new value config.locale = locale; //持久化 config.userSetLocale = true; Class clzConfig = Class .forName(\"android.content.res.Configuration\"); java.lang.reflect.Field userSetLocale = clzConfig .getField(\"userSetLocale\"); userSetLocale.set(config, true); // 此处需要声明权限:android.permission.CHANGE_CONFIGURATION // 会重新调用 onCreate(); Class[] clzParams = &#123; Configuration.class &#125;; // objIActMag.updateConfiguration(config); Method mtdIActMag$updateConfiguration = clzIActMag .getDeclaredMethod(\"updateConfiguration\", clzParams); mtdIActMag$updateConfiguration.invoke(objIActMag, config); BackupManager.dataChanged(\"com.android.providers.settings\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这样我们利用JAVA的反射机制，调用那些隐藏的方法就可以实现了。 需要注意的是调用此方法： 12// objIActMag.updateConfiguration(config);mtdIActMag$updateConfiguration.invoke(objIActMag, config); 需要加上权限： 1android.permission.CHANGE_CONFIGURATION 并且此处会重新调用onCreate方法，我就在这个地方处被坑了一把。（如果调用此方法的时候做了一些逻辑，就注意下）。 不同的地方在添加了 123Class clzConfig = Class.forName(\"android.content.res.Configuration\"); java.lang.reflect.Field userSetLocale = clzConfig.getField(\"userSetLocale\"); userSetLocale.set(config, true); Debug发现的逻辑是：1： 持久化保存下来 12SystemProperties.set(\"persist.sys.language\", l.getLanguage());SystemProperties.set(\"persist.sys.country\", l.getCountry()); 2： 开机AndroidRuntime读取这个属性， 更新系统之前的属性。估计是为了方便跑测试的Case添加的这个逻辑。 最后声明： 既然是更改系统的配置当然你的签名也应该是系统签名和sharedUserId。不然会类似以下的错误！ error： java.lang.SecurityException: Permission Denial: updateConfiguration() from pid=31594, uid=10099 requires android.permission.CHANGE_CONFIGURATION 各位都注意下吧~ 附上GitHub源码：SwitchLanguage； welcome everyone’s Star and fork！ 转载请标明出处： http://blog.csdn.net/u011974987/article/details/50801770","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"语言切换","slug":"语言切换","permalink":"https://xuhaoblog.com/tags/语言切换/"}]},{"title":"Android 5.1 Settings源码简要分析","slug":"android-5.1-settings","date":"2016-04-11T09:05:24.000Z","updated":"2017-11-04T11:00:33.000Z","comments":true,"path":"2016/04/11/android-5.1-settings/","link":"","permalink":"https://xuhaoblog.com/2016/04/11/android-5.1-settings/","excerpt":"概述：先声明：本人工作快两年了，仍是菜鸟级别的，惭愧啊！以前遇到好多知识点都没有记录下来，感觉挺可惜的，现在有机会接触Android 源码。我们一个Android组的搞Setting，我觉得是得写得东西，毕竟才接触，现在只能看一段时间代码，就先记录下一些收获吧，说多了就是泪~本文主要针对L平台上Settings模块正常启动流程做一个简要分析，并试着分析一下Settings下面某选项的实现。","text":"概述：先声明：本人工作快两年了，仍是菜鸟级别的，惭愧啊！以前遇到好多知识点都没有记录下来，感觉挺可惜的，现在有机会接触Android 源码。我们一个Android组的搞Setting，我觉得是得写得东西，毕竟才接触，现在只能看一段时间代码，就先记录下一些收获吧，说多了就是泪~本文主要针对L平台上Settings模块正常启动流程做一个简要分析，并试着分析一下Settings下面某选项的实现。 Setting 简介在之前的KK平台上Settings模块的第一个Activity名字为Settings，其继承的是PreferenceActivity，设置的每一个选项都是对应的一个Header对象，并且Header对象允许显示switch控件，button控件，checkbox控件等。如下图1.1，WLAN和蓝牙上使用到了switch开关。但在L上面，WLAN和蓝牙的这两个开关已经去掉了，如图1.2，在Settings模块的首个页面似乎就只是一个普通的Listview，那它用的还是不是Header呢？或者说取而代之的是什么呢？继续往下看吧~ 图片-1.1图片-1.2 L Settings 模块首界面初始化流程L Settings模块首界面为Settings，继承自SettingsActivity，SettingsActivity继承自Activity。 首先看一下Settings.java代码可以发现它没有重写任何SettingsActiviy的方法，也没有增加任何自己的方法，唯独增加了许多静态内部类，如： 123456789101112131415161718192021222324252627/** * Top-level Settings activity */public class Settings extends SettingsActivity &#123; /* * Settings subclasses for launching independently. */ public static class BluetoothSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class WirelessSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class SimSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class TetherSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class VpnSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class DateTimeSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class StorageSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class WifiSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class WifiP2pSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class InputMethodAndLanguageSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class KeyboardLayoutPickerActivity extends SettingsActivity &#123; /* empty */ &#125; public static class InputMethodAndSubtypeEnablerActivity extends SettingsActivity &#123; /* empty */ &#125; public static class VoiceInputSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class SpellCheckersSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class LocalePickerActivity extends SettingsActivity &#123; /* empty */ &#125; public static class UserDictionarySettingsActivity extends SettingsActivity &#123; /* empty */ &#125; public static class HomeSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; ... &#125; 看注释可以知道，这些子类是为了启动特定独立的Settings选项而创建的，例如在某个应用里需要设置无线那么只需要启动 WirelessSettingsActivity 就可以了。 所以Settings模块的启动流程直接看SettingsActiviy就行了。 SettingsActivity.onCreate方法onCreate方法是Activity的生命周期第一步，看看 SettingsActivity在这里都做了些什么？ 123// Should happen before any call to getIntent() getMetaData(); 这个方法用来获得Activity的额外数据mFragmentClass，如果可以获得这个数据，那么下面会去显示mFragmentClass对应的Activity。直接启动Settings模块不会获得这个数据。 1mIsShowingDashboard = className.equals(Settings.class.getName()); 这一步很重要，因为我们是从Settings这个Activity过来的，所以这里的 mIsShowingDashboard 为 true 。 123456789// This is a \"Sub Settings\" when: // - this is a real SubSettings // - or :settings:show_fragment_as_subsetting is passed to the Intent final boolean isSubSettings = className.equals(SubSettings.class.getName()) || intent.getBooleanExtra(EXTRA_SHOW_FRAGMENT_AS_SUBSETTING, false); 这个判断很重要但很明显这时isSubSettings的值是fasle，暂时忽略。 123setContentView(mIsShowingDashboard ? R.layout.settings_main_dashboard : R.layout.settings_main_prefs); 前面知道这里的 mIsShowingDashboard为true，所以这里使用的布局文件为R.layout.settings_main_dashboard。settings_main_dashboard.xml文件如下： 1234567891011&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/main_content\" android:layout_height=\"match_parent\" android:layout_width=\"match_parent\" android:background=\"@color/dashboard_background_color\" /&gt; 由于mIsShowingDashboard为true，直接走到下面这段 1234567891011121314151617else &#123; // No UP affordance if we are displaying the main Dashboard mDisplayHomeAsUpEnabled = false; // Show Search affordance mDisplaySearch = true; mInitialTitleResId = R.string.dashboard_title; switchToFragment(DashboardSummary.class.getName(), null, false, false, mInitialTitleResId, mInitialTitle, false); &#125; 这里看到switchToFragment这个方法，可以知道这里是要切换DashboardSummary这个Fragment. 接下来就看看DashboardSummary是个什么玩意？ dashboard中文意思是仪表盘，这里是指DashboardSummary就是用来显示Settings所有选项的。 在DashboardSummary的onCreateView里加载了这个布局文件R.layout.dashboard 123456789101112131415161718192021222324252627282930313233343536373839&lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/dashboard\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbarStyle=\"outsideOverlay\" android:clipToPadding=\"false\"&gt; &lt;LinearLayout android:id=\"@+id/dashboard_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center_horizontal\" android:paddingStart=\"@dimen/dashboard_padding_start\" android:paddingEnd=\"@dimen/dashboard_padding_end\" android:paddingTop=\"@dimen/dashboard_padding_top\" android:paddingBottom=\"@dimen/dashboard_padding_bottom\" android:orientation=\"vertical\" /&gt; &lt;/ScrollView&gt; 看了上面的布局文件可以知道Settings的选项视图应该就是显示在dashboard_container中了。 DashboardSummary走完onCreateView方法后会走onResume,然后一路下来又会调到SettingsActivity的 1loadCategoriesFromResource(R.xml.dashboard_categories, categories); 这一步是通过 R.xml.dashboard_categories来加载categories，这里的categorys为ArrayList mCategories。接着来看看dashboard_categories.xml这个文件吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- Copyright (C) 2014 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;dashboard-categories xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- WIRELESS and NETWORKS --&gt; &lt;dashboard-category android:id=\"@+id/wireless_section\" android:title=\"@string/header_category_wireless_networks\" &gt; &lt;!-- Wifi --&gt; &lt;dashboard-tile android:id=\"@+id/wifi_settings\" android:title=\"@string/wifi_settings_title\" android:fragment=\"com.android.settings.wifi.WifiSettings\" android:icon=\"@drawable/ic_settings_wireless\" /&gt; &lt;!--HetComm--&gt; &lt;dashboard-tile android:id=\"@+id/hetcomm_settings\" android:icon=\"@drawable/ic_settings_hetcomm\" android:title=\"@string/hetcom_setting_title\"&gt; &lt;intent android:action=\"com.android.settings.HETCOMM_SETTINGS\" /&gt; &lt;/dashboard-tile&gt; &lt;!-- Bluetooth --&gt; &lt;dashboard-tile android:id=\"@+id/bluetooth_settings\" android:title=\"@string/bluetooth_settings_title\" android:fragment=\"com.android.settings.bluetooth.BluetoothSettings\" android:icon=\"@drawable/ic_settings_bluetooth2\" /&gt; &lt;!-- Hotknot --&gt; &lt;dashboard-tile android:id=\"@+id/hotknot_settings\" android:title=\"@string/hotknot_settings_title\" android:fragment=\"com.mediatek.settings.hotknot.HotKnotSettings\" android:icon=\"@drawable/ic_settings_hotknot\" /&gt; &lt;!-- SIM Cards --&gt; &lt;dashboard-tile android:id=\"@+id/sim_settings\" android:title=\"@string/sim_settings_title\" android:fragment=\"com.android.settings.sim.SimSettings\" android:icon=\"@drawable/ic_sim_sd\" /&gt; &lt;!-- Data Usage --&gt; &lt;dashboard-tile android:id=\"@+id/data_usage_settings\" android:title=\"@string/data_usage_summary_title\" android:fragment=\"com.android.settings.DataUsageSummary\" android:icon=\"@drawable/ic_settings_data_usage\" /&gt; &lt;!-- Operator hook --&gt; &lt;dashboard-tile android:id=\"@+id/operator_settings\" android:fragment=\"com.android.settings.WirelessSettings\" &gt; &lt;intent android:action=\"com.android.settings.OPERATOR_APPLICATION_SETTING\" /&gt; &lt;/dashboard-tile&gt; &lt;!-- Other wireless and network controls --&gt; &lt;dashboard-tile android:id=\"@+id/wireless_settings\" android:title=\"@string/radio_controls_title\" android:fragment=\"com.android.settings.WirelessSettings\" android:icon=\"@drawable/ic_settings_more\" /&gt; &lt;/dashboard-category&gt; &lt;!-- DEVICE --&gt; &lt;dashboard-category android:id=\"@+id/device_section\" android:title=\"@string/header_category_device\" &gt; &lt;!-- Home --&gt; &lt;dashboard-tile android:id=\"@+id/home_settings\" android:title=\"@string/home_settings\" android:fragment=\"com.android.settings.HomeSettings\" android:icon=\"@drawable/ic_settings_home\" /&gt; &lt;!-- Display --&gt; &lt;dashboard-tile android:id=\"@+id/display_settings\" android:title=\"@string/display_settings\" android:fragment=\"com.android.settings.DisplaySettings\" android:icon=\"@drawable/ic_settings_display\" /&gt; &lt;!-- Notifications --&gt; &lt;dashboard-tile android:id=\"@+id/notification_settings\" android:title=\"@string/notification_settings\" android:fragment=\"com.mediatek.audioprofile.AudioProfileSettings\" android:icon=\"@drawable/ic_settings_notifications\" /&gt; &lt;!-- Storage --&gt; &lt;dashboard-tile android:id=\"@+id/storage_settings\" android:title=\"@string/storage_settings\" android:fragment=\"com.android.settings.deviceinfo.Memory\" android:icon=\"@drawable/ic_settings_storage\" /&gt; &lt;!-- Battery --&gt; &lt;dashboard-tile android:id=\"@+id/battery_settings\" android:title=\"@string/power_usage_summary_title\" android:fragment=\"com.android.settings.fuelgauge.PowerUsageSummary\" android:icon=\"@drawable/ic_settings_battery\" /&gt; &lt;!-- Application Settings --&gt; &lt;dashboard-tile android:id=\"@+id/application_settings\" android:title=\"@string/applications_settings\" android:fragment=\"com.android.settings.applications.ManageApplications\" android:icon=\"@drawable/ic_settings_applications\" /&gt; &lt;!-- Manage users --&gt; &lt;dashboard-tile android:id=\"@+id/user_settings\" android:title=\"@string/user_settings_title\" android:fragment=\"com.android.settings.users.UserSettings\" android:icon=\"@drawable/ic_settings_multiuser\" /&gt; &lt;!-- Manage NFC payment apps --&gt; &lt;dashboard-tile android:id=\"@+id/nfc_payment_settings\" android:title=\"@string/nfc_payment_settings_title\" android:fragment=\"com.android.settings.nfc.PaymentSettings\" android:icon=\"@drawable/ic_settings_nfc_payment\" /&gt; &lt;!-- Manufacturer hook --&gt; &lt;dashboard-tile android:id=\"@+id/manufacturer_settings\" android:fragment=\"com.android.settings.WirelessSettings\"&gt; &lt;intent android:action=\"com.android.settings.MANUFACTURER_APPLICATION_SETTING\" /&gt; &lt;/dashboard-tile&gt; &lt;/dashboard-category&gt; &lt;!-- PERSONAL --&gt; &lt;dashboard-category android:id=\"@+id/personal_section\" android:title=\"@string/header_category_personal\" &gt; &lt;!-- Location --&gt; &lt;dashboard-tile android:id=\"@+id/location_settings\" android:title=\"@string/location_settings_title\" android:fragment=\"com.android.settings.location.LocationSettings\" android:icon=\"@drawable/ic_settings_location\" /&gt; &lt;!-- Security --&gt; &lt;dashboard-tile android:id=\"@+id/security_settings\" android:title=\"@string/security_settings_title\" android:fragment=\"com.android.settings.SecuritySettings\" android:icon=\"@drawable/ic_settings_security\" /&gt; &lt;!-- Account --&gt; &lt;dashboard-tile android:id=\"@+id/account_settings\" android:title=\"@string/account_settings_title\" android:fragment=\"com.android.settings.accounts.AccountSettings\" android:icon=\"@drawable/ic_settings_accounts\" /&gt; &lt;!-- Language --&gt; &lt;dashboard-tile android:id=\"@+id/language_settings\" android:title=\"@string/language_settings\" android:fragment=\"com.android.settings.inputmethod.InputMethodAndLanguageSettings\" android:icon=\"@drawable/ic_settings_language\" /&gt; &lt;!-- Backup and reset --&gt; &lt;dashboard-tile android:id=\"@+id/privacy_settings\" android:title=\"@string/privacy_settings\" android:fragment=\"com.android.settings.PrivacySettings\" android:icon=\"@drawable/ic_settings_backup\" /&gt; &lt;/dashboard-category&gt; &lt;!-- SYSTEM --&gt; &lt;dashboard-category android:id=\"@+id/system_section\" android:title=\"@string/header_category_system\" &gt; &lt;!-- Date &amp; Time --&gt; &lt;dashboard-tile android:id=\"@+id/date_time_settings\" android:title=\"@string/date_and_time_settings_title\" android:fragment=\"com.android.settings.DateTimeSettings\" android:icon=\"@drawable/ic_settings_date_time\" /&gt; &lt;!--Scheduled power on&amp;off--&gt; &lt;dashboard-tile android:id=\"@+id/power_settings\" android:icon=\"@drawable/ic_settings_schpwronoff\" android:title=\"@string/schedule_power_on_off_settings_title\"&gt; &lt;intent android:action=\"com.android.settings.SCHEDULE_POWER_ON_OFF_SETTING\" /&gt; &lt;/dashboard-tile&gt; &lt;!-- Accessibility feedback --&gt; &lt;dashboard-tile android:id=\"@+id/accessibility_settings\" android:title=\"@string/accessibility_settings\" android:fragment=\"com.android.settings.accessibility.AccessibilitySettings\" android:icon=\"@drawable/ic_settings_accessibility\" /&gt; &lt;!-- Print --&gt; &lt;dashboard-tile android:id=\"@+id/print_settings\" android:title=\"@string/print_settings\" android:fragment=\"com.android.settings.print.PrintSettingsFragment\" android:icon=\"@drawable/ic_settings_print\" /&gt; &lt;!-- Development --&gt; &lt;dashboard-tile android:id=\"@+id/development_settings\" android:title=\"@string/development_settings_title\" android:fragment=\"com.android.settings.DevelopmentSettings\" android:icon=\"@drawable/ic_settings_development\" /&gt; &lt;!-- About Device --&gt; &lt;dashboard-tile android:id=\"@+id/about_settings\" android:title=\"@string/about_settings\" android:fragment=\"com.android.settings.DeviceInfoSettings\" android:icon=\"@drawable/ic_settings_about\" /&gt; &lt;/dashboard-category&gt;&lt;/dashboard-categories&gt; 根据这个文件我们可以知道了，所谓的dashboard就是Settings模块首界面的一个抽象。而dashboard-categorys则是设置分类集合的抽象，而dashboard-category是分类的抽象，dashboard-tile就是分类下每个选项的抽象了。代码中的List对应dashboard-categorys， DashboardCategory对应dashboard-category，而dashboard-tile则对因代码中的DashboardTile。 当加载完这些对象后SettingsActivity会将得到的 mCategories 返回给DashboardSummary来初始化Settings的设置选项。 下面这段代码就是DashboardSummary.rebuildUI()中完成界面的初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273long start = System.currentTimeMillis(); final Resources res = getResources(); mDashboard.removeAllViews(); List&lt;DashboardCategory&gt; categories = ((SettingsActivity) context).getDashboardCategories(true); final int count = categories.size(); for (int n = 0; n &lt; count; n++) &#123; DashboardCategory category = categories.get(n); View categoryView = mLayoutInflater.inflate(R.layout.dashboard_category, mDashboard, false); TextView categoryLabel = (TextView) categoryView.findViewById(R.id.category_title); categoryLabel.setText(category.getTitle(res)); ViewGroup categoryContent = (ViewGroup) categoryView.findViewById(R.id.category_content); final int tilesCount = category.getTilesCount(); for (int i = 0; i &lt; tilesCount; i++) &#123; DashboardTile tile = category.getTile(i); DashboardTileView tileView = new DashboardTileView(context); updateTileView(context, res, tile, tileView.getImageView(), tileView.getTitleTextView(), tileView.getStatusTextView()); tileView.setTile(tile); categoryContent.addView(tileView); &#125; // Add the category mDashboard.addView(categoryView); &#125; 这段代码我就不具体分析了，逻辑很简单，遍历categories这个列表来获取DashboardCategory对象，将所有DashboardCategory对象和DashboardCategory对象中的DashboardTile对象转化为视图对象并添加到主视图对象mDashboard中。 到这里SettingsActivity的onCreate方法就算结束了。总结一下， 1.onCreate完成的任务是切换DashboardSmmary这个Fragment，然后从dashboard_categories.xml中读取预先配置好的文件来初始化Settings的首界面视图。 2.L中舍弃了Header类，取而代之的是DashboardCategory和DashboardTile类。 转载请注明出处，谢谢~: http://blog.csdn.net/u011974987/article/details/51004854","categories":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xuhaoblog.com/tags/Android/"},{"name":"Settings","slug":"Settings","permalink":"https://xuhaoblog.com/tags/Settings/"}]},{"title":"Ubuntu 更改 Gun Make 版本","slug":"change-gun-make-code","date":"2016-04-10T04:35:12.000Z","updated":"2017-11-04T11:06:08.000Z","comments":true,"path":"2016/04/10/change-gun-make-code/","link":"","permalink":"https://xuhaoblog.com/2016/04/10/change-gun-make-code/","excerpt":"1：Gun Make 下载地址ftp://ftp.gnu.org/gnu/make/ 2： 下载并解压 make3.8.1.tar.gz1$ tar -zxvf make3.8.1.tar.gz 3： 编译Make12$ ./configure$ make 4： 安装Make1$ sudo make install","text":"1：Gun Make 下载地址ftp://ftp.gnu.org/gnu/make/ 2： 下载并解压 make3.8.1.tar.gz1$ tar -zxvf make3.8.1.tar.gz 3： 编译Make12$ ./configure$ make 4： 安装Make1$ sudo make install","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xuhaoblog.com/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xuhaoblog.com/tags/Ubuntu/"},{"name":"Gun Make","slug":"Gun-Make","permalink":"https://xuhaoblog.com/tags/Gun-Make/"}]},{"title":"Ubuntu 15.10 下载Android5.1代码环境搭建","slug":"android-source-download","date":"2016-04-10T02:05:36.000Z","updated":"2017-11-04T11:06:33.000Z","comments":true,"path":"2016/04/10/android-source-download/","link":"","permalink":"https://xuhaoblog.com/2016/04/10/android-source-download/","excerpt":"概述：作为一个Android开发者，想要自己提升一个阶段，想深入了解 Android 相关的知识，Activity 是工作流程是怎样的？ View 是怎样绘制的？ 怎样修改一些系统相关的应用？等等，就得要深入Android 源代码~所以就要先获取Android源码： 准备工作： 装一个Ubuntu系统（http://www.ubuntu.com/download/desktop）电脑的内存最好有 8 G，因为编译 Android 源码很吃电脑内存，特别是在 4.4 以后的版本，电脑内存大点，比较保险，编译一次源码要好几个小时，要因为内存原因，太让人郁闷了。ps:( ubuntu装完后把系统软件全都更新一下) 一个翻墙vpn（https://www.trueyt.com/）","text":"概述：作为一个Android开发者，想要自己提升一个阶段，想深入了解 Android 相关的知识，Activity 是工作流程是怎样的？ View 是怎样绘制的？ 怎样修改一些系统相关的应用？等等，就得要深入Android 源代码~所以就要先获取Android源码： 准备工作： 装一个Ubuntu系统（http://www.ubuntu.com/download/desktop）电脑的内存最好有 8 G，因为编译 Android 源码很吃电脑内存，特别是在 4.4 以后的版本，电脑内存大点，比较保险，编译一次源码要好几个小时，要因为内存原因，太让人郁闷了。ps:( ubuntu装完后把系统软件全都更新一下) 一个翻墙vpn（https://www.trueyt.com/） 编译环境的部署： 访问： http://source.android.com/source/initializing.html 1、 Installing the JDKAndroid 5.0 编译需要 Open Java7 版本12$ sudo apt-get update$ sudo apt-get install openjdk-7-jdk Android 4.4 编译需要 Sun Java6 版本 123$ sudo add-apt-repository ppa:webupd8team/java$ sudo apt-get update$ sudo apt-get install oracle-java6-set-default 切换 Java 的方法 (上面 2 个根据你的需要安装) 12$ sudo update-alternatives --config java$ sudo update-alternatives --config javac 2、 Installing required packages123$ sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip$ sudo apt-get install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386$ sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so Notes！！不同的 Ubuntu 版本可能不能，安装这些编译工具可能不成功，也不用管，在你编译的时候，可能会出错，根据错误日志去解决就行了。 配置 USB 访问 (下面的都可能需要翻墙了) 12$ wget -S -O - http://source.android.com/source/51-android.rules | sed \"s/&lt;username&gt;/$USER/\" |sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; $ sudo udevadm control --reload-rules 安装 repo ， repo 是 git 的管理工具 1234$ mkdir ~/bin$ PATH=~/bin:$PATH$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo 下载源代码（我这边添加的是内置服务器，从我们自己的服务器下载的代码很快，一般一个小时左右就下载完了！） 建立一个目录来存放 Android 源码 12$ mkdir android_source_5.0$ cd android_source_5.0 初始化下载 12$ repo init -u https://android.googlesource.com/platform/manifest -b 你要同步的源码(android-5.0.1_r1) 在初始化时，可能要配置下git的emai 信息： 12$ git config --global user.email \"you@example.com\"$ git config --global user.name \"Your Name\" Downloading the Android Source Tree同步源码 1$ repo sync 这个命令如果代理断了需要重新执行这个命令同步代码(也可以写一个shell 脚本) 当控制台显示 successful的时候恭喜你代码同步成功了~控制台显示如下： 编译源代码进入到你DownLoad 源码的目录下，执行以下命令 1234$ cd android_source_5.0$ source build/envsetup.sh$ choosecombo release aosp_flo eng$ make -j4 编译的时间是漫长的，中间还可能出错，所以我们需要随时陪同，中间还可能需要解错，当你看见屏幕的最下面出现 Successful 的时候，恭喜你，源码已经编译成功。如下图： 转载请注明出处：http://blog.csdn.net/u011974987/article/details/50978291","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xuhaoblog.com/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xuhaoblog.com/tags/Ubuntu/"},{"name":"Android源码下载","slug":"Android源码下载","permalink":"https://xuhaoblog.com/tags/Android源码下载/"},{"name":"Android环境搭建","slug":"Android环境搭建","permalink":"https://xuhaoblog.com/tags/Android环境搭建/"}]}]}