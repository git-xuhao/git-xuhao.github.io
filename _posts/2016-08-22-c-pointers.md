---
layout: post
title: C 语言指针概念的理解（四）
permalink: c-pointers
date: 2016-08-22 14:41:06
categories: C/C++
tags: C/C++
desc: 最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了）
---

## **前言** ##
最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了） 

## **指针**##
	

 我们通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有必要的。
正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

<!-- more -->
```
#include <stdio.h>

int main ()
{
   int  var1;
   char var2[10];

   printf("var1 变量的地址： %x\n", &var1  );
   printf("var2 变量的地址： %x\n", &var2  );

   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：

```
var1 变量的地址： bff5a400
var2 变量的地址： bff5a3f6
```

通过上面的栗子，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针吧！



## **什么是指针？** ##

指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```
type *name;
```

这里的type 是指针的基类型，它必须是一个有效的 C 数据类型，name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

```
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch     /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

## **如何使用指针？** ##
* 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

```
#include <stdio.h>
//指针
//指针存储的是变量的内存地址
//内存地址，系统给数据分配的编号（门牌号）

void main(){
	int i = 90;
	//指针变量，创建一个int类型的指针
	int* p = &i; //p的值就是i这个变量的内存地址
	printf("%#x\n",p);

	float f = 89.5f;
	//创建一个float类型的指针
	float *fp = &f;
	printf("%#x\n", fp);

	system("pause");
}
```

上面的代码被编译和执行时，运行的结果：

```
0xeffb30
0xeffb18
请按任意键继续. . .
```
* 对指针存的地址指向的变量进行操作

```
#include <stdio.h>

void change(int* p){
	*p = 300;
}

//变量名，对内存空间上的一段数据的抽象
void main(){
	int i = 90;
	//i = 89;
	//创建一个int类型的指针
	int *p = &i;
	//输出地址
	printf("p的地址：%#x\n",&p);
	printf("i的地址：%#x\n",&i);
	printf("i的值为：%d\n", i);
	//间接赋值 i = 200;

	//对p存的地址指向的变量进行操作
	//*p = 200;
	//change(p);
	change(&i);  // int *p = &i;
	printf("i的值为：%d\n",i);

	system("pause");
}
```
上面代码编译执行结果如下：

```
p的地址：0x6ffdb0
i的地址：0x6ffdbc
i的值为：90
i的值为：300
请按任意键继续. . .

```
通过上面栗子，我们可以看出，指针所指向的变量值已经被更改了。

## **C中的NULL 指针** ##

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。
NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

```
#include <stdio.h>

int main ()
{
   int  *ptr = NULL;

   printf("ptr 的值是 %x\n", ptr  );
 
   return 0;
}
```
运行结果为：

```
ptr 的值是 0
```

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。
如需检查一个空指针，您可以使用 if 语句，如下所示：

```
#include <stdio.h>

int main(int argc, char const *argv[]) {

  char *s = "hello";

  if (!s) {
    fprintf(stderr, "s is null\n");
  } else {
    fprintf(stderr, "%s\n", s);
  }

  if (s == NULL) {
    fprintf(stderr, "s is null\n");
  } else {
    fprintf(stderr, "%s\n", s);
  }


  return 0;
}
```

这两种方法都能判断字符指针是否为空，但推荐使用前者。"NULL" 的本质是个宏，并非是个常量，C99 中甚至可以自行定义，故尽量避免使用它去判断，当 !s 与 s == NULL 表示同一含义的时候，使用前者吧！

## **C中的二级指针（多级指针）** ##
指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int *、double *、char * 等。

如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。
假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示：

![这里写图片描述](https://img-blog.csdn.net/20160821214956473)

用代码表示为：

```
int a =100;
int *p1 = &a;
int **p2 = &p1;
```

指针变量也是一种变量，也会占用存储空间，也可以使用&获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号 * 。p1 是一级指针，指向普通类型的数据，定义时有一个 * ；p2 是二级指针，指向一级指针 p1，定义时有两个*。

如果再定义一个三级指针 p3，让它指向 p2，那么可以这样写：

```
int ***p3 = &p2;
```

四级指针：

```
int ****p4 = &p3;
```
等等，以此类推。。。
不过，经常使用的也就是一级指针和二级指针了。
在获取指针指向的数据时，一级指针加一个 * ，二级指针加两个 * ，三级指针加三个 *，以此类推，请看代码：

```
#include <stdio.h>
int main(){
    int a =100;
    int *p1 = &a;
    int **p2 = &p1;
    int ***p3 = &p2;
    printf("%d, %d, %d, %d\n", a, *p1, **p2, ***p3);
    printf("&p2 = %#X, p3 = %#X\n", &p2, p3);
    printf("&p1 = %#X, p2 = %#X, *p3 = %#X\n", &p1, p2, *p3);
    printf(" &a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n", &a, p1, *p2, **p3);
    return 0;
}
```

编译并运行结果如下：
![这里写图片描述](http://img.blog.csdn.net/20160821215837967)

以三级指针 p3 为例来分析上面的代码。*** p3等价于 * ( * (* p3))。* p3 得到的是 p2 的值，也即 p1 的地址；* ( * p3) 得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后，* ( *(p3)) 得到的才是 a 的值。

假设 a、p1、p2、p3 的地址分别是 0X00A0、0X1000、0X2000、0X3000，它们之间的关系可以用下图来描述：

![这里写图片描述](http://img.blog.csdn.net/20160821220050579)

方框里面是变量本身的值，方框下面是变量的地址。

## **C中指针的运算** ##

指针变量保存的是地址，本质上是一个整数，可以进行部分运算，例如加法、减法、比较等，请看下面的代码：

```

#include <stdio.h>
//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式
void main(){
	//数组在内存中连续存储
	int ids[] = { 78, 90, 23, 65, 19 };
	//数组变量名：ids就是数组的首地址
	printf("%#x\n",ids);
	printf("%#x\n",&ids);
	printf("%#x\n",&ids[0]);
	//指针变量
	int *p = ids;
	printf("%d\n",*p);
	//指针的加法
	p++; //p++向前移动sizeof(数据类型)个字节
	printf("p的值:%#x\n", p);
	//p--;
	printf("%d\n", *p);
	getchar();
}
```

编译并运行的结果如下：

```
0x5ff7d0
0x5ff7d0
0x5ff7d0
78
p的值:0x5ff7d4
90

```

从上面的栗子来看，数组变量名：ids就是数组的首地址，指针的加法，p++就是向前移动了sizeof(数据类型)个字节。
我们知道，数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，不过C语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。

下面举一个栗子，通过指针获取下一个变量的地址：

```
#include <stdio.h>
int main(){
    int a = 1, b = 2, c = 3;
    int *p = &c;
    int i;
    for(i=0; i<8; i++){
        printf("%d, ", *(p+i) );
    }
    return 0;
}
```

编译并运行结果如下：

```
3, -858993460, -858993460, 2, -858993460, -858993460, 1, -858993460,
```

可以看出变量 a、b、c 并不挨着，它们中间还有其他的数据。

指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。
所以总结出，不要对指向普通变量的指针进行加减运算；另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。

## **C中的指针数组** ##

如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：

```
dataType *arrayName[length];
```
 ]的优先级高于*，该定义形式应该理解为：

```
dataType *(arrayName[length]);
```

括号里面说明arrayName是一个数组，包含了length个元素，括号外面说明每个元素的类型为dataType *。

除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的栗子：

```
#include <stdio.h>
int main(){
    int a = 16, b = 932, c = 100;
    //定义一个指针数组
    int *arr[3] = {&a, &b, &c};//也可以不指定长度，直接写作 int *parr[]
    //定义一个指向指针数组的指针
    int **parr = arr;
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);
    printf("%d, %d, %d\n", **(parr+0), **(parr+1), **(parr+2));
    return 0;
}
```

编译并运行结果如下：

```
16, 932, 100
16, 932, 100
```

arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。

parr 是指向数组 arr 的指针，确切地说是指向 arr 第一个元素的指针，它的定义形式应该理解为int * ( * parr)，括号中的 * 表示 parr 是一个指针，括号外面的int * 表示 parr 指向的数据的类型。arr 第一个元素的类型为 int *，
 所以在定义 parr 时要加两个 * （星号）（MD语法自动识别其他的格式了）。

第一个 printf() 语句中，arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。

第二个 printf() 语句中，parr+i 表示第 i 个元素的地址，* (parr+i) 表示获取第 i 个元素的值（该元素是一个指针），**(parr+i) 表示获取第 i 个元素指向的数据。

通过指针给数组赋值，下面是一个简单的栗子：

```
#include <stdio.h>
void main(){
	int uids[5];
	//高级写法
	//int i = 0;
	//for (; i < 5; i++){
	//	uids[i] = i;
	//}
	//早些版本的写法
	int* p = uids;
	printf("%#x\n",p);
	int i = 0; //i是数组元素的值
	for (; p < uids + 5; p++){
		*p = i;
		i++;
	}

	getchar();
}
```

## **C中的指针与二维数组** ##

二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：

```
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```
从概念上来理解，数组a 的分布如下：

```
0   1   2   3
4   5   6   7
8   9  10  11
```

但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：

![这里写图片描述](https://img-blog.csdn.net/20160821224606127)

C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。

C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0][0]、a[0][1]、a[0][2]、a[0][3]。

假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：
![这里写图片描述](https://img-blog.csdn.net/20160821224959492)

为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：

```
int (*p)[4] = a;
```
**int *p[4]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。**

**int (*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。**

```
区分int *p[n]; 和int (*p)[n]; 就要看运算符的优先级了。
int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。
int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。
```

对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。

下面我们就来实现如何使用指针 p 来访问二维数组中的每个元素。按照上面的定义：

* p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。
* *(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点：

```
#include <stdio.h>
int main(){
    int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
    int (*p)[4] = a;
    printf("%d\n", sizeof(*(p+1)));
    return 0;
}
```

编译并运行结果为：

```
16
```

  那么，*(p+1)+1表示第 1 行第 1 个元素的地址。这个如何理解呢？（注意，这里的小细节）

```
  *(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。

```

```
* ( *(p+1)+1) 表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。
```
根据上面的推论，推出以下等价关系：

```
a+i == p+i
a[i] == p[i] == *(a+i) == *(p+i)
a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
```
可能有点绕，不好理解，不过没关系，多看几遍，相信你是可以的。

栗子：
使用指针遍历二维数组
```
#include <stdio.h>
int main(){
    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
    int(*p)[4];
    int i,j;
    p=a;
    for(i=0; i<3; i++){
        for(j=0; j<4; j++) printf("%2d  ",*(*(p+i)+j));
        printf("\n");
    }
    return 0;
}
```
编译并运行的结果如下：

```
 0   1   2   3
 4   5   6   7
 8   9  10  11
```


**指针数组和二维数组指针的区别：**

指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：

```
int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
int (*p2)[5];  //二维数组指针，不能去掉括号
```

指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。

## **C中的函数指针** ##

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是**函数指针。**

**函数指针的定义形式为：**

```
returnType (*pointerName)(param list);
```
returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。

**注意：**
> ( )的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(paramlist);
> 就成了函数原型，它表明函数的返回值类型为returnType *。

下面写一个简单的栗子：

```
#include <stdio.h>
#include <Windows.h>

int msg(char* msg,char* title){
	MessageBox(0,msg,title,0);
	return 0;
}
void main(){
	//msg();
	printf("%#x\n",msg);
	printf("%#x\n",&msg);
	//函数指针
	//函数返回值类型，函数指针的名称，函数的参数列表
	int(*fun_p)(char* msg, char* title) = msg;
	fun_p("消息内容","标题");

	getchar();
}
```

编译并运行结果如下：

![这里写图片描述](http://img.blog.csdn.net/20160822141122306)

上面对msg函数进行了调用，fun_p是一个函数指针。

## **总结：** ##

指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。

常见的指针含义：

```
- int *p;	    p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。
- int **p;	    p 为二级指针，指向 int * 类型的数据。
- int *p[n];	p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);
- int (*p)[n];	p 为二维数组指针。
- int *p();	    p 是一个函数，它的返回值类型为 int *。
- int (*p)();	p 是一个函数指针，指向原型为 int func() 的函数。
```

以上就是通过学习对指针的概念的理解，不能再写了，不然又是长篇大论，很难让读者看完，（我也不喜欢）。

# CSDN
### 更多系列相关文章传送门：


- [C语言（一）基本数据类型](http://blog.csdn.net/u011974987/article/details/52138798) 
- [C语言（二）有符号数和无符号数的理解](http://blog.csdn.net/u011974987/article/details/52142794) 
- [C语言（三）字符串处理函数](http://blog.csdn.net/u011974987/article/details/52200178)
- [C语言（四）指针概念的理解](http://blog.csdn.net/u011974987/article/details/52270018)
- [C语言（五）内存的分配与释放](http://blog.csdn.net/u011974987/article/details/52290724)
- [C语言（六）结构体和联合体](http://blog.csdn.net/u011974987/article/details/52305364)
- [C语言（七）文件的相关操作](http://blog.csdn.net/u011974987/article/details/52354074)