---
layout: post
title: C 语言内存分配与释放（五）
permalink: c/memory_allocation
date: 2016-08-23 13:10:26
categories: C/C++
tags: C/C++
desc: 什么是堆？说到堆，又忍不住说到了栈！什么是 栈？
---

首先我们来科普一下：

**什么是堆？说到堆，又忍不住说到了栈！什么是 栈？**
------------------------

**1、什么是堆：**堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 

**2、什么是栈：**栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。  



## **C语言程序编译的内存分配，堆与栈的区别：**
 - 栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。   
   堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。再强调一次，记得要释放！
 - 栈区(stack) :
  	//windows下，栈内存分配2M（确定的常数），超出了限制，提示stack overflow错误
	//编译器自动分配释放，主要存放函数的参数值，局部变量值等；
 - 堆区(heap)：程序员手动分配释放，操作系统80%内存
	 
 - 全局区或静态区：存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区和全局未初始化区；
 - 字符常量区：常量字符串放与此，程序结束时由系统释放；
 
 - 程序代码区：存放函数体的二进制代码。
<!-- more --> 

栗子：

```
int a=0;        //全局初始化区
char *p1;       //全局未初始化区
void main()
{
   int b;          //栈
   char s[]="bb";  //栈
   char *p2;       //栈
   char *p3="123"; //其中，“123\0”常量区，p3在栈区
   static int c=0; //全局区
   p1=(char*)malloc(10);   //10个字节区域在堆区
   strcpy(p1,"123");    //"123\0"在常量区，编译器 可能 会优化为和p3的指向同一块区域
 
}
```

**栈内存**

```
void stackFun(){
	int a[1024];
	//栈内存自动释放
}
```

**堆内存**

```
void heapFun(){
	//40M内存
	//字节
	//void *任意类型的指针
	int* p = malloc(1024 * 1024 * 10 * sizeof(int));

	//释放
	free(p);
}
```

```
void main(){	
	//在堆内存上，分配40M的内存
	while (1){
		Sleep(1000);	
		stackFun();
	}

	getchar();
}
```


创建一个数组，动态指定数组的大小（在程序运行过长中，可以随意的开辟指定大小的内存，以供使用，相当于Java中的集合）
**静态内存分配**，分配内存大小的是固定，问题：1.很容易超出栈内存的最大值 2.为了防止内存不够用会开辟更多的内存，容易浪费内存


**动态内存分配**，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用（活水）

**函数：calloc()  分配内存空间并初始化**
calloc() 函数用来动态地分配内存空间并初始化为 0，其原型为：

```
  void* calloc (size_t num, size_t size);
```
  

calloc() 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。

【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。

**函数：malloc() 动态地分配内存空间**

malloc() 函数用来动态地分配内存空间（如果你不了解动态内存分配，请查看：C语言动态内存分配及变量存储类别），其原型为：

```
void* malloc (size_t size);
```


应用在程序中代码如下：
```
void main(){
	//静态内存分配创建数组，数组的大小是固定的
	//int i = 10;
	//int a[i];

	int len;
	printf("输入数组的长度：");
	scanf("%d",&len);

	//开辟内存，大小len*4字节
	int* p = malloc(len * sizeof(int));
	//p是数组的首地址，p就是数组的名称
	//给数组元素赋值（使用这一块刚刚开辟出来的内存区域）
	int i = 0;
	for (; i < len - 1; i++){
		p[i] = rand() % 100;
		printf("%d,%#x\n", p[i], &p[i]);
	}
	
	//手动释放内存 
	//free()释放动态分配的内存空间
	free(p);

	getchar();
}
```


**realloc 重新分配内存**

```
void main(){
	int len;
	printf("第一次输入数组的长度：");
	scanf("%d", &len);

	//int* p = malloc(len * sizeof(int));	
	int* p = calloc(len, sizeof(int));
	int i = 0;
	for (; i < len; i++){
		p[i] = rand() % 100;
		printf("%d,%#x\n", p[i], &p[i]);
	}

	int addLen;
	printf("输入数组增加的长度：");
	scanf("%d", &addLen);
	//内存不够用，扩大刚刚分配的内存空间
	//1.原来内存的指针 2.内存扩大之后的总大小		
	int* p2 = realloc(p, sizeof(int) * (len + addLen));
	if (p2 == NULL){
		printf("重新分配失败，世界那么大，容不下我。。。");
	}
```
	

## **新分配内存的两种情况：**

   //缩小，缩小的那一部分数据会丢失
	//扩大，（连续的）
	1.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针
	2.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据库释放掉，返回新的内存地址
	3.如果申请失败，返回NULL，原来的指针仍然有效
```
//接着上面的代码重新赋值
	i = 0;
	printf("--------------------------\n");
	for (; i < len + addLen; i++){
		p2[i] = rand() % 200;
		printf("%d,%#x\n", p2[i], &p2[i]);
	}

	//手动释放内存
	if (p != NULL){
		free(p);
		p = NULL;
	}	
	if (p2 != NULL){
		free(p2);
		p2 = NULL;
	}

	getchar();
}
```



## **内存分配的几个注意细节**
1.不能多次释放；
2.释放完之后（指针仍然有值），给指针置NULL，标志释放完成；
3.内存泄露（p重新赋值之后，再free，并没有真正释放内存）；

```
void main(){
	int len;
	printf("输入数组的长度：");
	scanf("%d", &len);

	int* p = malloc(len * sizeof(int));		
	int i = 0;
	for (; i < len; i++){
		p[i] = rand() % 100;
		printf("%d,%#x\n", p[i], &p[i]);
	}

	if (p != NULL){
		free(p);
		p = NULL;
	}

	getchar();
}
```
以上就是C语言中对内存的分配与释放，常用的几个函数~


# CSDN
### 更多系列相关文章传送门：


- [C语言（一）基本数据类型](http://blog.csdn.net/u011974987/article/details/52138798) 
- [C语言（二）有符号数和无符号数的理解](http://blog.csdn.net/u011974987/article/details/52142794) 
- [C语言（三）字符串处理函数](http://blog.csdn.net/u011974987/article/details/52200178)
- [C语言（四）指针概念的理解](http://blog.csdn.net/u011974987/article/details/52270018)
- [C语言（五）内存的分配与释放](http://blog.csdn.net/u011974987/article/details/52290724)
- [C语言（六）结构体和联合体](http://blog.csdn.net/u011974987/article/details/52305364)
- [C语言（七）文件的相关操作](http://blog.csdn.net/u011974987/article/details/52354074)

