<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XUHAO’S 博客</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 24 Aug 2018 23:36:56 +0800</pubDate>
    <lastBuildDate>Fri, 24 Aug 2018 23:36:56 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>基于Kotlin+Mvp+RxJava+Retrofit架构开发的短视频APP</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#kotlinmvp&quot; id=&quot;markdown-toc-kotlinmvp&quot;&gt;KotlinMvp&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#项目截图&quot; id=&quot;markdown-toc-项目截图&quot;&gt;项目截图&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#下载体验&quot; id=&quot;markdown-toc-下载体验&quot;&gt;下载体验&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#技术要点&quot; id=&quot;markdown-toc-技术要点&quot;&gt;技术要点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#更新日志&quot; id=&quot;markdown-toc-更新日志&quot;&gt;更新日志&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#关于我&quot; id=&quot;markdown-toc-关于我&quot;&gt;关于我&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#thanks&quot; id=&quot;markdown-toc-thanks&quot;&gt;Thanks&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#声明&quot; id=&quot;markdown-toc-声明&quot;&gt;声明&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#license&quot; id=&quot;markdown-toc-license&quot;&gt;LICENSE&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;kotlinmvp&quot;&gt;KotlinMvp&lt;/h1&gt;

&lt;a href=&quot;http://xuhaoblog.com&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/QQ-504105930-blue.svg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;

&lt;img src=&quot;http://oyp2zrwnm.bkt.clouddn.com/ic_launcher.png&quot; alt=&quot;这里写图片描述&quot; /&gt;

GitHub地址：&lt;a href=&quot;https://github.com/git-xuhao/KotlinMvp&quot;&gt;https://github.com/git-xuhao/KotlinMvp&lt;/a&gt;

（开源不易，如果喜欢的话希望给个 Star 或者 Fork，谢谢！）

《KotlinMvp》 是仿着“开眼Eyepetizer”之前版本并加上自己的想法，开发的一款的短视频小应用，每日为你推荐精选视频，让你大开眼界。本项目采用 Kotlin 语言编写，结合 MVP+RxJava2+Retrofit2+Glide等的架构设计，学习 Kotlin 利用空余时间开发的一款小项目，代码结构清晰有详细注释，如有任何疑问和建议请提 Issue或联系&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Gmail:-igeekho@gmail.com-blue.svg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;

&lt;h2 id=&quot;项目截图&quot;&gt;项目截图&lt;/h2&gt;

&lt;img src=&quot;http://oyp2zrwnm.bkt.clouddn.com/pt2017_12_09_10_27_10.jpg&quot; alt=&quot;&quot; /&gt;

&lt;ul&gt;
  &lt;li&gt;
    gif

    &lt;img src=&quot;http://oyp2zrwnm.bkt.clouddn.com/kotlin-mvp-1.gif&quot; /&gt;
    &lt;h2 id=&quot;下载体验&quot;&gt;下载体验&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

点击&lt;a href=&quot;https://fir.im/kotlinmvp&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Download-apk-green.svg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; 或者扫描下方二维码

&lt;img src=&quot;http://oyp2zrwnm.bkt.clouddn.com/QR-code-kotlin-mvp.png&quot; /&gt;

&lt;h2 id=&quot;技术要点&quot;&gt;技术要点&lt;/h2&gt;
主要使用的第三方开源框架有：

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot;&gt;RxAndroid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/square/retrofit&quot;&gt;Retrofit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bumptech/glide&quot;&gt;Glide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/orhanobut/logger&quot;&gt;Logger&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/H07000223/FlycoTabLayout&quot;&gt;FlycoTabLayout&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/google/flexbox-layout&quot;&gt;Flexbox-layout&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mmin18/RealtimeBlurView&quot;&gt;RealtimeBlurView&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/scwang90/SmartRefreshLayout&quot;&gt;SmartRefreshLayout&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bingoogolapple/BGABanner-Android&quot;&gt;BGABanner-Android&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/CarGuo/GSYVideoPlayer&quot;&gt;GSYVideoPlayer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

模块说明：

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;每日精选：&lt;/strong&gt;首页采用下拉刷新+RecyclerView 实现，Banner展示每日精选推荐的视频，监听 RecyclerView 的滑动事件，实现 TitleBar 的隐藏显示功能，底部菜单采用高斯模糊的半透明效果，使整个 APP 风格更加清爽。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;发现：&lt;/strong&gt; 包括关注和分类模块，关注是推荐的作者上传的视频，分类包括时尚、运动、创意、广告、音乐、旅行、生活、记录、开胃、游戏、萌宠、动画、综艺、搞笑等可自由选择想查看的类型视频。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;热门：&lt;/strong&gt; 热门排行榜包括周排行、月排行、总排行的视频列表。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;搜索：&lt;/strong&gt; 根据关键字搜索榜你找到感兴趣的视频。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;我的：&lt;/strong&gt; 个人主页的相关介绍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新日志&quot;&gt;更新日志&lt;/h2&gt;

&lt;strong&gt;v1.0&lt;/strong&gt;

&lt;ul&gt;
  &lt;li&gt;初始化版本，主要功能已经完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;关于我&quot;&gt;关于我&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Email: igeekho@gmail.com&lt;/li&gt;
  &lt;li&gt;Home: &lt;a href=&quot;https://xuhaoblog.com&quot;&gt;https://xuhaoblog.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;CSDN:&lt;a href=&quot;http://blog.csdn.net/u011974987&quot;&gt;http://blog.csdn.net/u011974987&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;简书: &lt;a href=&quot;http://www.jianshu.com/u/25bc3e1e7595&quot;&gt;http://www.jianshu.com/u/25bc3e1e7595&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;thanks&quot;&gt;Thanks&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;感谢所有优秀的开源项目&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kaikaixue/Eyepetizer&quot;&gt;Eyepetizer&lt;/a&gt; ：最初是看了这个项目才开始做的，学了不少东西，写出了我自己的代码风格&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;strong&gt;项目中的 API 均来自开眼视频，纯属学习交流使用，不得用于商业用途！&lt;/strong&gt;

&lt;h2 id=&quot;license&quot;&gt;LICENSE&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Copyright 2017 Xiho

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 25 Dec 2017 01:15:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/25/kotlin-mvp/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/25/kotlin-mvp/</guid>
        
        <category>kotlin</category>
        
        <category>mvp</category>
        
        
        <category>开源项目</category>
        
      </item>
    
      <item>
        <title>Android-L SIM卡自适应更新语言问题</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
每次到发布UAT和Release 版本的时候，不同的组件总是出现各种问题，在测试中版本中就没有测试出来，就在今天发布Global（海外）版的时候遇到了一个之前并没发现的问题，就是刷机的rom版本是Global版的，默认的系统语言是英文版的。刚刷完机，插上中国区域的SIM 卡，第一次开机时候，语言自动切换到中文了，由于之前也没这方面经验，对这并不清楚，然后就当BUG 让我修改，后来在网上查了下资料，才了解MTK平台 确实有这么回事，Mark一下~详情如下：

&lt;hr /&gt;
&lt;!-- more --&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;一系统设定默认语言规则&quot;&gt;一、系统设定默认语言规则&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    系统预置语言，即在 makefile 文件中定义的语言；

    位置：&lt;code class=&quot;highlighter-rouge&quot;&gt;mediatek/config/${Project}/ProjectConfig.mk&lt;/code&gt;，默认第一个是系统默认语言；
  &lt;/li&gt;
  &lt;li&gt;
    刷机过后，开机重启，如果未插卡，系统语言为预置的语言；
  &lt;/li&gt;
  &lt;li&gt;
    插入SIM卡过后，系统语言根据 SIM 卡来改变， 默认会把刷机过后第一次插的 SIM 卡的语言设置为默认语言；(如果sim的mcc可以在内置的mcc表中找到)；
  &lt;/li&gt;
  &lt;li&gt;
    如果用户没有手动在 Settings 里面设置语言，以后系统语言一直是默认语言（第一次插的 SIM 卡的语言），即使是插入其它国家的卡，系统语言也不会变；
  &lt;/li&gt;
  &lt;li&gt;
    如果用户在 Settings 里面手动设置了语言，以后系统语言会为设置后的语言，无论插入什么卡，系统语言不会变，一直为用户手动设置后的语言。
  &lt;/li&gt;
&lt;/ol&gt;
&amp;lt;font color=red size=3&amp;gt;MTK默认设计是如果手机有插卡，那么在开机是会读取SIM的imsi取出mcc，然后通过mcc来查找对应的language，并设置为手机默认语言&amp;lt;/font&amp;gt;
&lt;strong&gt;(相关文件MccTable.javaframeworks\opt\telephony\src\java\com\android\internal\telephony).&lt;/strong&gt;

&lt;h3 id=&quot;二修改默认语言&quot;&gt;二、修改默认语言&lt;/h3&gt;

1、 如果想手机默认语言不随SIM的MCC走，请按照如下修改：

在&lt;strong&gt;setLocaleFromMccIfNeeded()&lt;/strong&gt;函数中

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//String language = MccTable.defaultLanguageForMcc(mcc);      //注释掉此语句
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

对于&lt;strong&gt;KK&lt;/strong&gt;版本,在&lt;strong&gt;updateMccMncConfiguration()&lt;/strong&gt;函数中

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // locale = getLocaleFromMcc(context, mcc);         //注释掉此语句
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
2、 如果手机默认语言随SIM卡走

此为operator CT的定制feature，如果有开OP03 option,默认就支持该功能。

如果想非OP03也支持该功能，请按照如下修改:

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   alps/mediatek/frameworks/base/op/java/com/mediatek/op/telephony/TelephonyExt.java中, 使方法isSetLanguangBySIM()返回true，那么手机的默认语言会使用SIM中的EF_LI(6F05)或者EF_EPL(2F05)中的语言。这两个文件优先使用EF_LI中的，如果EF_LI没有匹配的在使用EF_EPL的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;strong&gt;如何打开一种新语言？&lt;/strong&gt;

&lt;strong&gt;如何设置开机默认语言?&lt;/strong&gt;

3、取消sim卡语言自适应

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void updateMccMncConfiguration(Context context, String mccmnc)
MccTable.java(frameworks\base\telephony\java\com\Android\internal\telephony)
if (mcc != 0) {
                setTimezoneFromMccIfNeeded(context, mcc);
                setLocaleFromMccIfNeeded(context, mcc);
                setWifiCountryCodeFromMcc(context, mcc);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

每次插卡开机，当sim准备好之后，系统会走&lt;code class=&quot;highlighter-rouge&quot;&gt;updateMccMncConfiguration&lt;/code&gt;这个函数，其调用这个setLocaleFromMccIfNeeded函数去根据mcc更新系统语言，可以设置是否&amp;lt;font color=red&amp;gt;调用这个函数来决定是否根据sim切换语言。&amp;lt;/font&amp;gt;

4、要求每次均可以根据sim卡切换语言

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void setSystemLocale(Context context, String language, String country)
……
config.userSetLocale = false;
config.simSetLocale = true;
……
 am.updateConfiguration(config);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

第一次开机插入sim卡，如果根据mcc找到相应语言，系统会把当前sim卡语言信息保存起来，以后系统无论插入任何语言的sim卡，系统语言均不会在根据sim在进行切换，其中系统是根据&amp;lt;font color=red&amp;gt;simSetLocale这个参数来决定是否要保存这个信息的，如果在上面把其设为false，则可以实现每次插卡均可自适应(除手动设置语言外)。&amp;lt;/font&amp;gt;

这是从网上了解到的资料，讲道理，这并不是我的问题，~~&lt;del&gt;(&amp;gt;_&amp;lt;)&lt;/del&gt;~~，设计如此~

</description>
        <pubDate>Tue, 01 Nov 2016 08:42:31 +0800</pubDate>
        <link>http://localhost:4000/android-sim</link>
        <guid isPermaLink="true">http://localhost:4000/android-sim</guid>
        
        <category>Android</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Git 本地提交未Push 自动切到其他版本的解决姿势</title>
        <description>&lt;h3 id=&quot;现象描述&quot;&gt;&lt;strong&gt;现象描述：&lt;/strong&gt;&lt;/h3&gt;

我在现有的分支上进行修改代码，使用git提交本地代码后，SourceTree上面没有记录，我就纳闷了，我原本以为我提交到其他项目了，仔细查看了几个项目的提交记录也都没有，于是退出SourceTree，在打开这个项目还是没记录，并且最新修改的分支在两个版本之前的Develop v2.2.2分支（这个我记得我是在最新的分支上开发的，不排除我在其他分支上进行开发的情况），不过这个都不是事儿，怎么恢复修改的代码到最新的分支上面呢？下面提供解决方案~~

&lt;h3 id=&quot;解决方案&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;打开&lt;strong&gt;gitbash&lt;/strong&gt; 命令行；&lt;/li&gt;
  &lt;li&gt;输出&lt;strong&gt;git log&lt;/strong&gt; 查看不到提交历史的历史记录；&lt;/li&gt;
  &lt;li&gt;输入&lt;strong&gt;git reflog&lt;/strong&gt;可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。&lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;https://img-blog.csdn.net/20161024172334515&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;strong&gt;上面红色箭头指的地方就查看不到记录。&lt;/strong&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
  &lt;li&gt;（上面已经说明了,当前最新提交的分支在v2.2.2上）然后我们要恢复5d3c053 这个分支到v2.2.4上面，那我们就要使用&lt;strong&gt;git cherry&lt;/strong&gt;了。&lt;/li&gt;
  &lt;li&gt;使用 cherry-pick.  根据git 文档：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Apply the changes introduced by some existing commits 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

就是对已经存在的commit 进行apply (可以理解为再次提交）

简单用法：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git cherry-pick &amp;lt;commit id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

例如：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  git checkout old_cc
$  git cherry-pick 67fbeee# 这个 67fbeee号码，位于：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Commit: 67fbeee108798cf43895db16cdcf91c2b1d5298d [67fbeee]
Parents: fa10c134b8
Author: xuhao &amp;lt;504105930@qq.com&amp;gt;
Date: 2016年10月21日 18:27:14
Labels: tag:, v2.2.3
更改版本号，解决发布问题标题问题

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

如上图：
由于adb install 这个记录可能在v2.2.2分支提交的，现在要把这个分支提交到v2.2.4分支上；

结果如下：

&lt;img src=&quot;https://img-blog.csdn.net/20161024175356461&quot; alt=&quot;这里写图片描述&quot; /&gt;，

最后之前丢失的那条记录也出来了，成功的解决了~~，sourceTree记录图如下：

&lt;img src=&quot;https://img-blog.csdn.net/20161024175647103&quot; alt=&quot;这里写图片描述&quot; /&gt;

总结：不管用什么工具，只有熟练掌握了命令才是王道啊~

&lt;blockquote&gt;
  本文由博主辛苦整理下来的笔记； 
希望大家能够指点或提出宝贵意见，共同学习，谢谢！ 
转载请注明出处：&lt;a href=&quot;http://xuhaoblog.com/git/not_push.html&quot;&gt;http://xuhaoblog.com/git/not_push.html&lt;/a&gt;
欢迎关注我的社交网站~
个人博客：&lt;a href=&quot;http://xuhaoblog.com&quot;&gt;xuhaoblog.com&lt;/a&gt;
新浪微博：&lt;a href=&quot;http://weibo.com/xuxiho&quot;&gt;http://weibo.com/xuxiho&lt;/a&gt;
github：&lt;a href=&quot;https://github.com/git-xuhao&quot;&gt;https://github.com/git-xuhao&lt;/a&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 25 Oct 2016 02:05:00 +0800</pubDate>
        <link>http://localhost:4000/git-not_push</link>
        <guid isPermaLink="true">http://localhost:4000/git-not_push</guid>
        
        <category>Git</category>
        
        
        <category>GitHub</category>
        
      </item>
    
      <item>
        <title>Android 中取得当前时区（以GMT形式）和语言</title>
        <description>国际化需求，要访问当地的时区和语言，作为参数上传服务器处理一些业务，Android手机中如果想以GMT形式（GMT+08:00）得到当前时区，如下的工具类做个记录：
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
/**
 * 时区语言工具类
 * @author Xiho
 *
 */
public class I18NUtils {

	/**
	 * 获取当前时区
	 * @return
	 */
	public static String getCurrentTimeZone() {
		TimeZone tz = TimeZone.getDefault();
		String strTz = tz.getDisplayName(false, TimeZone.SHORT);
		return strTz;

	}
	
	
	/**
	 * 获取当前系统语言格式
	 * @param mContext
	 * @return
	 */
	public static String getCurrentLanguage(Context mContext){
	    Locale locale =mContext.getResources().getConfiguration().locale;
        String language=locale.getLanguage();
        String country = locale.getCountry();
        String lc=language+&quot;_&quot;+country;
        return lc;
	}
	

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;!-- more --&gt;
</description>
        <pubDate>Fri, 21 Oct 2016 02:05:00 +0800</pubDate>
        <link>http://localhost:4000/Android-getdate-language</link>
        <guid isPermaLink="true">http://localhost:4000/Android-getdate-language</guid>
        
        <category>Android</category>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Android NDK 开发AndroidStudio 2.2 更友好的支持NDK（五）</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，觉得还挺好用的，Eclipse 是一个吃内存的IDE，反正我每次打开，编写代码的时候就会卡，有时候还是死掉，已无力吐糟~~，AndroidStudio的界面更人性化，除此之外，还有更多的功能。所以决定把之前在正在eclipse上开发的一个使用NDK开发的android项目转移到AndroidStudio上，在2.2之前对C/C++ 支持不是很友好，没有语法提示，编译也不方便等问题，所以期待了的Android Studio 2.2 版本稳定版终于在前段发布，一直未来得及尝试，今天把整个过程记下来，希望能给你有所帮助。

参考文献：https://developer.android.com/studio/projects/add-native-code.html#create-sources

&lt;hr /&gt;

&lt;!-- more --&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;1-下载开发工具和ndkwindows10-64位环境&quot;&gt;&lt;strong&gt;1. 下载开发工具和NDK（windows10 64位环境）&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  Android Studio 2.2 的NDK开发支持 CMake和ndk-build两种方式，默认的是CMake编译的，编译和调试需要下载安装以下组件：
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;strong&gt;AndroidStudio&lt;/strong&gt; 官网下载地址：

    &lt;a href=&quot;https://developer.android.com/studio/index.html#win-bundle&quot;&gt; Android Studio 2.2 &lt;/a&gt;（需要梯子）
  &lt;/li&gt;
&lt;/ul&gt;

推荐一个国内的镜像网站：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[http://www.androiddevtools.cn](http://www.androiddevtools.cn/) （身为开发者都应该知道，O(∩_∩)O）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

下载最新版的 &lt;strong&gt;Android Studio 2.2&lt;/strong&gt; ：

&lt;a href=&quot;https://dl.google.com/dl/android/studio/install/2.2.2.0/android-studio-bundle-145.3360264-windows.exe&quot;&gt;Download （点击下载） &lt;/a&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;strong&gt;下载NDK：&lt;/strong&gt;&lt;a href=&quot;https://dl.google.com/android/repository/android-ndk-r12b-windows-x86_64.zip&quot;&gt;android-ndk-r12b-windows-x86_64&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CMake：&lt;/strong&gt; Android Studio 默认使用 CMake 编译原生库，如果你只打算用ndk-build来编译的话，你就不需要这个组件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LLDB：&lt;/strong&gt; 使用它来调试本地代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;strong&gt;注意：&lt;/strong&gt;要在 Android Studio 中使用 CMake 或者 ndk-build，你需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。
&lt;/blockquote&gt;

&lt;strong&gt;你可以使用 SDK Manager 来安装上述组件：&lt;/strong&gt;

&lt;ol&gt;
  &lt;li&gt;
    已安装的软件包如有更新，其旁边的复选框中会显示短划线 &lt;img src=&quot;https://img-blog.csdn.net/20161025113813489&quot; alt=&quot;这里写图片描述&quot; /&gt;
  &lt;/li&gt;
  &lt;li&gt;
    打开一个项目，从菜单栏中选择 &lt;strong&gt;Tools &amp;gt; Android &amp;gt; SDK Manager&lt;/strong&gt; 。
  &lt;/li&gt;
  &lt;li&gt;
    点击 &lt;strong&gt;SDK Tools&lt;/strong&gt; 选项卡。
  &lt;/li&gt;
  &lt;li&gt;
    勾选 &lt;strong&gt;LLDB&lt;/strong&gt;，&lt;strong&gt;CMake&lt;/strong&gt; 和 &lt;strong&gt;NDK&lt;/strong&gt; 。如图一：
  &lt;/li&gt;
&lt;/ol&gt;

&lt;img src=&quot;https://img-blog.csdn.net/20161025115020495&quot; alt=&quot;这里写图片描述&quot; /&gt;

点击 Apply ，然后点击 OK 。

当安装完成后，点击 Finish ，然后点击 OK 。

&lt;hr /&gt;

&lt;h3 id=&quot;创建支持native-code新项目&quot;&gt;&lt;strong&gt;创建支持Native Code新项目&lt;/strong&gt;&lt;/h3&gt;

创建一个支持 native code 的项目和创建普通的 Android studio 工程很像。但是有几点需要留意的地方：

&lt;ol&gt;
  &lt;li&gt;
    在 Configure your new project 选项中，勾选 Include C++ Support 选项。
  &lt;/li&gt;
  &lt;li&gt;
    点击 Next，后面的流程和创建普通的 Android studio 工程一样。
  &lt;/li&gt;
  &lt;li&gt;
    在 Customize C++ Support 选项卡中。你有下面几种方式来自定义你的项目：
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    C++ Standard ：点击下拉框，可以选择标准 C++，或者选择默认 CMake 设置的 Toolchain Default 选项。
  &lt;/li&gt;
  &lt;li&gt;
    Exceptions Support ：如果你想使用有关 C++ 异常处理的支持，就勾选它。勾选之后，Android Studio 会在 module 层的 build.gradle 文件中的 cppFlags 中添加 -fexcetions 标志。
  &lt;/li&gt;
  &lt;li&gt;
    Runtime Type Information Support ：如果你想支持 RTTI，那么就勾选它。勾选之后，Android Studio 会在 module 层的 build.gradle 文件中的 cppFlags 中添加 -frtti 标志。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;点击 “Finish”。&lt;/li&gt;
&lt;/ol&gt;

当 Android Studio 完成新项目创建后，打开 Project 面板，选择 Android 视图。Android Studio 会添加 cpp 和 External Build Files 文件夹。

&lt;img src=&quot;https://img-blog.csdn.net/20161025120041509&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;strong&gt;cpp&lt;/strong&gt; 文件夹存放你所有 native code 的地方，包括源码，头文件，预编译项目等。对于新项目，Android Studio 创建了一个 C++ 模板文件： &lt;strong&gt;native-lib.cpp&lt;/strong&gt; ，并且将该文件放到了你的 app 模块的 &lt;strong&gt;src/main/cpp/&lt;/strong&gt; 目录下。这份模板代码提供了一个简答的 C++ 函数： &lt;strong&gt;stringFromJNI()&lt;/strong&gt; ，该函数返回一个字符串：&lt;strong&gt;”Hello from C++”&lt;/strong&gt;。
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;External Build Files&lt;/strong&gt; 文件夹是存放 &lt;strong&gt;CMake&lt;/strong&gt; 或 &lt;strong&gt;ndk-build&lt;/strong&gt; 构建脚本的地方。有点类似于 build.gradle 文件告诉 Gradle 如何编译你的 APP 一样，CMake 和 ndk-build 也需要一个脚本来告知如何编译你的 native library。对于一个新的项目，Android Studio 创建了一个 CMake 脚本： &lt;strong&gt;CMakeLists.txt&lt;/strong&gt; ，并且将其放到了你的 module 的根目录下。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;编译运行示例-app&quot;&gt;&lt;strong&gt;编译运行示例 APP&lt;/strong&gt;&lt;/h3&gt;
当你点击 Run 按钮，Android Studio 会编译并启动一个 APP ，然后在 APP 中显示一段文字”Hello from C++”。

&lt;img src=&quot;https://img-blog.csdn.net/20161025120804299&quot; alt=&quot;这里写图片描述&quot; /&gt;

从编译到运行示例 APP 的流程简单归纳如下：

&lt;ol&gt;
  &lt;li&gt;
    Gradle 调用外部构建脚本，也就是 CMakeLists.txt 。
  &lt;/li&gt;
  &lt;li&gt;
    CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是 native-lib.cpp ，并将编译后的产物扔进共享对象库中，并将其命名为 libnative-lib.so ，然后 Gradle 将其打包到 APK 中。
  &lt;/li&gt;
  &lt;li&gt;
    在运行期间，APP 的 MainActivity 会调用 System.loadLibrary() 方法，加载 native library。而这个库的原生函数， stringFromJNI() ，就可以为 APP 所用了。
  &lt;/li&gt;
  &lt;li&gt;
    MainActivity.onCreate() 方法会调用 stringFromJNI() ，然后返回 “Hello from C++”，并更新 TextView 的显示。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  注意： Instant Run 并不兼容使用了 native code 的项目。Android Studio 会自动禁止 Instant
Run 功能。
&lt;/blockquote&gt;

如果你想验证一下 Gradle 是否将 native library 在APK中是否存在，你可以使用 &lt;strong&gt;APK Analyzer&lt;/strong&gt;:

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 选择 Build &amp;gt; Analyze APK 。
2. 从 app/build/outputs/apk/ 路径中选择 APK，并点击 OK 。
3. 如下图，在 APK Analyzer 窗口中，选择 lib/&amp;lt;ABI&amp;gt;/ ，你就可以看见 libnative-lib.so 。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;img src=&quot;http://img-blog.csdn.net/20161025122320133&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;将-cc-代码添加到现有的项目中&quot;&gt;&lt;strong&gt;将 C/C++ 代码添加到现有的项目中&lt;/strong&gt;&lt;/h3&gt;

如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤：

&lt;ol&gt;
  &lt;li&gt;
    创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。
  &lt;/li&gt;
  &lt;li&gt;
    创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。
  &lt;/li&gt;
  &lt;li&gt;
    将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。
  &lt;/li&gt;
&lt;/ol&gt;

一旦你配置好了你的项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击 Run 按钮，就可以编译运行你的 APP 了。

&lt;hr /&gt;

&lt;h3 id=&quot;创建新的-native-source-文件&quot;&gt;&lt;strong&gt;创建新的 native source 文件&lt;/strong&gt;&lt;/h3&gt;

请按照下面的方法来创建一个 cpp/ 文件夹和源文件（native source files）：

&lt;ol&gt;
  &lt;li&gt;
    打开IDE左边的 Project 面板，选择 Project 视图。
  &lt;/li&gt;
  &lt;li&gt;
    找到你项目的 module &amp;gt; src 目录，右键点击 main 文件夹，选择 New &amp;gt; Directory 。
  &lt;/li&gt;
  &lt;li&gt;
    输入文件夹的名字（比如 cpp），然后点击 OK 。
  &lt;/li&gt;
  &lt;li&gt;
    右键点击刚才创建好的文件夹，选择 New &amp;gt; C/C++ Source File 。
  &lt;/li&gt;
  &lt;li&gt;
    输入文件名，比如 native-lib 。
  &lt;/li&gt;
  &lt;li&gt;
    在 Type 菜单下拉选项中，选择源文件的扩展后缀名，比如 .cpp 。
  &lt;/li&gt;
  &lt;li&gt;
    如果你也想创建一个头文件，点击 Create an associated header 选项框。
  &lt;/li&gt;
  &lt;li&gt;
    点击 OK 。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;创建-cmake-构建脚本&quot;&gt;&lt;strong&gt;创建 CMake 构建脚本&lt;/strong&gt;&lt;/h3&gt;

如果没有一个 CMake 构建脚本，你需要自己手动创建一个，并添加一些合适的 CMake 命令。CMake 构建脚本是一个空白的文本文档（后缀为 .txt 的文件），名字必须为 CMakeLists.txt 。

&lt;blockquote&gt;
  &lt;strong&gt;注意：&lt;/strong&gt;如果你的项目使用了 ndk-build，你就不需要创建 CMake 构建脚本，只需要提供一个路径链，将你的 Android.mk
文件链接到 Gradle 中即可。
&lt;/blockquote&gt;

将一个空白的文本文档变成一个 CMake 构建脚本，你需要这么做：

&lt;ol&gt;
  &lt;li&gt;
    打开 IDE 左边的 Project 面板，选择 Project 视图。
  &lt;/li&gt;
  &lt;li&gt;
    在你的 module 根目录下，右键，选择 New &amp;gt; File 。
  &lt;/li&gt;
  &lt;li&gt;
    输入 “CMakeLists.txt” 作为文件名，并点击 OK 。
  &lt;/li&gt;
&lt;/ol&gt;

现在，你可以添加 CMake 命令来配置你的构建脚本了。为了让 CMake 将源代码（native source code）编译成 native library。需要在编译文件中添加 &lt;strong&gt;cmake_minimum_required()&lt;/strong&gt; 和 &lt;strong&gt;add_library()&lt;/strong&gt; 命令：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 设置建立你的本地库所需的CMake的最低版本。
# 这为了确保某些功能在你构建的时候是可用的。

cmake_minimum_required(VERSION 3.4.1)

# 指定库名
# 并提供源代码的相对路径. 
# 你可以通过add.library()命令定义多个库,CMake会去构建他们，
# 当你构建App 的时候，Gradle 会自动把库打包到你的apk 中

add_library( # Specifies the name of the library.
             native-lib

            # Sets the library as a shared library.
             SHARED

            # Provides a relative path to your source file(s).
            src/main/cpp/native-lib.cpp )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

当你使用 &lt;strong&gt;add_library()&lt;/strong&gt; ，将一个源文件（source file）或库添加到你的 CMake 构建脚本，同步你的项目，然后你会发现 Android studio 将关联的头文件也显示了处理。然而，为了让 CMake 在编译时期能定位到你的头文件，你需要在 CMake 构建脚本中添加 &lt;strong&gt;include_directories()&lt;/strong&gt; 命令，并指定头文件路径：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_library(...)

# Specifies a path to native header files.
include_directories(src/main/cpp/include/)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

CMake的使用命名库的文件的约定下面的形式：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lib*library-name*.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

例如 ，如果你在构建脚本中，将 library 命名为 “native-lib”，那么 CMake 会创建叫 libnative-lib.so 的文件。但是，当你将 library 加载到 Java 代码中的时候， 你需要使用在 CMake 中指定的名称：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static {
        System.loadLibrary(“native-lib”);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;strong&gt;注意：&lt;/strong&gt;如果你将 CMake 脚本里面的 library 重命名了，或者移除了。你需要清理一下你的工程。在 IDE 的菜单栏中选择 Build &amp;gt; Clean Project 。
&lt;/blockquote&gt;

Android Studio 会在 Project 面板中的 cpp 文件夹中自动添加源文件和头文件。你可以多次使用 add_library() 命令，来添加额外的 library。

&lt;h4 id=&quot;添加-ndk-apis&quot;&gt;&lt;strong&gt;添加 NDK APIs&lt;/strong&gt;&lt;/h4&gt;

Android NDK 提供了一些有用的 native APIs。将 NDK librarys 添加到 CMakeLists.txt 脚本文件中，就可以使用这些 API 了。

预编译的 NDK librarys 已经存在在 Android 平台中了，所以你不需要编译它们，或者是将其打包到你的 APK 中。因为这些 NDK librarys 已经是 CMake 搜索路径的一部分，你甚至不需要提供你本地安装的 NDK 路径。你只需要向 CMake 提供你想使用的 library 名字。

将 &lt;strong&gt;find_library()&lt;/strong&gt; 命令添加到你的 CMake 构建脚本中，这样就可以定位 NDK library 的位置，并将其位置存储在一个变量之中。你可以在构建脚本的其他地方使用这个变量，来代指 NDK library。下面的示例代码将 Android-specific log support library 的位置存储到变量 log-lib 中：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find_library( # Defines the name of the path variable that stores the
              # location of the NDK library.
              log-lib

              # Specifies the name of the NDK library that
              # CMake needs to locate.
              log )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

NDK 同样也包含一些只包含源码的 library，这些就需要你去编译，然后链接到你的本地库（native library）。你可以在 CMake 构建脚本中使用 add_library() 命令将源码编译进本地库。这时就需要提供你的本地 NDK 安装路径，通常将该路径保存在 ANDROID_NDK 变量中，这样 Android Studio 可以自动为你定义。

下面的命令告诉 CMake 去构建 android_native_app_glue.c ，这个命令可以管理 NativeActivity 的生命周期以及点击输入，并将其导入静态库中，然后将其链接至 native-lib ：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_library( app-glue
             STATIC
             ${ANDROID_NDK}/sources/android/native_app_glue/android_native_app_glue.c )

# You need to link static libraries against your shared native library.
target_link_libraries( native-lib app-glue ${log-lib} )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;添加其他的预编译库&quot;&gt;&lt;strong&gt;添加其他的预编译库&lt;/strong&gt;&lt;/h4&gt;

添加预编译库和添加本地库（native library）类似。由于预编译库是已经构建好的，你想就要使用 IMPORTED 标志去告诉 CMake ，你只需要将其导入到你的项目中即可：

add_library( imported-lib
             SHARED
             IMPORTED )
然后你需要使用 set_target_properties() 命令去指定库的路径，就像下面的代码那样。

一些库会根据不同的 CPU 使用不同的包，或者是 Application Binary Interfaces(ABI) ，并且将他们归类到不同的目录中。这样做的好处是，可以充分发挥特定的 CPU 架构。你可以使用 ANDROID_ABI 路径变量，将多个 ABI 版本的库添加到你的 CMake 构建脚本中。这个变量使用了一些 NDK 默认支持的 ABI，以及一些需要手动配置到 Gradle 的 ABI，比如：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add_library(...)
set_target_properties( ＃指定目标库。
                       imported-lib

                       ＃指定要定义的参数。
                       PROPERTIES IMPORTED_LOCATION

                       ＃提供的路径，你要导入的库。
                       imported-lib/src/${ANDROID_ABI}/libimported-lib.so )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

为了让 CMake 在编译时期能找到你的头文件，你需要使用 include_directories() 命令，并且将你的头文件地址传进去：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;include_directories( imported-lib/include/ )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

在 CMake 构建脚本中使用 target_link_libraries() 命令，将预构建库与你本地库相关联：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target_link_libraries( native-lib imported-lib app-glue ${log-lib} )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

当你构建你的 APP 的时候，Gradle 会自动将导入的库打包到你的 APK 中。你可以使用 &lt;strong&gt;APK Analyzer&lt;/strong&gt; 来检查。有关CMake的命令的详细信息，请参阅&lt;a href=&quot;https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html&quot;&gt;CMake的文档。&lt;/a&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;关联本地库与-gradle&quot;&gt;&lt;strong&gt;关联本地库与 Gradle&lt;/strong&gt;&lt;/h3&gt;

为了将本地库与 Gradle 相关联，你需要在 CMake 或 ndk-build 构建脚本中提供一个路径地址。当你构建你的 APP 时，Gradle 会将 CMake 或 ndk-build 作为一个依赖运行，然后将共享库（.so 文件）打包到你的 APK 中。Gradle 同样使用构建脚本来识别哪些文件需要导入到 Android Studio 项目，你可以从 Project 窗口面板中看到相应的文件。如果你还没有一个为 native sources 准备的构建脚本，你需要先创建一个&lt;a href=&quot;http://blog.csdn.net/u011974987/article/details/52888864#t7&quot;&gt;CMake脚本&lt;/a&gt;，然后在继续。

</description>
        <pubDate>Wed, 19 Oct 2016 19:42:00 +0800</pubDate>
        <link>http://localhost:4000/ndk-jni-5</link>
        <guid isPermaLink="true">http://localhost:4000/ndk-jni-5</guid>
        
        <category>ndk</category>
        
        
        <category>NDK</category>
        
      </item>
    
      <item>
        <title>Android NDK 开发JNI 中局部引用、全局引用和弱全局引用（四）</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃圾回收器在处理这些事情就行了，然而，从Java虚拟机创建的对象传到C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不回触发该引用所指向Java对象的垃圾回收；这些引用在JNI 中分为3种：全局引用（Global Reference）、局部引用 (Local Reference)、弱全局引用 (Week Global Reference) since JDK1.2。

&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;三种引用的区别&quot;&gt;&lt;strong&gt;三种引用的区别&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;1全局引用&quot;&gt;&lt;strong&gt;1、全局引用&lt;/strong&gt;&lt;/h4&gt;
全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部引用不同的是，没有那么多函数能够创建全局引用。能创建全局引用的函数只有 NewGlobalRef。以下例子说明了如何使用一个全局引用。

java native方法：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public native void createGlobalRef();
	
	public native String getGlobalRef();
	
	public native void deleteGlobalRef();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;!-- more --&gt;
jni实现：
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//全局引用
//共享(可以跨多个线程)，手动控制内存使用
jstring global_str;

//创建
JNIEXPORT void JNICALL Java_com_study_jni_JniTest_createGlobalRef(JNIEnv *env, jobject jobj){
	jstring obj = (*env)-&amp;gt;NewStringUTF(env, &quot;jni development is powerful!&quot;);
	global_str = (*env)-&amp;gt;NewGlobalRef(env, obj);
}

//获得
JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getGlobalRef(JNIEnv *env, jobject jobj){
	return global_str;
}

//释放
JNIEXPORT void JNICALL Java_com_study_jni_JniTest_deleteGlobalRef(JNIEnv *env, jobject jobj){
	(*env)-&amp;gt;DeleteGlobalRef(env, global_str);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;2局部引用&quot;&gt;&lt;strong&gt;2、局部引用&lt;/strong&gt;&lt;/h4&gt;
一个局部引用仅在创建它的native函数及该函数调用的函数中有效。在一个native函数执行期间创建的所有局部引用将在该函数返回时被释放，创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性。

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//模拟：循环创建数组
JNIEXPORT void JNICALL Java_com_study_jni_JniTest_localRef(JNIEnv *env, jobject jobj){
	int i = 0;
	for (; i &amp;lt; 5; i++){
		//创建Date对象
		jclass cls = (*env)-&amp;gt;FindClass(env, &quot;java/util/Date&quot;);
		jmethodID constructor_mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;&amp;lt;init&amp;gt;&quot;, &quot;()V&quot;);
		jobject obj = (*env)-&amp;gt;NewObject(env, cls, constructor_mid);
		//此处省略一百行代码...

		//不在使用jobject对象了
		//通知垃圾回收器回收这些对象
		//释放局部引用
		(*env)-&amp;gt;DeleteLocalRef(env, obj);
		//此处省略一百行代码...
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
上面代码中，省略了和我们无关紧要的代码，通过FindClass返回一个对java.util.Date对象的局部引用。

&lt;hr /&gt;
&lt;h4 id=&quot;3弱全局引用&quot;&gt;&lt;strong&gt;3、弱全局引用&lt;/strong&gt;&lt;/h4&gt;
节省内存，在内存不足时可以是释放所引用的对象，可以引用一个不常用的对象，如果为NULL，临时创建，弱全局引用使用NewGlobalWeakRef创建，使用DeleteGlobalWeakRef释放。下面简称弱引用。与全局引用类似，弱引用可以跨方法、线程使用。但与全局引用很重要不同的一点是，弱引用不会阻止GC回收它引用的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。

&lt;h5 id=&quot;1创建弱全局引用&quot;&gt;&lt;strong&gt;1.创建弱全局引用&lt;/strong&gt;&lt;/h5&gt;
用NewWeakGlobalRef函数对弱全局引用进行初始化，例如：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jclass weakGlobalcls
weakGlobalcls = (*env)-&amp;gt;NewWeakGlobalRef(env,localclazz);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2引用的比较&quot;&gt;&lt;strong&gt;2.引用的比较&lt;/strong&gt;&lt;/h5&gt;
给定两个引用（不管是全局、局部还是弱全局引用），我们只需要调用IsSameObject来判断它们两个是否指向相同的对象。例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;（*env)-&amp;gt;IsSameObject(env, obj1, obj2)&lt;/code&gt;
如果obj1和obj2指向相同的对象，则返回&lt;strong&gt;JNI_TRUE（或者1）&lt;/strong&gt;，否则返回&lt;strong&gt;JNI_FALSE（或者0）&lt;/strong&gt;。有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象。如果obj是一个局部或全局引用，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;(*env)-&amp;gt;IsSameObject(env, obj, NULL) 或者 obj == NULL&lt;/code&gt; 来判断obj是否指向一个null对象即可。但需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。比如：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(JNI_FALSE == (*env)-&amp;gt;IsSameObject(env,weakGlobalcls,NULL)){
//TODO 对象未被回收，可以使用
}else{
//TODO 对象被垃圾回收器回收，不能使用
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
以上就是学习这jni 的三种引用的简单使用，相关的知识并没有深入详细的说明！O(∩_∩)O~~

&lt;blockquote&gt;
  本文由博主辛苦整理下来的笔记； 
希望大家能够指点或提出宝贵意见，共同学习，谢谢！ 
转载请注明出处：&lt;a href=&quot;http://xuhaoblog.com/ndk/jni-4.html&quot;&gt;http://xuhaoblog.com/ndk/jni-4.html&lt;/a&gt;
欢迎关注我的社交网站~
个人博客：&lt;a href=&quot;http://xuhaoblog.com&quot;&gt;xuhaoblog.com&lt;/a&gt;
新浪微博：&lt;a href=&quot;http://weibo.com/xuxiho&quot;&gt;http://weibo.com/xuxiho&lt;/a&gt;
github：&lt;a href=&quot;https://github.com/git-xuhao&quot;&gt;https://github.com/git-xuhao&lt;/a&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 18 Oct 2016 22:54:00 +0800</pubDate>
        <link>http://localhost:4000/ndk-jni-4</link>
        <guid isPermaLink="true">http://localhost:4000/ndk-jni-4</guid>
        
        <category>ndk</category>
        
        
        <category>NDK</category>
        
      </item>
    
      <item>
        <title>Android NDK开发C访问Java属性和方法（三）</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~

&lt;hr /&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
继&lt;a href=&quot;http://blog.csdn.net/u011974987/article/details/52743495&quot;&gt; Android NDK 开发（二）JNI 传递参数和返回值&lt;/a&gt;之后。

&lt;h3 id=&quot;1访问类方法&quot;&gt;&lt;strong&gt;1.访问类方法&lt;/strong&gt;&lt;/h3&gt;
初始化了Java虚拟机后，就可以开始调用Java的方法。要调用一个Java对象的方法必须经过几个步骤：

&lt;h4 id=&quot;11获取指定对象的类定义jclass&quot;&gt;&lt;strong&gt;1.1获取指定对象的类定义（jclass）&lt;/strong&gt;&lt;/h4&gt;
有两种方式来获取对象的类定义：
第一种是在已知类名的情况下使用FindClass来查找对应的类。但是要注意类名并不同于平时写的Java代码，例如要得到类jni.test.Demo的定义必须调用如下代码：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jclass cls = (*env)-&amp;gt;FindClass(env, &quot;jni/test/Demo&quot;); //把点号换成斜杠
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
第二种是通过对象直接得到其所对应的类定义：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jclass cls = (*env)-&amp;gt; GetObjectClass(env, obj); //其中obj是要引用的对象，类型是jobject 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;!-- more --&gt;

&lt;h4 id=&quot;12读取要调用方法的定义&quot;&gt;&lt;strong&gt;1.2读取要调用方法的定义&lt;/strong&gt;&lt;/h4&gt;

我们先来看看JNI中获取方法定义的函数：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jmethodID (JNICALL *GetMethodID)(JNIEnv *env, jclass clazz, const char *name,  
const char *sig); 


jmethodID (JNICALL *GetStaticMethodID)(JNIEnv *env, jclass class, const char  
*name, const char *sig);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
这两个函数的区别明显都能猜到，GetStaticMethodID 是用来获取静态方法的定义，而GetMethodID 则是获取非静态的方法定义。

这两个函数都需要提供四个参数：

&lt;ul&gt;
  &lt;li&gt;第一个参数env 就是初始化虚拟机得到的jni环境；&lt;/li&gt;
  &lt;li&gt;第二个参数class 是对象的类定义，也就是第一步得到的obj；&lt;/li&gt;
  &lt;li&gt;第三个参数是方法名称；&lt;/li&gt;
  &lt;li&gt;第四个参数是最重要德，这个参数是方法的定义。&lt;/li&gt;
&lt;/ul&gt;

因为我们知道Java中允许方法的多态，仅仅是通过方法名是没有办法定位到一个具体的方法，因此就需要第 四个参数来指定方法的具体定义（也就是所谓的签名）；但是怎么利用一个字符串来表示方法的具体定义呢？JDK中已经准备好一个反编译工具javap。

通过这个工具就可以得到类 中每个属性、方法的定义。下面就来看看jni.test.Demo的定义：

打开命令行窗口进入到项目目录德的bin目录下，并运行 javap -s -p jni.test.Demo 得到运行结果如下：

&lt;img src=&quot;https://img-blog.csdn.net/20161006210123652&quot; alt=&quot;cmd签名&quot; /&gt;

从上图中，我们看到类中每个属性和方法下面都有一段注释。注释中不包含空格的内容就是第四个参数要填的内容。基本数据的签名如下：

&lt;img src=&quot;https://img-blog.csdn.net/20161006213959982&quot; alt=&quot;这里写图片描述&quot; /&gt;

下面这段代码将调用accessConstructor（）的方法。

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//访问构造方法
//使用java.util.Date产生一个当前的时间戳
JNIEXPORT jobject JNICALL Java_com_dongnaoedu_jni_JniTest_accessConstructor
(JNIEnv *env, jobject jobj){
	jclass cls = (*env)-&amp;gt;FindClass(env, &quot;java/util/Date&quot;);
	//jmethodID
	jmethodID constructor_mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;&amp;lt;init&amp;gt;&quot;, &quot;()V&quot;);
	//实例化一个Date对象
	jobject date_obj = (*env)-&amp;gt;NewObject(env, cls, constructor_mid);
	//调用getTime方法
	jmethodID mid = (*env)-&amp;gt;GetMethodID(env, cls, &quot;getTime&quot;, &quot;()J&quot;);
	jlong time = (*env)-&amp;gt;CallLongMethod(env, date_obj, mid);

	printf(&quot;\ntime:%lld\n&quot;,time);

	return date_obj;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

在java 端调用

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t.accessConstructor();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

运行结果：

&lt;img src=&quot;https://img-blog.csdn.net/20161006211824441&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;13-调用方法&quot;&gt;&lt;strong&gt;1.3 调用方法&lt;/strong&gt;&lt;/h4&gt;

为了调用对象的某个方法，可以使用函数

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Call&amp;lt;TYPE&amp;gt;Method或者 CallStatic&amp;lt;TYPE&amp;gt;Method（访问类的静态方法），
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&amp;lt; TYPE&amp;gt;根据不同的返回类型而定。这些方法都是使用可 变参数的定义，如果访问某个方法需要参数时，只需要把所有参数按照顺序填写到方法中就可以。在讲到构造函数的访问时，将演示如何访问带参数的构造函数。

&lt;hr /&gt;

&lt;h3 id=&quot;2访问类属性&quot;&gt;&lt;strong&gt;2.访问类属性&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&quot;21-获取指定对象的类jclass&quot;&gt;&lt;strong&gt;2.1 获取指定对象的类（jclass）&lt;/strong&gt;&lt;/h4&gt;

这一步，与访问类方法完全一样，具体就参考上面德步骤吧~

&lt;hr /&gt;
&lt;h4 id=&quot;22-读取类属性的定义jfieldid&quot;&gt;&lt;strong&gt;2.2 读取类属性的定义（jfieldID）&lt;/strong&gt;&lt;/h4&gt;
在JNI中是这样定义获取类属性的方法的：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jfieldID (JNICALL *GetFieldID)
(JNIEnv *env, jclass clazz, const char *name, const char *sig); 


jfieldID (JNICALL *GetStaticFieldID) 
(JNIEnv *env, jclass clazz, const char *name, const char *sig); 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

这两个函数中第一个参数为JNI环境；clazz为类的定义；name为属性名称；第四个参数同样是为了表达属性的类型。前面我们使用javap工具获取类的详细定义的时候有这样两行：

public java.lang.String key; 
/*   Ljava/lang/String;   */

其中第二行注释的内容就是第四个参数要填的信息，这跟访问类方法时是相同的。

&lt;hr /&gt;
&lt;h4 id=&quot;23-读取和设置属性值&quot;&gt;&lt;strong&gt;2.3 读取和设置属性值&lt;/strong&gt;&lt;/h4&gt;
有了属性的定义要访问属性值就很容易了。有几个方法用来读取和设置类的属性，它们是：&lt;code class=&quot;highlighter-rouge&quot;&gt;Get&amp;lt;TYPE&amp;gt;Field、 Set&amp;lt;TYPE&amp;gt;Field、GetStatic&amp;lt;TYPE&amp;gt;Field、 SetStatic&amp;lt;TYPE&amp;gt;Field。&lt;/code&gt;
比如读取Demo类的key属性就可以用GetFieldID，相关代码如下：

java调用代码：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//属性
public String key = &quot;xuhao&quot;;
	//访问属性，返回修改之后的属性内容
public native String accessField();

public static void main(String[] args) {
    JniTest t = new JniTest();
	System.out.println(&quot;key修改前：&quot;+t.key);
	t.accessField();
	System.out.println(&quot;key修改后：&quot;+t.key);
		
		
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
本地方法实现：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//C/C++访问Java的成员

//1.访问属性
//修改属性key
JNIEXPORT jstring JNICALL Java_com_dongnaoedu_jni_JniTest_accessField
(JNIEnv *env, jobject jobj){
	//jobj是t对象，JniTest.class
	jclass cls = (*env)-&amp;gt;GetObjectClass(env, jobj);
	//jfieldID
	//属性名称，属性签名
	jfieldID fid = (*env)-&amp;gt;GetFieldID(env, cls, &quot;key&quot;, &quot;Ljava/lang/String;&quot;);	

	//xuhao &amp;gt;&amp;gt; super xuhao
	//获取key属性的值
	//Get&amp;lt;Type&amp;gt;Field
	jstring jstr = (*env)-&amp;gt;GetObjectField(env, jobj, fid);	
	printf(&quot;jstr:%#x\n&quot;,&amp;amp;jstr);

	//jstring -&amp;gt; c字符串
	//isCopy 是否复制（true代表赋值，false不复制）
	char *c_str = (*env)-&amp;gt;GetStringUTFChars(env,jstr,JNI_FALSE);
	//拼接得到新的字符串
	char text[20] = &quot;super &quot;;
	strcat(text,c_str);

	//c字符串 -&amp;gt;jstring
	jstring new_jstr = (*env)-&amp;gt;NewStringUTF(env, text);

	//修改key
	//Set&amp;lt;Type&amp;gt;Field
	(*env)-&amp;gt;SetObjectField(env, jobj, fid, new_jstr);

	printf(&quot;new_jstr:%#x\n&quot;, &amp;amp;new_jstr);

	return new_jstr;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

最后调用结果如下：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;key修改前：xuhao
key修改后：super xuhao
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

其他的访问方式都是按照这些套路来的，理解就可以了，今天连续赶了两篇博客，后面再抽出时间继续，坚持，坚持，再坚持！！！

&lt;hr /&gt;

&lt;blockquote&gt;
  本文由博主辛苦整理下来的笔记； 
希望大家能够指点或提出宝贵意见，共同学习，谢谢！ 
转载请注明出处：&lt;a href=&quot;http://blog.csdn.net/u011974987/article/details/52745362&quot;&gt;http://blog.csdn.net/u011974987/article/details/52745362&lt;/a&gt;
欢迎关注我的社交网站~
个人博客：&lt;a href=&quot;http://xuhaoblog.com&quot;&gt;xuhaoblog.com&lt;/a&gt;
新浪微博：&lt;a href=&quot;http://weibo.com/xuxiho&quot;&gt;http://weibo.com/xuxiho&lt;/a&gt;
github：&lt;a href=&quot;https://github.com/git-xuhao&quot;&gt;https://github.com/git-xuhao&lt;/a&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 07 Oct 2016 06:30:31 +0800</pubDate>
        <link>http://localhost:4000/ndk-jni-3</link>
        <guid isPermaLink="true">http://localhost:4000/ndk-jni-3</guid>
        
        <category>ndk</category>
        
        
        <category>NDK</category>
        
      </item>
    
      <item>
        <title>Android NDK开发JNI传递参数和返回值（二）</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。

&lt;hr /&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
继&lt;a href=&quot;http://blog.csdn.net/u011974987/article/details/52602913&quot;&gt;JNI简介及调用流程&lt;/a&gt;这篇文章，我们再来实现一个非静态的native方法。

Java端：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JniTest {

    //静态的
	public native static String getStringFromC();
	
	//非静态的
	public native String getString2FromC(int i);
	
	public static void main(String[] args) {
		String text = getStringFromC();
		System.out.println(text);
		
		JniTest t = new JniTest();
		text = t.getString2FromC(6);
		System.out.println(text);
		
	}
	
	//加载动态库
	static{	
		System.loadLibrary(&quot;jni_study&quot;);
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;!-- more --&gt;
在native层实现 getString2FromC 非静态方法；

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getString2FromC
(JNIEnv *env, jobject jobj, jint num){
	return (*env)-&amp;gt;NewStringUTF(env,&quot;C String2&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

由此看出，每个native函数，都至少有两个参数（JNIEnv*,jclass或者jobject)

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;当native方法为静态方法时：&lt;/strong&gt;
jclass 代表native方法所属类的class对象(JniTest.class)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;当native方法为非静态方法时：&lt;/strong&gt;
jobject 代表native方法所属的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;1java基本数据类型传递&quot;&gt;&lt;strong&gt;1.Java基本数据类型传递&lt;/strong&gt;&lt;/h3&gt;

用过Java的人都知道，Java中的基本类型包括boolean，byte，char，short，int，long，float，double这样几种，如果你用这几种类型做native方法的参数，当你通过javah -jni生成.h文件的时候，只要看一下生成的.h文件，就会一清二楚，这些类型分别对应的类型是jboolean，jbyte，jchar，jshort，jint，jlong，jfloat，jdouble 。这几种类型几乎都可以当成对应的C++类型来用。

Java基本数据类型与JNI数据类型的映射关系如下：

&lt;img src=&quot;https://img-blog.csdn.net/20161006145447006&quot; alt=&quot;JNI的基本数据类型&quot; /&gt;

对应的java引用数据类型：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct _jobject;

typedef struct _jobject *jobject;
typedef jobject jclass;
typedef jobject jthrowable;
typedef jobject jstring;
typedef jobject jarray;
typedef jarray jbooleanArray;
typedef jarray jbyteArray;
typedef jarray jcharArray;
typedef jarray jshortArray;
typedef jarray jintArray;
typedef jarray jlongArray;
typedef jarray jfloatArray;
typedef jarray jdoubleArray;
typedef jarray jobjectArray;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
关系图：

&lt;img src=&quot;https://img-blog.csdn.net/20161006153213851&quot; alt=&quot;这里写图片描述&quot; /&gt;

最终都是jobject 的结构体指针类型。

&lt;hr /&gt;
&lt;h3 id=&quot;2string参数的传递&quot;&gt;&lt;strong&gt;2.String参数的传递&lt;/strong&gt;&lt;/h3&gt;

Java的String和C++的string是不能对等起来的，所以处理起来比较麻烦。先看一个例子

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Prompt {

// native method that prints a prompt and reads a line
private native String getLine(String prompt);

public static void main(String args[]) {
Prompt p = new Prompt();
String input = p.getLine(&quot;Type a line: &quot;);

System.out.println(&quot;User typed: &quot; + input);
}

static {
System.loadLibrary(&quot;Prompt&quot;);
}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

在这个例子中，我们要实现一个native方法，String getLine(String prompt);读入一个String参数，返回一个String值。通过执行javah -jni得到的头文件是这样的。

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;jni.h&amp;gt;
#ifndef _Included_Prompt
#define _Included_Prompt
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
JNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject this, jstring prompt);
#ifdef __cplusplus
}
#endif
#endif

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
jstring是JNI中对应于String的类型，但是和基本类型不同的是，jstring不能直接当作C++的string用。如果你用

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cout &amp;lt;&amp;lt; prompt &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

编译器肯定会扔给你一个错误信息的。
其实要处理jstring有很多种方式，这里只讲一种我认为最简单的方式，看下面这个例子：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;Prompt.h&quot;
#include &amp;lt;iostream&amp;gt;

JNIEXPORT jstring JNICALL Java_Prompt_getLine(JNIEnv *env, jobject obj, jstring prompt)
{
const char* str;
str = env-&amp;gt;GetStringUTFChars(prompt, false);
if(str == NULL) {
return NULL; 
}

std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl;

//释放资源
env-&amp;gt;ReleaseStringUTFChars(prompt, str);

// 返回一个字符串
char* tmpstr = &quot;return string succeeded&quot;;
jstring rtstr = env-&amp;gt;NewStringUTF(tmpstr);
return rtstr;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

在上面的列子代码中，作为参数的prompt不能直接被C++程序使用，先做了如下转换

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;str = env-&amp;gt;GetStringUTFChars(prompt, false);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

将jstring类型变成一个char*类型。
返回的时候，要生成一个jstring类型的对象，也必须通过如下方式，

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jstring rtstr = env-&amp;gt;NewStringUTF(tmpstr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

这里用到的&lt;strong&gt;GetStringUTFChars&lt;/strong&gt;和&lt;strong&gt;NewStringUTF&lt;/strong&gt;都是JNI提供的处理String类型的函数。

&lt;hr /&gt;

&lt;h3 id=&quot;3数组类型的传递&quot;&gt;&lt;strong&gt;3.数组类型的传递&lt;/strong&gt;&lt;/h3&gt;
和String一样，JNI为Java基本类型的数组提供了j*Array类型，比如int[]对应的就是jintArray。来看一个传递int数组的例子。

java端主要代码：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public native void giveArray(int[] array);
	
	int[] array = {9,100,10,37,5,10};
		//排序
	t.giveArray(array);
	
	for (int i : array) {
		System.out.println(i);
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
C实现主要代码：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int compare(int *a,int *b){
	return (*a) - (*b);
}

//传入
JNIEXPORT void JNICALL Java_com_study_jni_JniTest_giveArray
(JNIEnv *env, jobject jobj, jintArray arr){
	//jintArray -&amp;gt; jint指针 -&amp;gt; c int 数组
	jint *elems = (*env)-&amp;gt;GetIntArrayElements(env, arr, NULL);
	//printf(&quot;%#x,%#x\n&quot;, &amp;amp;elems, &amp;amp;arr);

	//数组的长度
	int len = (*env)-&amp;gt;GetArrayLength(env, arr);
	//排序
	qsort(elems, len, sizeof(jint), compare);	

	//同步
	//mode
	//0, Java数组进行更新，并且释放C/C++数组
	//JNI_ABORT, Java数组不进行更新，但是释放C/C++数组
	//JNI_COMMIT，Java数组进行更新，不释放C/C++数组（函数执行完，数组还是会释放）
	
	(*env)-&amp;gt;ReleaseIntArrayElements(env, arr, elems, JNI_COMMIT);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
这个代码中的&lt;strong&gt;GetIntArrayElements&lt;/strong&gt;和&lt;strong&gt;ReleaseIntArrayElements&lt;/strong&gt;函数就是JNI提供用于处理int数组的函数。

如果用arr[i]的方式去访问jintArray类型，不用问肯定会出错。
JNI还提供了另一对函数&lt;strong&gt;GetIntArrayRegion&lt;/strong&gt;和&lt;strong&gt;ReleaseIntArrayRegion&lt;/strong&gt;访问int数组，不在这里做介绍，至于其他的类型数组，方法类似。

&lt;hr /&gt;

&lt;h3 id=&quot;4返回数组&quot;&gt;&lt;strong&gt;4.返回数组&lt;/strong&gt;&lt;/h3&gt;

在JNI中，二维数组和String数组都被视为object数组，因为数组和String被视为object。最后一个示例说明如何在本地代码中创建一个字符串数组并将它返回给 Java 调用者。

java端的代码：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	int[] array2 = t.getArray(10);
	System.out.println(&quot;------------&quot;);
	for (int i : array2) {
		System.out.println(i);
	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
函数实现：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//返回数组
JNIEXPORT jintArray JNICALL Java_com_study_jni_JniTest_getArray(JNIEnv *env, jobject jobj, jint len){
	//创建一个指定大小的数组
	jintArray jint_arr = (*env)-&amp;gt;NewIntArray(env, len);
	jint *elems = (*env)-&amp;gt;GetIntArrayElements(env, jint_arr, NULL);	
	int i = 0;
	for (; i &amp;lt; len; i++){
		elems[i] = i;
	}

	//同步
	(*env)-&amp;gt;ReleaseIntArrayElements(env, jint_arr, elems, 0);	

	return jint_arr;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

jintArray jint_arr ;因为要返回值，所以需要创建一个指定大小jintArray对象。根据jintArray对象拿到jint 指针。然后，赋值，同步，这样通过参数返回就可以了。
下一篇将会介绍C 访问Java 属性和方法。

</description>
        <pubDate>Thu, 06 Oct 2016 23:28:31 +0800</pubDate>
        <link>http://localhost:4000/ndk-jni-2</link>
        <guid isPermaLink="true">http://localhost:4000/ndk-jni-2</guid>
        
        <category>ndk</category>
        
        
        <category>NDK</category>
        
      </item>
    
      <item>
        <title>Android NDK开发JNI简介及调用流程（一）</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;
前段时间学习了C、C++的一些基础知识后，了解了它们的编码风格，要想掌握NDK开发，前提是会使用JNI，下面我们开始简单的介绍吧！

&lt;h3 id=&quot;jni简介&quot;&gt;&lt;strong&gt;JNI简介&lt;/strong&gt;&lt;/h3&gt;

　　JNI全称是Java Native Interface（Java本地接口），本地接口就是指用C和C++开发的接口。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。

　　开发JNI程序会受到系统环境的限制，因为用C/C++语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和CPU指令集，而且各个平台对标准C/C++的规范和标准库函数实现方式也有所区别。这就造成使用了JNI接口的JAVA程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。

&lt;!-- more --&gt;
&lt;strong&gt;JNI的开发流程主要分为以下几个步骤：&lt;/strong&gt;

&lt;ol&gt;
  &lt;li&gt;
    编写带有native声明方法的java类；
  &lt;/li&gt;
  &lt;li&gt;
    用”javac”命令来编译所编写的java类；
  &lt;/li&gt;
  &lt;li&gt;
    使用”javah”java类的名生成扩展名为h的头文件；
  &lt;/li&gt;
  &lt;li&gt;
    复制jni.h和jni_md.h文件到CPP工程中;
  &lt;/li&gt;
  &lt;li&gt;
    实现.h头文件中声明的函数
  &lt;/li&gt;
  &lt;li&gt;
    生成dll动态链接库
  &lt;/li&gt;
  &lt;li&gt;
    配置dll文件所在目录到环境变量
  &lt;/li&gt;
  &lt;li&gt;
    重启Eclipse
  &lt;/li&gt;
&lt;/ol&gt;

&lt;strong&gt;jni调用dill的流程图如下：&lt;/strong&gt;

&lt;img src=&quot;https://img-blog.csdn.net/20160921002729113&quot; alt=&quot;这里写图片描述&quot; /&gt;

通过上面的分析，相信大家已经对jni的开发流程有一个整体的认识，接下来，我们将通过实例更进一步的了解。

&lt;h4 id=&quot;第一步编写带有native声明方法的java类&quot;&gt;&lt;strong&gt;第一步：编写带有native声明方法的java类&lt;/strong&gt;&lt;/h4&gt;

JniTest.java

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jni&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JniTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStringFromC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;第二步用javac命令来编译所编写的java类&quot;&gt;&lt;strong&gt;第二步：用”javac”命令来编译所编写的java类；&lt;/strong&gt;&lt;/h4&gt;

首先我们必须得配有java环境变量，然后我们右键点击项目-&amp;gt;properties,复制项目路径；

&lt;img src=&quot;https://img-blog.csdn.net/20160921004851299&quot; alt=&quot;这里写图片描述&quot; /&gt;

然后进入dos命令，

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\Users\uuxuh&amp;gt;cd E:\Documents\11\JniTest

C:\Users\uuxuh&amp;gt;E:

E:\Documents\11\JniTest&amp;gt;cd src

E:\Documents\11\JniTest\src&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;第三步使用javahjava类的名生成h的头文件&quot;&gt;&lt;strong&gt;第三步：使用”javah”java类的名生成.h的头文件&lt;/strong&gt;&lt;/h4&gt;
接着，复制我们的完整类名（包名+类名），执行命令：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E:\Documents\11\JniTest\src&amp;gt;javah com.study.jni.JniTest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
回到工程目录下，刷新项目，编译后的.h头文件就出现了。

源码：

com_study_jni_JniTest.h

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &amp;lt;jni.h&amp;gt;
/* Header for class com_study_jni_JniTest */

#ifndef _Included_com_study_jni_JniTest
#define _Included_com_study_jni_JniTest
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     com_study_jni_JniTest
 * Method:    getStringFromC
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getStringFromC
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;第四步复制jnih和jni_mdh文件到cpp工程中&quot;&gt;&lt;strong&gt;第四步：复制jni.h和jni_md.h文件到CPP工程中&lt;/strong&gt;&lt;/h4&gt;
将要编译的文件中引入了

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#inlcude&amp;lt;jni.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
头文件，所以我们手动导入这两个文件到CPP工程中，

以我的jdk1.7.0_75为例，两个头文件的位置分别为：
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jni.h    jdk1.7.0_75/include
jni_md.h    jdk1.7.0_75/include/linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
将我们生成.h头文件复制到项目的代码文件目录下 ， 在解决方案中的头文件目录-&amp;gt; 右键-&amp;gt; 添加 -&amp;gt; 添加现有项 。 将我们的头文件添加进来，还有jni.h和jni_md.h一起添加进来，如图：

&lt;img src=&quot;https://img-blog.csdn.net/20160921011013003&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;h4 id=&quot;第五步实现h头文件中声明的函数&quot;&gt;&lt;strong&gt;第五步：实现.h头文件中声明的函数&lt;/strong&gt;&lt;/h4&gt;

c代码如下：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;com_study_jni_JniTest.h&quot;

//函数实现
JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getStringFromC
(JNIEnv *env, jclass jcls){
	//简单的实现
return (*env)-&amp;gt;NewStringUTF(env, &quot;C String&quot;);


}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;第六步生成dll动态链接库&quot;&gt;&lt;strong&gt;第六步：生成dll动态链接库&lt;/strong&gt;&lt;/h4&gt;

我们以VS2013为例：

操作步骤：

选中项目 -&amp;gt; 右键 -&amp;gt; 属性 -&amp;gt; 常规 -&amp;gt; 项目默认值 -&amp;gt; 配置类型 , 选择动态库.dll，

&lt;img src=&quot;https://img-blog.csdn.net/20160921011522662&quot; alt=&quot;这里写图片描述&quot; /&gt;

如图，右上角配置管理器，根据我们所使用的平台进去配置一下：

&lt;img src=&quot;https://img-blog.csdn.net/20160921011811821&quot; alt=&quot;这里写图片描述&quot; /&gt;

这里我使用64位的，所以活动解决方案平台下新建了一个x64，部署项目配置也选择x64。

配置完了之后，最后生成解决方案。去项目目录下查看dll动态库。

&lt;img src=&quot;https://img-blog.csdn.net/20160921012257530&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;h4 id=&quot;font-colorblue第七步配置dll文件所在目录到环境变量&quot;&gt;&amp;lt;font color=blue&amp;gt;&lt;strong&gt;第七步：配置dll文件所在目录到环境变量&lt;/strong&gt;&lt;/h4&gt;

我们把生成dll文件的路径配置java环境变量里面，这样java 才会知道有dll动态库存在，配置完之后，重启下Eclipse。

最后我们在java中调用动态库，完整代码：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;study&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jni&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JniTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStringFromC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getStringFromC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;加载动态库&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	   &lt;span class=&quot;nf&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loadLibrary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jni_study&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

最后运行一下项目控制台打印出C中返回给我们的字符串。

&lt;img src=&quot;https://img-blog.csdn.net/20160921013119011&quot; alt=&quot;这里写图片描述&quot; /&gt;

好了，整个jni的调用流程已经说的非常详细了，但这只是jni入门的基础，后续会继续更新！

&lt;blockquote&gt;
  学习理解并整理下来的笔记；&lt;br /&gt;
希望大家能够指点或提出宝贵意见，一起学习，谢谢！ 
转载请注明出处：&lt;a href=&quot;http://blog.csdn.net/u011974987/article/details/52602913&quot;&gt;http://blog.csdn.net/u011974987/article/details/52602913&lt;/a&gt;
个人主页：&lt;a href=&quot;http://xuhaoblog.com&quot;&gt;xuhaoblog.com&lt;/a&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 04 Oct 2016 23:28:31 +0800</pubDate>
        <link>http://localhost:4000/ndk-jni-1</link>
        <guid isPermaLink="true">http://localhost:4000/ndk-jni-1</guid>
        
        <category>ndk</category>
        
        
        <category>NDK</category>
        
      </item>
    
      <item>
        <title>shell 脚本基础学习之函数（五）</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
Linux shell脚本基础学习我们这里就差不多讲完了，函数相信大家都不陌生吧，直接入正题吧~

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;a href=&quot;http://xuhaoblog.com/linux/shell-script-04.html&quot;&gt;继上篇博客之后&lt;/a&gt;
&lt;h4 id=&quot;shell-函数&quot;&gt;&lt;strong&gt;shell 函数&lt;/strong&gt;&lt;/h4&gt;

Linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。
shell 中函数的定义格式如下：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function_name () {
    list of commands
    [ return value ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
说明：

&lt;ul&gt;
  &lt;li&gt;1、函数名前面也可以加上关键字function；&lt;/li&gt;
  &lt;li&gt;2、函数的返回值，可以显示加：return 返回，如果不加，将以最后一条命令的运行结果作为返回值。
 &lt;!-- more --&gt;
shell 函数返回值只能是整数，一般用来表示函数执行是否政工，0表示成功，其他则表示失败。&lt;/li&gt;
&lt;/ul&gt;

如果要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在访问这个变量来获得函数的返回值。

比如：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1 #!/bin/bash                                                            
  2 Hello () {
  3         echo &quot;My name is xu hao&quot;
  4 }
  5 
  6 #调用上面的函数
  7 Hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
运行结果：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@iZ28t5k4ny4Z:/usr/xiho/shell# ./06.sh 
My name is xu hao
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;strong&gt;调用函数只需要给出函数名，不需要加括号。&lt;/strong&gt;

再来看一个带有return语句的函数：

在上面例子后面添加：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; funWithReturn() {
 11         echo &quot;这个函数功能是得到两个数字的和&quot;
 12         echo -n &quot;请输入第一个数字&quot;
 13         read aNum;
 14         echo -n &quot;请输入第二个数字&quot;
 15         read bNum;
 16         echo &quot;这两个数分别是 $aNum 和 $bNum !&quot;
 17   return $(($aNum+$bNum))
 18 } 
 19 
 20 #调用funWithReturn这个函数
 21 funWithReturn
 22 
 23 ret=$?
 24 echo &quot;The sun of two numbers is $ret !&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

运行结果：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@iZ28t5k4ny4Z:/usr/xiho/shell# ./06.sh 
My name is xu hao
这个函数功能是得到两个数字的和
请输入第一个数字56
请输入第二个数字23
这两个数分别是 56 和 23 !
The sun of two numbers is 79 !

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  $?最后运行的命令的结束代码（返回值），这个在后面会总结的。
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;函数参数&quot;&gt;&lt;strong&gt;函数参数&lt;/strong&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在shell 中，调用函数时可以向其传递参数，在函数体内部，通过$n 的形式来获取参数，比如,$1表示第一个参数，$2表示第二个参数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

再来看一个带参数的函数例子：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 28 funWithParam() {
 29         echo &quot;第一个param为 $1&quot;
 30         echo &quot;第二个param为 $2&quot;
 31         echo &quot;第十个param为 $10&quot;
 32         echo &quot;第十个param为 ${10}&quot;
 33         echo &quot;参数总共有 $#&quot;
 34         echo &quot;作为一个字符串输出所有参数 $* !&quot;
 35 
 36 }
 37 #调用函数并传递参数
 38 funWithParam 1 2 3 4 5 6 23 45 22 9 25

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

运行脚本输出的结果为：

&lt;img src=&quot;https://img-blog.csdn.net/20161001175800334&quot; alt=&quot;这里写图片描述&quot; /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 在这里注意下，$ 10不能获取第10个参数，当n&amp;gt;=10时，需要${n}来获取参数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;strong&gt;另外：在补充几个特殊字符来处理的参数&lt;/strong&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$#	传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

一下午整理这两篇博客，算是把Linux shell 脚本的基础的理论学习讲完了，更多的细节只有等我们遇到了在慢慢琢磨吧！吃饭~

&lt;hr /&gt;

&lt;h2 id=&quot;更多相关系列传送门&quot;&gt;更多相关系列传送门：&lt;/h2&gt;
&lt;strong&gt;【个人博客】shel 脚本系列&lt;/strong&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://xuhaoblog.com/linux/shell-script-01.html&quot;&gt;【Linux 系统编程】shell 脚本基础学习（一）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xuhaoblog.com/linux/shell-script-02.html&quot;&gt;【Linux 系统编程】shell 命令和流程控制（二）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xuhaoblog.com/linux/shell-script-03.html&quot;&gt;【Linux 系统编程】shell 流程控制loop和引号（三）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xuhaoblog.com/linux/shell-script-04.html&quot;&gt;【Linux 系统编程】shell 输入/输出重定向（四）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xuhaoblog.com/linux/shell-script-05.html&quot;&gt;【Linux 系统编程】shell 脚本基础学习之函数（五）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 02 Oct 2016 02:10:31 +0800</pubDate>
        <link>http://localhost:4000/linux/shell-script-05</link>
        <guid isPermaLink="true">http://localhost:4000/linux/shell-script-05</guid>
        
        <category>Shell</category>
        
        
        <category>Shell</category>
        
      </item>
    
  </channel>
</rss>
