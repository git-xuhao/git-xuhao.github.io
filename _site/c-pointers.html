<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>C 语言指针概念的理解（四）</title>
    <meta name="description" content="前言最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了）指针##我们通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/css/main.css ">
    <link rel="canonical" href="http://localhost:4000/c-pointers">
    <link rel="alternate" type="application/rss+xml" title="XUHAO’S 博客" href="http://localhost:4000/feed.xml ">


    <script>
    // 百度统计代码
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3e58af9d5d9338b706ad81d79dcedb4c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-122974929-1', 'auto');
      ga('send', 'pageview');

    </script>



</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">XUHAO’S 博客</a>
        <small>Always hungry to keep learning.</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>博客
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>归档
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>分类
                        </a>
                    </li>
                    
                
                    
                
                    
                    <li>
                        
                        <a href="/collection/">
                        
                            <i class="fa fa-bookmark"></i>书签
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/demo/">
                        
                            <i class="fa fa-play"></i>项目
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-user"></i>关于
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>C 语言指针概念的理解（四）</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2016-08-22
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <!-- <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#C/C++" title="Category: C/C++" rel="category">C/C++</a>
    
  
 -->
  <i class="fa "></i>
  
    
        <a href="/category/#C/C++" title="Category: C/C++" rel="category">C/C++</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#C%2FC%2B%2B" title="Tag: C/C++" rel="tag">C/C++</a-->
        <a href="/tag/#C/C++" title="Tag: C/C++" rel="tag">C/C++</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <h2 id="前言"><strong>前言</strong></h2>
<p>最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了）</p>

<h2 id="指针"><strong>指针</strong>##</h2>

<p>我们通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有必要的。
正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>

<!-- more -->
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main ()
{
   int  var1;
   char var2[10];

   printf("var1 变量的地址： %x\n", &amp;var1  );
   printf("var2 变量的地址： %x\n", &amp;var2  );

   return 0;
}
</code></pre></div></div>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var1 变量的地址： bff5a400
var2 变量的地址： bff5a3f6
</code></pre></div></div>

<p>通过上面的栗子，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针吧！</p>

<h2 id="什么是指针"><strong>什么是指针？</strong></h2>

<p>指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type *name;
</code></pre></div></div>

<p>这里的type 是指针的基类型，它必须是一个有效的 C 数据类型，name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch     /* 一个字符型的指针 */
</code></pre></div></div>

<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>

<h2 id="如何使用指针"><strong>如何使用指针？</strong></h2>
<ul>
  <li>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
//指针
//指针存储的是变量的内存地址
//内存地址，系统给数据分配的编号（门牌号）

void main(){
	int i = 90;
	//指针变量，创建一个int类型的指针
	int* p = &amp;i; //p的值就是i这个变量的内存地址
	printf("%#x\n",p);

	float f = 89.5f;
	//创建一个float类型的指针
	float *fp = &amp;f;
	printf("%#x\n", fp);

	system("pause");
}
</code></pre></div></div>

<p>上面的代码被编译和执行时，运行的结果：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xeffb30
0xeffb18
请按任意键继续. . .
</code></pre></div></div>
<ul>
  <li>对指针存的地址指向的变量进行操作</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

void change(int* p){
	*p = 300;
}

//变量名，对内存空间上的一段数据的抽象
void main(){
	int i = 90;
	//i = 89;
	//创建一个int类型的指针
	int *p = &amp;i;
	//输出地址
	printf("p的地址：%#x\n",&amp;p);
	printf("i的地址：%#x\n",&amp;i);
	printf("i的值为：%d\n", i);
	//间接赋值 i = 200;

	//对p存的地址指向的变量进行操作
	//*p = 200;
	//change(p);
	change(&amp;i);  // int *p = &amp;i;
	printf("i的值为：%d\n",i);

	system("pause");
}
</code></pre></div></div>
<p>上面代码编译执行结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p的地址：0x6ffdb0
i的地址：0x6ffdbc
i的值为：90
i的值为：300
请按任意键继续. . .

</code></pre></div></div>
<p>通过上面栗子，我们可以看出，指针所指向的变量值已经被更改了。</p>

<h2 id="c中的null-指针"><strong>C中的NULL 指针</strong></h2>

<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。
NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main ()
{
   int  *ptr = NULL;

   printf("ptr 的值是 %x\n", ptr  );
 
   return 0;
}
</code></pre></div></div>
<p>运行结果为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ptr 的值是 0
</code></pre></div></div>

<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。
如需检查一个空指针，您可以使用 if 语句，如下所示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;

int main(int argc, char const *argv[]) {

  char *s = "hello";

  if (!s) {
    fprintf(stderr, "s is null\n");
  } else {
    fprintf(stderr, "%s\n", s);
  }

  if (s == NULL) {
    fprintf(stderr, "s is null\n");
  } else {
    fprintf(stderr, "%s\n", s);
  }


  return 0;
}
</code></pre></div></div>

<p>这两种方法都能判断字符指针是否为空，但推荐使用前者。”NULL” 的本质是个宏，并非是个常量，C99 中甚至可以自行定义，故尽量避免使用它去判断，当 !s 与 s == NULL 表示同一含义的时候，使用前者吧！</p>

<h2 id="c中的二级指针多级指针"><strong>C中的二级指针（多级指针）</strong></h2>
<p>指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int *、double *、char * 等。</p>

<p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。
假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示：</p>

<p><img src="https://img-blog.csdn.net/20160821214956473" alt="这里写图片描述" /></p>

<p>用代码表示为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int a =100;
int *p1 = &amp;a;
int **p2 = &amp;p1;
</code></pre></div></div>

<p>指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号 * 。p1 是一级指针，指向普通类型的数据，定义时有一个 * ；p2 是二级指针，指向一级指针 p1，定义时有两个*。</p>

<p>如果再定义一个三级指针 p3，让它指向 p2，那么可以这样写：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int ***p3 = &amp;p2;
</code></pre></div></div>

<p>四级指针：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int ****p4 = &amp;p3;
</code></pre></div></div>
<p>等等，以此类推。。。
不过，经常使用的也就是一级指针和二级指针了。
在获取指针指向的数据时，一级指针加一个 * ，二级指针加两个 * ，三级指针加三个 *，以此类推，请看代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(){
    int a =100;
    int *p1 = &amp;a;
    int **p2 = &amp;p1;
    int ***p3 = &amp;p2;
    printf("%d, %d, %d, %d\n", a, *p1, **p2, ***p3);
    printf("&amp;p2 = %#X, p3 = %#X\n", &amp;p2, p3);
    printf("&amp;p1 = %#X, p2 = %#X, *p3 = %#X\n", &amp;p1, p2, *p3);
    printf(" &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n", &amp;a, p1, *p2, **p3);
    return 0;
}
</code></pre></div></div>

<p>编译并运行结果如下：
<img src="http://img.blog.csdn.net/20160821215837967" alt="这里写图片描述" /></p>

<p>以三级指针 p3 为例来分析上面的代码。<em>** p3等价于 * ( * (</em> p3))。* p3 得到的是 p2 的值，也即 p1 的地址；* ( * p3) 得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后，* ( *(p3)) 得到的才是 a 的值。</p>

<p>假设 a、p1、p2、p3 的地址分别是 0X00A0、0X1000、0X2000、0X3000，它们之间的关系可以用下图来描述：</p>

<p><img src="http://img.blog.csdn.net/20160821220050579" alt="这里写图片描述" /></p>

<p>方框里面是变量本身的值，方框下面是变量的地址。</p>

<h2 id="c中指针的运算"><strong>C中指针的运算</strong></h2>

<p>指针变量保存的是地址，本质上是一个整数，可以进行部分运算，例如加法、减法、比较等，请看下面的代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#include &lt;stdio.h&gt;
//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式
void main(){
	//数组在内存中连续存储
	int ids[] = { 78, 90, 23, 65, 19 };
	//数组变量名：ids就是数组的首地址
	printf("%#x\n",ids);
	printf("%#x\n",&amp;ids);
	printf("%#x\n",&amp;ids[0]);
	//指针变量
	int *p = ids;
	printf("%d\n",*p);
	//指针的加法
	p++; //p++向前移动sizeof(数据类型)个字节
	printf("p的值:%#x\n", p);
	//p--;
	printf("%d\n", *p);
	getchar();
}
</code></pre></div></div>

<p>编译并运行的结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x5ff7d0
0x5ff7d0
0x5ff7d0
78
p的值:0x5ff7d4
90

</code></pre></div></div>

<p>从上面的栗子来看，数组变量名：ids就是数组的首地址，指针的加法，p++就是向前移动了sizeof(数据类型)个字节。
我们知道，数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，不过C语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。</p>

<p>下面举一个栗子，通过指针获取下一个变量的地址：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(){
    int a = 1, b = 2, c = 3;
    int *p = &amp;c;
    int i;
    for(i=0; i&lt;8; i++){
        printf("%d, ", *(p+i) );
    }
    return 0;
}
</code></pre></div></div>

<p>编译并运行结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3, -858993460, -858993460, 2, -858993460, -858993460, 1, -858993460,
</code></pre></div></div>

<p>可以看出变量 a、b、c 并不挨着，它们中间还有其他的数据。</p>

<p>指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。
所以总结出，不要对指向普通变量的指针进行加减运算；另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。</p>

<h2 id="c中的指针数组"><strong>C中的指针数组</strong></h2>

<p>如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dataType *arrayName[length];
</code></pre></div></div>
<p>]的优先级高于*，该定义形式应该理解为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dataType *(arrayName[length]);
</code></pre></div></div>

<p>括号里面说明arrayName是一个数组，包含了length个元素，括号外面说明每个元素的类型为dataType *。</p>

<p>除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的栗子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(){
    int a = 16, b = 932, c = 100;
    //定义一个指针数组
    int *arr[3] = {&amp;a, &amp;b, &amp;c};//也可以不指定长度，直接写作 int *parr[]
    //定义一个指向指针数组的指针
    int **parr = arr;
    printf("%d, %d, %d\n", *arr[0], *arr[1], *arr[2]);
    printf("%d, %d, %d\n", **(parr+0), **(parr+1), **(parr+2));
    return 0;
}
</code></pre></div></div>

<p>编译并运行结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>16, 932, 100
16, 932, 100
</code></pre></div></div>

<p>arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。</p>

<p>parr 是指向数组 arr 的指针，确切地说是指向 arr 第一个元素的指针，它的定义形式应该理解为int * ( * parr)，括号中的 * 表示 parr 是一个指针，括号外面的int * 表示 parr 指向的数据的类型。arr 第一个元素的类型为 int *，
 所以在定义 parr 时要加两个 * （星号）（MD语法自动识别其他的格式了）。</p>

<p>第一个 printf() 语句中，arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 * 才能取得它指向的数据，也即 *arr[i] 的形式。</p>

<p>第二个 printf() 语句中，parr+i 表示第 i 个元素的地址，* (parr+i) 表示获取第 i 个元素的值（该元素是一个指针），**(parr+i) 表示获取第 i 个元素指向的数据。</p>

<p>通过指针给数组赋值，下面是一个简单的栗子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
void main(){
	int uids[5];
	//高级写法
	//int i = 0;
	//for (; i &lt; 5; i++){
	//	uids[i] = i;
	//}
	//早些版本的写法
	int* p = uids;
	printf("%#x\n",p);
	int i = 0; //i是数组元素的值
	for (; p &lt; uids + 5; p++){
		*p = i;
		i++;
	}

	getchar();
}
</code></pre></div></div>

<h2 id="c中的指针与二维数组"><strong>C中的指针与二维数组</strong></h2>

<p>二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
</code></pre></div></div>
<p>从概念上来理解，数组a 的分布如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0   1   2   3
4   5   6   7
8   9  10  11
</code></pre></div></div>

<p>但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：</p>

<p><img src="https://img-blog.csdn.net/20160821224606127" alt="这里写图片描述" /></p>

<p>C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。</p>

<p>C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0][0]、a[0][1]、a[0][2]、a[0][3]。</p>

<p>假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：
<img src="https://img-blog.csdn.net/20160821224959492" alt="这里写图片描述" /></p>

<p>为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int (*p)[4] = a;
</code></pre></div></div>
<p><strong>int *p[4]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。</strong></p>

<p><strong>int (*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>区分int *p[n]; 和int (*p)[n]; 就要看运算符的优先级了。
int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。
int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。
</code></pre></div></div>

<p>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。</p>

<p>下面我们就来实现如何使用指针 p 来访问二维数组中的每个元素。按照上面的定义：</p>

<ul>
  <li>p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。</li>
  <li>*(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点：</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(){
    int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
    int (*p)[4] = a;
    printf("%d\n", sizeof(*(p+1)));
    return 0;
}
</code></pre></div></div>

<p>编译并运行结果为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>16
</code></pre></div></div>

<p>那么，*(p+1)+1表示第 1 行第 1 个元素的地址。这个如何理解呢？（注意，这里的小细节）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  *(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、&amp; 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针。

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* ( *(p+1)+1) 表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。
</code></pre></div></div>
<p>根据上面的推论，推出以下等价关系：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a+i == p+i
a[i] == p[i] == *(a+i) == *(p+i)
a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
</code></pre></div></div>
<p>可能有点绕，不好理解，不过没关系，多看几遍，相信你是可以的。</p>

<p>栗子：
使用指针遍历二维数组</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(){
    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
    int(*p)[4];
    int i,j;
    p=a;
    for(i=0; i&lt;3; i++){
        for(j=0; j&lt;4; j++) printf("%2d  ",*(*(p+i)+j));
        printf("\n");
    }
    return 0;
}
</code></pre></div></div>
<p>编译并运行的结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0   1   2   3
 4   5   6   7
 8   9  10  11
</code></pre></div></div>

<p><strong>指针数组和二维数组指针的区别：</strong></p>

<p>指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
int (*p2)[5];  //二维数组指针，不能去掉括号
</code></pre></div></div>

<p>指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。</p>

<h2 id="c中的函数指针"><strong>C中的函数指针</strong></h2>

<p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是<strong>函数指针。</strong></p>

<p><strong>函数指针的定义形式为：</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>returnType (*pointerName)(param list);
</code></pre></div></div>
<p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。</p>

<p><strong>注意：</strong></p>
<blockquote>
  <p>( )的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(paramlist);
就成了函数原型，它表明函数的返回值类型为returnType *。</p>
</blockquote>

<p>下面写一个简单的栗子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;

int msg(char* msg,char* title){
	MessageBox(0,msg,title,0);
	return 0;
}
void main(){
	//msg();
	printf("%#x\n",msg);
	printf("%#x\n",&amp;msg);
	//函数指针
	//函数返回值类型，函数指针的名称，函数的参数列表
	int(*fun_p)(char* msg, char* title) = msg;
	fun_p("消息内容","标题");

	getchar();
}
</code></pre></div></div>

<p>编译并运行结果如下：</p>

<p><img src="http://img.blog.csdn.net/20160822141122306" alt="这里写图片描述" /></p>

<p>上面对msg函数进行了调用，fun_p是一个函数指针。</p>

<h2 id="总结"><strong>总结：</strong></h2>

<p>指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。</p>

<p>常见的指针含义：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- int *p;	    p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。
- int **p;	    p 为二级指针，指向 int * 类型的数据。
- int *p[n];	p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);
- int (*p)[n];	p 为二维数组指针。
- int *p();	    p 是一个函数，它的返回值类型为 int *。
- int (*p)();	p 是一个函数指针，指向原型为 int func() 的函数。
</code></pre></div></div>

<p>以上就是通过学习对指针的概念的理解，不能再写了，不然又是长篇大论，很难让读者看完，（我也不喜欢）。</p>

<h1 id="csdn">CSDN</h1>
<h3 id="更多系列相关文章传送门">更多系列相关文章传送门：</h3>

<ul>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52138798">C语言（一）基本数据类型</a></li>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52142794">C语言（二）有符号数和无符号数的理解</a></li>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52200178">C语言（三）字符串处理函数</a></li>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52270018">C语言（四）指针概念的理解</a></li>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52290724">C语言（五）内存的分配与释放</a></li>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52305364">C语言（六）结构体和联合体</a></li>
  <li><a href="http://blog.csdn.net/u011974987/article/details/52354074">C语言（七）文件的相关操作</a></li>
</ul>

        </article>
        <hr>

        
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
            
            
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2016/08/14/c-string-function/">C 语言字符串处理函数（三）</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/c/memory_allocation">C 语言内存分配与释放（五）</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        
  
  <!-- Gitalk 评论 start  -->
  <!-- Link Gitalk 的支持文件  -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  
  <div id="gitalk-container">
      <script type="text/javascript">
      var gitalk = new Gitalk({
  
      // gitalk的主要参数
          clientID: `3d507f3b58e98bd4c002`,
          clientSecret: `20eb5562ff08dcc12a9a61edbdb8b29f9135e302`,
          repo: `git-xuhao.github.io`,
          owner: `git-xuhao`,
          admin: [`git-xuhao`],
          id: location.pathname,
          distractionFreeMode: false

      });
      gitalk.render('gitalk-container');
  </script>
  </div>
  <!-- Gitalk end -->



    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    目录
                </div>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
             徐昊Xiho开源技术博客 
        </p>
        <p class="contact">
            <b>| 联系我</b>
            <a href="mailto:igeekho@gmail.com" title="email"><i class="fa fa-envelope-square" aria-hidden="true"></i></a> 
            <a href="https://github.com/git-xuhao" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a> 
            <a href="http://weibo.com/xuxiho" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a>    
            <a href="https://www.facebook.com/google.xu" title="Facebook"><i class="fa fa-facebook-official" aria-hidden="true"></i></a>    
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次
        </p>
      
            <span>
                © 2015-2018  Power by Jekyll </a>
            </span>
    
    </div>
</footer>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
