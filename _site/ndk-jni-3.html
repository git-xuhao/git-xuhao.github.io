<h2 id="前言">前言</h2>
<p>native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~</p>

<hr />
<h2 id="正文">正文</h2>
<p>继<a href="http://blog.csdn.net/u011974987/article/details/52743495"> Android NDK 开发（二）JNI 传递参数和返回值</a>之后。</p>

<h3 id="1访问类方法"><strong>1.访问类方法</strong></h3>
<p>初始化了Java虚拟机后，就可以开始调用Java的方法。要调用一个Java对象的方法必须经过几个步骤：</p>

<h4 id="11获取指定对象的类定义jclass"><strong>1.1获取指定对象的类定义（jclass）</strong></h4>
<p>有两种方式来获取对象的类定义：
第一种是在已知类名的情况下使用FindClass来查找对应的类。但是要注意类名并不同于平时写的Java代码，例如要得到类jni.test.Demo的定义必须调用如下代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jclass cls = (*env)-&gt;FindClass(env, "jni/test/Demo"); //把点号换成斜杠
</code></pre></div></div>
<p>第二种是通过对象直接得到其所对应的类定义：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jclass cls = (*env)-&gt; GetObjectClass(env, obj); //其中obj是要引用的对象，类型是jobject 
</code></pre></div></div>
<hr />
<!-- more -->

<h4 id="12读取要调用方法的定义"><strong>1.2读取要调用方法的定义</strong></h4>

<p>我们先来看看JNI中获取方法定义的函数：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jmethodID (JNICALL *GetMethodID)(JNIEnv *env, jclass clazz, const char *name,  
const char *sig); 


jmethodID (JNICALL *GetStaticMethodID)(JNIEnv *env, jclass class, const char  
*name, const char *sig);

</code></pre></div></div>
<p>这两个函数的区别明显都能猜到，GetStaticMethodID 是用来获取静态方法的定义，而GetMethodID 则是获取非静态的方法定义。</p>

<p>这两个函数都需要提供四个参数：</p>

<ul>
  <li>第一个参数env 就是初始化虚拟机得到的jni环境；</li>
  <li>第二个参数class 是对象的类定义，也就是第一步得到的obj；</li>
  <li>第三个参数是方法名称；</li>
  <li>第四个参数是最重要德，这个参数是方法的定义。</li>
</ul>

<p>因为我们知道Java中允许方法的多态，仅仅是通过方法名是没有办法定位到一个具体的方法，因此就需要第 四个参数来指定方法的具体定义（也就是所谓的签名）；但是怎么利用一个字符串来表示方法的具体定义呢？JDK中已经准备好一个反编译工具javap。</p>

<p>通过这个工具就可以得到类 中每个属性、方法的定义。下面就来看看jni.test.Demo的定义：</p>

<p>打开命令行窗口进入到项目目录德的bin目录下，并运行 javap -s -p jni.test.Demo 得到运行结果如下：</p>

<p><img src="http://img.blog.csdn.net/20161006210123652" alt="cmd签名" /></p>

<p>从上图中，我们看到类中每个属性和方法下面都有一段注释。注释中不包含空格的内容就是第四个参数要填的内容。基本数据的签名如下：</p>

<p><img src="http://img.blog.csdn.net/20161006213959982" alt="这里写图片描述" /></p>

<p>下面这段代码将调用accessConstructor（）的方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//访问构造方法
//使用java.util.Date产生一个当前的时间戳
JNIEXPORT jobject JNICALL Java_com_dongnaoedu_jni_JniTest_accessConstructor
(JNIEnv *env, jobject jobj){
	jclass cls = (*env)-&gt;FindClass(env, "java/util/Date");
	//jmethodID
	jmethodID constructor_mid = (*env)-&gt;GetMethodID(env, cls, "&lt;init&gt;", "()V");
	//实例化一个Date对象
	jobject date_obj = (*env)-&gt;NewObject(env, cls, constructor_mid);
	//调用getTime方法
	jmethodID mid = (*env)-&gt;GetMethodID(env, cls, "getTime", "()J");
	jlong time = (*env)-&gt;CallLongMethod(env, date_obj, mid);

	printf("\ntime:%lld\n",time);

	return date_obj;
}
</code></pre></div></div>

<p>在java 端调用</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t.accessConstructor();
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="http://img.blog.csdn.net/20161006211824441" alt="这里写图片描述" /></p>

<hr />

<h4 id="13-调用方法"><strong>1.3 调用方法</strong></h4>

<p>为了调用对象的某个方法，可以使用函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Call&lt;TYPE&gt;Method或者 CallStatic&lt;TYPE&gt;Method（访问类的静态方法），
</code></pre></div></div>

<p>&lt; TYPE&gt;根据不同的返回类型而定。这些方法都是使用可 变参数的定义，如果访问某个方法需要参数时，只需要把所有参数按照顺序填写到方法中就可以。在讲到构造函数的访问时，将演示如何访问带参数的构造函数。</p>

<hr />

<h3 id="2访问类属性"><strong>2.访问类属性</strong></h3>

<h4 id="21-获取指定对象的类jclass"><strong>2.1 获取指定对象的类（jclass）</strong></h4>

<p>这一步，与访问类方法完全一样，具体就参考上面德步骤吧~</p>

<hr />
<h4 id="22-读取类属性的定义jfieldid"><strong>2.2 读取类属性的定义（jfieldID）</strong></h4>
<p>在JNI中是这样定义获取类属性的方法的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jfieldID (JNICALL *GetFieldID)
(JNIEnv *env, jclass clazz, const char *name, const char *sig); 


jfieldID (JNICALL *GetStaticFieldID) 
(JNIEnv *env, jclass clazz, const char *name, const char *sig); 

</code></pre></div></div>

<p>这两个函数中第一个参数为JNI环境；clazz为类的定义；name为属性名称；第四个参数同样是为了表达属性的类型。前面我们使用javap工具获取类的详细定义的时候有这样两行：</p>

<p>public java.lang.String key; 
/*   Ljava/lang/String;   */</p>

<p>其中第二行注释的内容就是第四个参数要填的信息，这跟访问类方法时是相同的。</p>

<hr />
<h4 id="23-读取和设置属性值"><strong>2.3 读取和设置属性值</strong></h4>
<p>有了属性的定义要访问属性值就很容易了。有几个方法用来读取和设置类的属性，它们是：<code class="highlighter-rouge">Get&lt;TYPE&gt;Field、 Set&lt;TYPE&gt;Field、GetStatic&lt;TYPE&gt;Field、 SetStatic&lt;TYPE&gt;Field。</code>
比如读取Demo类的key属性就可以用GetFieldID，相关代码如下：</p>

<p>java调用代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//属性
public String key = "xuhao";
	//访问属性，返回修改之后的属性内容
public native String accessField();

public static void main(String[] args) {
    JniTest t = new JniTest();
	System.out.println("key修改前："+t.key);
	t.accessField();
	System.out.println("key修改后："+t.key);
		
		
}
</code></pre></div></div>
<p>本地方法实现：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//C/C++访问Java的成员

//1.访问属性
//修改属性key
JNIEXPORT jstring JNICALL Java_com_dongnaoedu_jni_JniTest_accessField
(JNIEnv *env, jobject jobj){
	//jobj是t对象，JniTest.class
	jclass cls = (*env)-&gt;GetObjectClass(env, jobj);
	//jfieldID
	//属性名称，属性签名
	jfieldID fid = (*env)-&gt;GetFieldID(env, cls, "key", "Ljava/lang/String;");	

	//xuhao &gt;&gt; super xuhao
	//获取key属性的值
	//Get&lt;Type&gt;Field
	jstring jstr = (*env)-&gt;GetObjectField(env, jobj, fid);	
	printf("jstr:%#x\n",&amp;jstr);

	//jstring -&gt; c字符串
	//isCopy 是否复制（true代表赋值，false不复制）
	char *c_str = (*env)-&gt;GetStringUTFChars(env,jstr,JNI_FALSE);
	//拼接得到新的字符串
	char text[20] = "super ";
	strcat(text,c_str);

	//c字符串 -&gt;jstring
	jstring new_jstr = (*env)-&gt;NewStringUTF(env, text);

	//修改key
	//Set&lt;Type&gt;Field
	(*env)-&gt;SetObjectField(env, jobj, fid, new_jstr);

	printf("new_jstr:%#x\n", &amp;new_jstr);

	return new_jstr;
}

</code></pre></div></div>

<p>最后调用结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key修改前：xuhao
key修改后：super xuhao
</code></pre></div></div>

<p>其他的访问方式都是按照这些套路来的，理解就可以了，今天连续赶了两篇博客，后面再抽出时间继续，坚持，坚持，再坚持！！！</p>

<hr />

<blockquote>
  <p>本文由博主辛苦整理下来的笔记； 
希望大家能够指点或提出宝贵意见，共同学习，谢谢！ 
转载请注明出处：<a href="http://blog.csdn.net/u011974987/article/details/52745362">http://blog.csdn.net/u011974987/article/details/52745362</a>
欢迎关注我的社交网站~
个人博客：<a href="http://xuhaoblog.com">xuhaoblog.com</a>
新浪微博：<a href="http://weibo.com/xuxiho">http://weibo.com/xuxiho</a>
github：<a href="https://github.com/git-xuhao">https://github.com/git-xuhao</a></p>
</blockquote>
