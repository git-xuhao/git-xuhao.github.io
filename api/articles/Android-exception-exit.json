{"title":"Android 异常退出的生命周期分析","slug":"Android-exception-exit","date":"2016-04-25T11:02:33.000Z","updated":"2017-12-17T15:34:24.000Z","comments":true,"path":"api/articles/Android-exception-exit.json","photos":[],"link":"","excerpt":"概述：典型的Activity 生命周期众所周知，就不用多说了吧；我们知道，Activity除了受用户操作所导致的正常的生命周期方法调度，还有一些异常情况，比如当资源相关的系统配置发生了改变以及系统内存不足时，Activity就可能被杀死，下面就来具体分析这两种情况。<br>","covers":["http://img.blog.csdn.net/20160425154234928"],"content":"<h2 id=\"概述：\"><a href=\"#概述：\" class=\"headerlink\" title=\"概述：\"></a><strong>概述：</strong></h2><p>典型的Activity 生命周期众所周知，就不用多说了吧；我们知道，Activity除了受用户操作所导致的正常的生命周期方法调度，还有一些异常情况，比如当资源相关的系统配置发生了改变以及系统内存不足时，Activity就可能被杀死，下面就来具体分析这两种情况。<br><a id=\"more\"></a></p>\n<h4 id=\"情况一-：-当一个activity的config改变的时候，Activity就会被杀死然后重建\"><a href=\"#情况一-：-当一个activity的config改变的时候，Activity就会被杀死然后重建\" class=\"headerlink\" title=\"情况一 ： 当一个activity的config改变的时候，Activity就会被杀死然后重建\"></a><strong>情况一 ：</strong> 当一个activity的config改变的时候，Activity就会被杀死然后重建</h4><p>而我们最熟悉的config的改变就是屏幕方向改变，系统语言改变，还有键盘可见改变了等等，系统配置发生了改变，在默认情况下，Activity就会被销毁并且重新创建，当然我们也可阻止系统重新创建我们的Activity。</p>\n<p>在默认情况下，如果我们的Activity不做特殊处理，那么当系统配置发生改变后，Activity就会被销毁并重新创建，如图所示：<br><img src=\"http://img.blog.csdn.net/20160425154234928\" alt=\"这里写图片描述\"></p>\n<p>当系统配置发生改变后，Activiy会被销毁，其onPause、onStop、onDestroy 均会被调用，同时由于Activiy 是在异常情况下终止的，系统会在onStop之前调用onSaveInstanState来保存当前Activiy的状态。<br>所以当出现异常有重要的数据需要恢复的，要在这里做一些数据的保存工作；系统只会帮我们保存视图。</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onSaveInstanceState(outState); </span><br><span class=\"line\">   <span class=\"comment\">//在这里我们可以把我们需要保存的东西给写入Bundle </span></span><br><span class=\"line\">   <span class=\"comment\">//....... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们保存的数据就可以在onCreate中来读取了：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;       </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState); </span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(savedInstanceState != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO 取出数据</span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>另一种就是一个独立的回调了：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onRestoreInstanceState</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onRestoreInstanceState(savedInstanceState); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二者的区别是：onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的判断是否为空；但是onCreate不行，这两个方法都可以进行数据恢复，但是Google建议采用onRestoreInstanceState 去恢复数据。<br>  <br></p>\n<h4 id=\"情况二：-资源内存不足导致低优先级的Activity被杀死\"><a href=\"#情况二：-资源内存不足导致低优先级的Activity被杀死\" class=\"headerlink\" title=\"情况二： 资源内存不足导致低优先级的Activity被杀死\"></a><strong>情况二：</strong> 资源内存不足导致低优先级的Activity被杀死</h4><p>Activity 按照优先级从高到低，可以分为三种：<br>（1）前台Activity——正在和用户交互的Activity，优先级最高。<br>（2）可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。<br>（3）后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。</p>\n<p>当系统内存不足时，系统就会按照上述优先级去杀死目标Activity所在的进程，并通过onSaveInstanState和onRestoreInstanceState 来存储和恢复数据。如果一个进程中没有四大组件在执行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件而独自运行在后台中，这样进程很容易被杀死。建议将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死了。</p>\n<p><strong>NOTES</strong>：虽然内容很简单，但也是博主辛苦的做了下笔记，转载请注明出处！</p>\n","categories":[{"name":"Android","slug":"Android","count":11,"path":"api/categories/Android.json"}],"tags":[{"name":"Android","slug":"Android","count":11,"path":"api/tags/Android.json"}]}