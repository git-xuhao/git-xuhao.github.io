{"name":"NDK","slug":"NDK","count":5,"postlist":[{"title":"AndroidStudio 2.2 更友好的支持NDK","slug":"ndk/jni-5","date":"2016-10-19T03:42:00.000Z","updated":"2017-12-17T15:51:17.000Z","comments":true,"path":"api/articles/ndk/jni-5.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，觉得还挺好用的，Eclipse 是一个吃内存的IDE，反正我每次打开，编写代码的时候就会卡，有时候还是死掉，已无力吐糟~~，AndroidStudio的界面更人性化，除此之外，还有更多的功能。所以决定把之前在正在eclipse上开发的一个使用NDK开发的android项目转移到AndroidStudio上，在2.2之前对C/C++ 支持不是很友好，没有语法提示，编译也不方便等问题，所以期待了的Android Studio 2.2 版本稳定版终于在前段发布，一直未来得及尝试，今天把整个过程记下来，希望能给你有所帮助。</p>\n<p>参考文献：<a href=\"https://developer.android.com/studio/projects/add-native-code.html#create-sources\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/studio/projects/add-native-code.html#create-sources</a></p>","keywords":null,"cover":"http://img.blog.csdn.net/20161025113813489","content":null,"text":"前言之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK 开发（四）JNI 中局部引用、全局引用和弱全局引用","slug":"ndk/jni-4","date":"2016-10-18T06:54:00.000Z","updated":"2017-12-17T15:52:26.000Z","comments":true,"path":"api/articles/ndk/jni-4.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃圾回收器在处理这些事情就行了，然而，从Java虚拟机创建的对象传到C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不回触发该引用所指向Java对象的垃圾回收；这些引用在JNI 中分为3种：全局引用（Global Reference）、局部引用 (Local Reference)、弱全局引用 (Week Global Reference) since JDK1.2。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"三种引用的区别\"><a href=\"#三种引用的区别\" class=\"headerlink\" title=\"三种引用的区别\"></a><strong>三种引用的区别</strong></h3><h4 id=\"1、全局引用\"><a href=\"#1、全局引用\" class=\"headerlink\" title=\"1、全局引用\"></a><strong>1、全局引用</strong></h4><p>全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部引用不同的是，没有那么多函数能够创建全局引用。能创建全局引用的函数只有 NewGlobalRef。以下例子说明了如何使用一个全局引用。</p>\n<p>java native方法：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createGlobalRef</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"function\">String <span class=\"title\">getGlobalRef</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteGlobalRef</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"前言做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK开发（三）C访问Java属性和方法","slug":"ndk/jni-3","date":"2016-10-06T14:30:31.000Z","updated":"2017-12-17T15:46:07.000Z","comments":true,"path":"api/articles/ndk/jni-3.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~</p>","keywords":null,"cover":"http://img.blog.csdn.net/20161006210123652","content":null,"text":"前言native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~正文继 Android NDK 开发（二）JNI 传递参数和返回值之后。1.访问类方法初始化了Java虚拟机后，就可","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK开发（一）JNI简介及调用流程","slug":"ndk/jni-1","date":"2016-09-23T07:28:31.000Z","updated":"2017-12-17T15:45:48.000Z","comments":true,"path":"api/articles/ndk/jni-1.json","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h3><p>前段时间学习了C、C++的一些基础知识后，了解了它们的编码风格，要想掌握NDK开发，前提是会使用JNI，下面我们开始简单的介绍吧！</p>\n<h3 id=\"JNI简介\"><a href=\"#JNI简介\" class=\"headerlink\" title=\"JNI简介\"></a><strong>JNI简介</strong></h3><p>　　JNI全称是Java Native Interface（Java本地接口），本地接口就是指用C和C++开发的接口。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。<br>　　<br>","keywords":null,"cover":"http://img.blog.csdn.net/20160921002729113","content":null,"text":"前言前段时间学习了C、C++的一些基础知识后，了解了它们的编码风格，要想掌握NDK开发，前提是会使用JNI，下面我们开始简单的介绍吧！JNI简介　　JNI全称是Java Native Interface（Java本地接口），本地接口就是指用C和C++开发的接口。从Java1.1开","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK开发（二）JNI传递参数和返回值","slug":"ndk/jni-2","date":"2016-10-06T07:28:31.000Z","updated":"2017-12-17T15:47:06.000Z","comments":true,"path":"api/articles/ndk/jni-2.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。<br>","keywords":null,"cover":"http://img.blog.csdn.net/20161006145447006","content":null,"text":"前言我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。<br>正文继JNI简介及调用流程这篇文章，我们再来实现一个非静态的","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]}]}