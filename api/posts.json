{"total":39,"pageSize":10,"pageCount":4,"data":[{"title":"基于Kotlin+Mvp+RxJava+Retrofit架构开发的短视频APP","slug":"android-kotlin-mvp","date":"2017-12-09T15:20:24.000Z","updated":"2017-12-19T13:47:35.000Z","comments":true,"path":"api/articles/android-kotlin-mvp.json","excerpt":"<h1 id=\"KotlinMvp\"><a href=\"#KotlinMvp\" class=\"headerlink\" title=\"KotlinMvp\"></a>KotlinMvp</h1><p><a href=\"http://xuhaoblog.com\"><img src=\"https://img.shields.io/badge/QQ-504105930-blue.svg\" alt=\"\"></a></p>\n<p><img src=\"http://oyp2zrwnm.bkt.clouddn.com/ic_launcher.png\" alt=\"这里写图片描述\"></p>\n<p>GitHub地址：<a href=\"https://github.com/git-xuhao/KotlinMvp\" target=\"_blank\" rel=\"noopener\">https://github.com/git-xuhao/KotlinMvp</a></p>\n<p>（开源不易，如果喜欢的话希望给个 Star 或者 Fork，谢谢！）</p>\n<p>《KotlinMvp》 是仿着“开眼Eyepetizer”之前版本并加上自己的想法，开发的一款的短视频小应用，每日为你推荐精选视频，让你大开眼界。本项目采用 Kotlin 语言编写，结合 MVP+RxJava2+Retrofit2+Glide等的架构设计，学习 Kotlin 利用空余时间开发的一款小项目，代码结构清晰有详细注释，如有任何疑问和建议请提 Issue或联系<a href=\"\"><img src=\"https://img.shields.io/badge/Gmail:-igeekho@gmail.com-blue.svg\" alt=\"\"></a><br>","keywords":null,"cover":"https://img.shields.io/badge/QQ-504105930-blue.svg","content":null,"text":"KotlinMvp [Figure] ","link":"","raw":null,"photos":[],"categories":[{"name":"开源项目","slug":"开源项目","count":1,"path":"api/categories/开源项目.json"}],"tags":[{"name":"Android","slug":"Android","count":11,"path":"api/tags/Android.json"},{"name":"Kotlin","slug":"Kotlin","count":1,"path":"api/tags/Kotlin.json"},{"name":"MVP","slug":"MVP","count":1,"path":"api/tags/MVP.json"}]},{"title":"Android 中获取当前时区和语言","slug":"Android-getdate-language","date":"2016-10-20T10:05:00.000Z","updated":"2017-12-17T16:21:26.000Z","comments":true,"path":"api/articles/Android-getdate-language.json","excerpt":"<p>国际化需求，要访问当地的时区和语言，作为参数上传服务器处理一些业务，Android手机中如果想以GMT形式（GMT+08:00）得到当前时区，如下的工具类做个记录：<br>","keywords":null,"cover":null,"content":null,"text":"国际化需求，要访问当地的时区和语言，作为参数上传服务器处理一些业务，Android手机中如果想以GMT形式（GMT+08:00）得到当前时区，如下的工具类做个记录：<br><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br","link":"","raw":null,"photos":[],"categories":[{"name":"Android","slug":"Android","count":11,"path":"api/categories/Android.json"}],"tags":[{"name":"Android","slug":"Android","count":11,"path":"api/tags/Android.json"}]},{"title":"AndroidStudio 2.2 更友好的支持NDK","slug":"ndk/jni-5","date":"2016-10-19T03:42:00.000Z","updated":"2017-12-17T15:51:17.000Z","comments":true,"path":"api/articles/ndk/jni-5.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><strong>前言</strong></h2><p>之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，觉得还挺好用的，Eclipse 是一个吃内存的IDE，反正我每次打开，编写代码的时候就会卡，有时候还是死掉，已无力吐糟~~，AndroidStudio的界面更人性化，除此之外，还有更多的功能。所以决定把之前在正在eclipse上开发的一个使用NDK开发的android项目转移到AndroidStudio上，在2.2之前对C/C++ 支持不是很友好，没有语法提示，编译也不方便等问题，所以期待了的Android Studio 2.2 版本稳定版终于在前段发布，一直未来得及尝试，今天把整个过程记下来，希望能给你有所帮助。</p>\n<p>参考文献：<a href=\"https://developer.android.com/studio/projects/add-native-code.html#create-sources\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/studio/projects/add-native-code.html#create-sources</a></p>","keywords":null,"cover":"http://img.blog.csdn.net/20161025113813489","content":null,"text":"前言之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK 开发（四）JNI 中局部引用、全局引用和弱全局引用","slug":"ndk/jni-4","date":"2016-10-18T06:54:00.000Z","updated":"2017-12-17T15:52:26.000Z","comments":true,"path":"api/articles/ndk/jni-4.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃圾回收器在处理这些事情就行了，然而，从Java虚拟机创建的对象传到C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不回触发该引用所指向Java对象的垃圾回收；这些引用在JNI 中分为3种：全局引用（Global Reference）、局部引用 (Local Reference)、弱全局引用 (Week Global Reference) since JDK1.2。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"三种引用的区别\"><a href=\"#三种引用的区别\" class=\"headerlink\" title=\"三种引用的区别\"></a><strong>三种引用的区别</strong></h3><h4 id=\"1、全局引用\"><a href=\"#1、全局引用\" class=\"headerlink\" title=\"1、全局引用\"></a><strong>1、全局引用</strong></h4><p>全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部引用不同的是，没有那么多函数能够创建全局引用。能创建全局引用的函数只有 NewGlobalRef。以下例子说明了如何使用一个全局引用。</p>\n<p>java native方法：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createGlobalRef</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"function\">String <span class=\"title\">getGlobalRef</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteGlobalRef</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"前言做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK开发（三）C访问Java属性和方法","slug":"ndk/jni-3","date":"2016-10-06T14:30:31.000Z","updated":"2017-12-17T15:46:07.000Z","comments":true,"path":"api/articles/ndk/jni-3.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~</p>","keywords":null,"cover":"http://img.blog.csdn.net/20161006210123652","content":null,"text":"前言native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~正文继 Android NDK 开发（二）JNI 传递参数和返回值之后。1.访问类方法初始化了Java虚拟机后，就可","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"NDK开发（二）JNI传递参数和返回值","slug":"ndk/jni-2","date":"2016-10-06T07:28:31.000Z","updated":"2017-12-17T15:47:06.000Z","comments":true,"path":"api/articles/ndk/jni-2.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。<br>","keywords":null,"cover":"http://img.blog.csdn.net/20161006145447006","content":null,"text":"前言我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。<br>正文继JNI简介及调用流程这篇文章，我们再来实现一个非静态的","link":"","raw":null,"photos":[],"categories":[{"name":"NDK","slug":"NDK","count":5,"path":"api/categories/NDK.json"}],"tags":[{"name":"NDK","slug":"NDK","count":5,"path":"api/tags/NDK.json"},{"name":"JNI","slug":"JNI","count":5,"path":"api/tags/JNI.json"}]},{"title":"Shell 脚本基础学习之函数（五）","slug":"linux/shell-script-05","date":"2016-10-01T10:10:31.000Z","updated":"2017-12-17T16:07:31.000Z","comments":true,"path":"api/articles/linux/shell-script-05.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Linux shell脚本基础学习我们这里就差不多讲完了，函数相信大家都不陌生吧，直接入正题吧~</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p><a href=\"http://xuhaoblog.com/linux/shell-script-04.html\">继上篇博客之后</a></p>\n<h4 id=\"shell-函数\"><a href=\"#shell-函数\" class=\"headerlink\" title=\"shell 函数\"></a><strong>shell 函数</strong></h4><p>Linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。<br>shell 中函数的定义格式如下：</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span><span class=\"number\">_n</span>ame () &#123;</span><br><span class=\"line\">    list <span class=\"keyword\">of</span> commands</span><br><span class=\"line\">    [ <span class=\"keyword\">return</span> <span class=\"keyword\">value</span> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":"http://img.blog.csdn.net/20161001175800334","content":null,"text":"前言Linux shell脚本基础学习我们这里就差不多讲完了，函数相信大家都不陌生吧，直接入正题吧~正文继上篇博客之后shell 函数Linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。<br>shell 中函数的定义格式如下：1<br>2<br>3<b","link":"","raw":null,"photos":[],"categories":[{"name":"Shell","slug":"Shell","count":5,"path":"api/categories/Shell.json"}],"tags":[{"name":"Shell","slug":"Shell","count":5,"path":"api/tags/Shell.json"},{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"}]},{"title":"Shell 输入/输出重定向（四）","slug":"linux/shell-script-04","date":"2016-10-01T04:23:31.000Z","updated":"2017-12-17T16:07:59.000Z","comments":true,"path":"api/articles/linux/shell-script-04.json","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><font size=\"4\">原本计划国庆节第一天假期休息一天，但是想想自己还有很多事情没有完成，就立马打开电脑，开始干活了。打算这7天的假期好好整理下之前学的知识和巩固练习，充实每一天，好了入正题，Linux shell脚本基础前面我们在介绍Linux shell脚本的控制流程时，还有一部分内容没讲就是有关here document的内容这里继续，Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</font></p>\n<p>原文链接请标明：<br><a href=\"http://xuhaoblog.com/linux/shell-script-04.html\">http://xuhaoblog.com/linux/shell-script-04.html</a><br>本文出自:【<a href=\"http://xuhaoblog.com\">stromxu</a>的博客】</p>","keywords":null,"cover":"http://img.blog.csdn.net/20161001150059408","content":null,"text":"前言原本计划国庆节第一天假期休息一天，但是想想自己还有很多事情没有完成，就立马打开电脑，开始干活了。打算这7天的假期好好整理下之前学的知识和巩固练习，充实每一天，好了入正题，Linux shell脚本基础前面我们在介绍Linux shell脚本的控制流程时，还有一部分内容没讲就是","link":"","raw":null,"photos":[],"categories":[{"name":"Shell","slug":"Shell","count":5,"path":"api/categories/Shell.json"}],"tags":[{"name":"Shell","slug":"Shell","count":5,"path":"api/tags/Shell.json"},{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"}]},{"title":"Shell 流程控制Loop和引号（三）","slug":"linux/shell-script-03","date":"2016-09-30T03:06:31.000Z","updated":"2017-12-17T16:07:26.000Z","comments":true,"path":"api/articles/linux/shell-script-03.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Linux shell 脚本基础学习第三篇；<br><a href=\"http://xuhaoblog.com/linux/shell-script-02.html\">上一篇</a>Liunx shell  脚本基础学习中，我们讲到了Linux shell 脚本中控制流程的if、select、case，这里接着介绍Linux shell 脚本控制流程的loop和引导，控制流程这部分内容较多，还有一部分是关于here document。<br>","keywords":null,"cover":"http://img.blog.csdn.net/20160930140550992","content":null,"text":"前言Linux shell 脚本基础学习第三篇；<br>上一篇Liunx shell  脚本基础学习中，我们讲到了Linux shell 脚本中控制流程的if、select、case，这里接着介绍Linux shell 脚本控制流程的loop和引导，控制流程这部分内容较多，还有一","link":"","raw":null,"photos":[],"categories":[{"name":"Shell","slug":"Shell","count":5,"path":"api/categories/Shell.json"}],"tags":[{"name":"Shell","slug":"Shell","count":5,"path":"api/tags/Shell.json"},{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"}]},{"title":"Shell 命令和流程控制（二）","slug":"linux/shell-script-02","date":"2016-09-29T08:06:31.000Z","updated":"2017-12-17T16:07:20.000Z","comments":true,"path":"api/articles/linux/shell-script-02.json","excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Linxu shell 脚本基础这里介绍到第二篇，详细介绍shell 命令和流程控制，这部分介绍三类命令，在学习时大家应该加以比较学习。<br>Linux shell脚本基础课程<a href=\"http://xuhaoblog.com/linux/shell-script-01.html\">前面一篇</a>介绍的都是语法基础的开头、注释、变量和 环境变量，这里将介绍shell命令和控制流程的第一部分，在shell脚本中可以使用三类命令，而控制流程就放在下一讲吧。<br>","keywords":null,"cover":null,"content":null,"text":"前言Linxu shell 脚本基础这里介绍到第二篇，详细介绍shell 命令和流程控制，这部分介绍三类命令，在学习时大家应该加以比较学习。<br>Linux shell脚本基础课程前面一篇介绍的都是语法基础的开头、注释、变量和 环境变量，这里将介绍shell命令和控制流程的第一","link":"","raw":null,"photos":[],"categories":[{"name":"Shell","slug":"Shell","count":5,"path":"api/categories/Shell.json"}],"tags":[{"name":"Shell","slug":"Shell","count":5,"path":"api/tags/Shell.json"},{"name":"Linux","slug":"Linux","count":8,"path":"api/tags/Linux.json"}]}]}