<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>基于Kotlin+Mvp+RxJava+Retrofit架构开发的短视频APP</title>
      <link href="/2017/12/09/android-kotlin-mvp/"/>
      <url>/2017/12/09/android-kotlin-mvp/</url>
      <content type="html"><![CDATA[<h1 id="KotlinMvp"><a href="#KotlinMvp" class="headerlink" title="KotlinMvp"></a>KotlinMvp</h1><p><a href="http://xuhaoblog.com"><img src="https://img.shields.io/badge/QQ-504105930-blue.svg" alt=""></a></p><p><img src="http://oyp2zrwnm.bkt.clouddn.com/ic_launcher.png" alt="这里写图片描述"></p><p>GitHub地址：<a href="https://github.com/git-xuhao/KotlinMvp" target="_blank" rel="noopener">https://github.com/git-xuhao/KotlinMvp</a></p><p>（开源不易，如果喜欢的话希望给个 Star 或者 Fork，谢谢！）</p><p>《KotlinMvp》 是仿着“开眼Eyepetizer”之前版本并加上自己的想法，开发的一款的短视频小应用，每日为你推荐精选视频，让你大开眼界。本项目采用 Kotlin 语言编写，结合 MVP+RxJava2+Retrofit2+Glide等的架构设计，学习 Kotlin 利用空余时间开发的一款小项目，代码结构清晰有详细注释，如有任何疑问和建议请提 Issue或联系<a href=""><img src="https://img.shields.io/badge/Gmail:-igeekho@gmail.com-blue.svg" alt=""></a><br><a id="more"></a></p><h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h2><p><img src="http://oyp2zrwnm.bkt.clouddn.com/pt2017_12_09_10_27_10.jpg" alt=""></p><h2 id="下载体验"><a href="#下载体验" class="headerlink" title="下载体验"></a>下载体验</h2><p>点击<a href="https://fir.im/kotlinmvp" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Download-apk-green.svg" alt=""></a> 或者扫描下方二维码</p><p><img src="http://oyp2zrwnm.bkt.clouddn.com/QR-code-kotlin-mvp.png" width="250" height="250" alt="图片名称" align="center"></p><h2 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h2><p>主要使用的第三方开源框架有：</p><ul><li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li><li><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">RxAndroid</a></li><li><a href="https://github.com/square/retrofit" target="_blank" rel="noopener">Retrofit</a></li><li><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a></li><li><a href="https://github.com/orhanobut/logger" target="_blank" rel="noopener">Logger</a></li><li><a href="https://github.com/H07000223/FlycoTabLayout" target="_blank" rel="noopener">FlycoTabLayout</a></li><li><a href="https://github.com/google/flexbox-layout" target="_blank" rel="noopener">Flexbox-layout</a></li><li><a href="https://github.com/mmin18/RealtimeBlurView" target="_blank" rel="noopener">RealtimeBlurView</a></li><li><a href="https://github.com/scwang90/SmartRefreshLayout" target="_blank" rel="noopener">SmartRefreshLayout</a></li><li><a href="https://github.com/bingoogolapple/BGABanner-Android" target="_blank" rel="noopener">BGABanner-Android</a></li><li><a href="https://github.com/CarGuo/GSYVideoPlayer" target="_blank" rel="noopener">GSYVideoPlayer</a></li></ul><p>模块说明：</p><ul><li><strong>每日精选：</strong>首页采用下拉刷新+RecyclerView 实现，Banner展示每日精选推荐的视频，监听 RecyclerView 的滑动事件，实现 TitleBar 的隐藏显示功能，底部菜单采用高斯模糊的半透明效果，使整个 APP 风格更加清爽。</li><li><strong>发现：</strong> 包括关注和分类模块，关注是推荐的作者上传的视频，分类包括时尚、运动、创意、广告、音乐、旅行、生活、记录、开胃、游戏、萌宠、动画、综艺、搞笑等可自由选择想查看的类型视频。</li><li><strong>热门：</strong> 热门排行榜包括周排行、月排行、总排行的视频列表。</li><li><strong>搜索：</strong> 根据关键字搜索榜你找到感兴趣的视频。</li><li><strong>我的：</strong> 个人主页的相关介绍。</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p><strong>v1.0</strong></p><ul><li>初始化版本，主要功能已经完成。</li></ul><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul><li>Email: igeekho@gmail.com</li><li>Home: <a href="https://xuhaoblog.com">https://xuhaoblog.com</a></li><li>CSDN:<a href="http://blog.csdn.net/u011974987" target="_blank" rel="noopener">http://blog.csdn.net/u011974987</a></li><li>简书: <a href="http://www.jianshu.com/u/25bc3e1e7595" target="_blank" rel="noopener">http://www.jianshu.com/u/25bc3e1e7595</a></li></ul><h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><ul><li>感谢所有优秀的开源项目</li><li><a href="https://github.com/kaikaixue/Eyepetizer" target="_blank" rel="noopener">Eyepetizer</a> ：最初是看了这个项目才开始做的，学了不少东西，写出了我自己的代码风格</li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>项目中的 API 均来自开眼视频，纯属学习交流使用，不得用于商业用途！</strong></p><h2 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2017 Xiho</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the "License");</span><br><span class="line">you may not <span class="keyword">use</span> this <span class="keyword">file</span> <span class="keyword">except</span> <span class="keyword">in</span> compliance <span class="keyword">with</span> the License.</span><br><span class="line">You may obtain a copy <span class="keyword">of</span> the License <span class="keyword">at</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">http</span>://www.apache.org/licenses/LICENSE<span class="number">-2.0</span></span><br><span class="line"></span><br><span class="line">Unless <span class="keyword">required</span> <span class="keyword">by</span> applicable law <span class="keyword">or</span> agreed <span class="keyword">to</span> <span class="keyword">in</span> writing, software</span><br><span class="line"><span class="keyword">distributed</span> <span class="keyword">under</span> the License <span class="keyword">is</span> <span class="keyword">distributed</span> <span class="keyword">on</span> an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line"><span class="keyword">WITHOUT</span> WARRANTIES <span class="keyword">OR</span> CONDITIONS <span class="keyword">OF</span> <span class="keyword">ANY</span> KIND, either express <span class="keyword">or</span> implied.</span><br><span class="line">See the License <span class="keyword">for</span> the specific <span class="keyword">language</span> governing permissions <span class="keyword">and</span></span><br><span class="line">limitations <span class="keyword">under</span> the License.</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> MVP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中获取当前时区和语言</title>
      <link href="/2016/10/20/Android-getdate-language/"/>
      <url>/2016/10/20/Android-getdate-language/</url>
      <content type="html"><![CDATA[<p>国际化需求，要访问当地的时区和语言，作为参数上传服务器处理一些业务，Android手机中如果想以GMT形式（GMT+08:00）得到当前时区，如下的工具类做个记录：<br><a id="more"></a><br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时区语言工具类</span></span><br><span class="line"><span class="comment"> * @author Xiho</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class I18NUtils &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前时区</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">String</span> getCurrentTimeZone() &#123;</span><br><span class="line">TimeZone tz = TimeZone.getDefault();</span><br><span class="line"><span class="built_in">String</span> strTz = tz.getDisplayName(<span class="literal">false</span>, TimeZone.SHORT);</span><br><span class="line"><span class="keyword">return</span> strTz;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前系统语言格式</span></span><br><span class="line"><span class="comment"> * @param mContext</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">String</span> getCurrentLanguage(Context mContext)&#123;</span><br><span class="line">    <span class="built_in">Locale</span> <span class="built_in">locale</span> =mContext.getResources().getConfiguration().<span class="built_in">locale</span>;</span><br><span class="line">        <span class="built_in">String</span> language=<span class="built_in">locale</span>.getLanguage();</span><br><span class="line">        <span class="built_in">String</span> country = <span class="built_in">locale</span>.getCountry();</span><br><span class="line">        <span class="built_in">String</span> lc=language+<span class="string">"_"</span>+country;</span><br><span class="line">        <span class="keyword">return</span> lc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AndroidStudio 2.2 更友好的支持NDK</title>
      <link href="/2016/10/19/ndk/jni-5/"/>
      <url>/2016/10/19/ndk/jni-5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前一直在用Eclipse 做开发，直到今年年初才将项目迁移到Google 推荐的AndroidStudio上面，毕竟这是一个趋势，可谁知道事情根本没有我想的那么简单，这期间遇到了N多坑，我想这些坑可能大家也有可能遇到，不在这里详细叙述。最终一个个问题的去解决，走完了这些坑，觉得还挺好用的，Eclipse 是一个吃内存的IDE，反正我每次打开，编写代码的时候就会卡，有时候还是死掉，已无力吐糟~~，AndroidStudio的界面更人性化，除此之外，还有更多的功能。所以决定把之前在正在eclipse上开发的一个使用NDK开发的android项目转移到AndroidStudio上，在2.2之前对C/C++ 支持不是很友好，没有语法提示，编译也不方便等问题，所以期待了的Android Studio 2.2 版本稳定版终于在前段发布，一直未来得及尝试，今天把整个过程记下来，希望能给你有所帮助。</p><p>参考文献：<a href="https://developer.android.com/studio/projects/add-native-code.html#create-sources" target="_blank" rel="noopener">https://developer.android.com/studio/projects/add-native-code.html#create-sources</a></p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><h3 id="1-下载开发工具和NDK（windows10-64位环境）"><a href="#1-下载开发工具和NDK（windows10-64位环境）" class="headerlink" title="1. 下载开发工具和NDK（windows10 64位环境）"></a><strong>1. 下载开发工具和NDK（windows10 64位环境）</strong></h3><blockquote><p>Android Studio 2.2 的NDK开发支持 CMake和ndk-build两种方式，默认的是CMake编译的，编译和调试需要下载安装以下组件：</p></blockquote><ul><li><p><strong>AndroidStudio</strong> 官网下载地址：</p><p> <a href="https://developer.android.com/studio/index.html#win-bundle" target="_blank" rel="noopener"> Android Studio 2.2 </a>（需要梯子）</p><p>推荐一个国内的镜像网站：</p><p> <a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn</a> （身为开发者都应该知道，O(∩_∩)O）</p><p>下载最新版的 <strong>Android Studio 2.2</strong> ：</p><p><a href="https://dl.google.com/dl/android/studio/install/2.2.2.0/android-studio-bundle-145.3360264-windows.exe" target="_blank" rel="noopener">Download （点击下载） </a></p></li><li><p><strong>下载NDK：</strong><a href="https://dl.google.com/android/repository/android-ndk-r12b-windows-x86_64.zip" target="_blank" rel="noopener">android-ndk-r12b-windows-x86_64</a></p></li><li><p><strong>CMake：</strong> Android Studio 默认使用 CMake 编译原生库，如果你只打算用ndk-build来编译的话，你就不需要这个组件。</p></li><li><strong>LLDB：</strong> 使用它来调试本地代码。</li></ul><blockquote><p><strong>注意：</strong>要在 Android Studio 中使用 CMake 或者 ndk-build，你需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。</p></blockquote><p><strong>你可以使用 SDK Manager 来安装上述组件：</strong></p><ol><li><p>已安装的软件包如有更新，其旁边的复选框中会显示短划线 <img src="http://img.blog.csdn.net/20161025113813489" alt="这里写图片描述"></p></li><li><p>打开一个项目，从菜单栏中选择 <strong>Tools &gt; Android &gt; SDK Manager</strong> 。</p></li><li><p>点击 <strong>SDK Tools</strong> 选项卡。</p></li><li><p>勾选 <strong>LLDB</strong>，<strong>CMake</strong> 和 <strong>NDK</strong> 。如图一：</p></li></ol><p><img src="http://img.blog.csdn.net/20161025115020495" alt="这里写图片描述"></p><p>点击 Apply ，然后点击 OK 。</p><p>当安装完成后，点击 Finish ，然后点击 OK 。</p><hr><h3 id="创建支持Native-Code新项目"><a href="#创建支持Native-Code新项目" class="headerlink" title="创建支持Native Code新项目"></a><strong>创建支持Native Code新项目</strong></h3><p>创建一个支持 native code 的项目和创建普通的 Android studio 工程很像。但是有几点需要留意的地方：</p><ol><li><p>在 Configure your new project 选项中，勾选 Include C++ Support 选项。</p></li><li><p>点击 Next，后面的流程和创建普通的 Android studio 工程一样。</p></li><li><p>在 Customize C++ Support 选项卡中。你有下面几种方式来自定义你的项目：</p><ul><li><p>C++ Standard ：点击下拉框，可以选择标准 C++，或者选择默认 CMake 设置的 Toolchain Default 选项。</p></li><li><p>Exceptions Support ：如果你想使用有关 C++ 异常处理的支持，就勾选它。勾选之后，Android Studio 会在 module 层的 build.gradle 文件中的 cppFlags 中添加 -fexcetions 标志。</p></li><li><p>Runtime Type Information Support ：如果你想支持 RTTI，那么就勾选它。勾选之后，Android Studio 会在 module 层的 build.gradle 文件中的 cppFlags 中添加 -frtti 标志。</p></li></ul></li><li><p>点击 “Finish”。</p></li></ol><p>当 Android Studio 完成新项目创建后，打开 Project 面板，选择 Android 视图。Android Studio 会添加 cpp 和 External Build Files 文件夹。</p><p><img src="http://img.blog.csdn.net/20161025120041509" alt="这里写图片描述"></p><ol><li><p><strong>cpp</strong> 文件夹存放你所有 native code 的地方，包括源码，头文件，预编译项目等。对于新项目，Android Studio 创建了一个 C++ 模板文件： <strong>native-lib.cpp</strong> ，并且将该文件放到了你的 app 模块的 <strong>src/main/cpp/</strong> 目录下。这份模板代码提供了一个简答的 C++ 函数： <strong>stringFromJNI()</strong> ，该函数返回一个字符串：<strong>”Hello from C++”</strong>。</p></li><li><p><strong>External Build Files</strong> 文件夹是存放 <strong>CMake</strong> 或 <strong>ndk-build</strong> 构建脚本的地方。有点类似于 build.gradle 文件告诉 Gradle 如何编译你的 APP 一样，CMake 和 ndk-build 也需要一个脚本来告知如何编译你的 native library。对于一个新的项目，Android Studio 创建了一个 CMake 脚本： <strong>CMakeLists.txt</strong> ，并且将其放到了你的 module 的根目录下。</p></li></ol><hr><h3 id="编译运行示例-APP"><a href="#编译运行示例-APP" class="headerlink" title="编译运行示例 APP"></a><strong>编译运行示例 APP</strong></h3><p>当你点击 Run 按钮，Android Studio 会编译并启动一个 APP ，然后在 APP 中显示一段文字”Hello from C++”。</p><p><img src="http://img.blog.csdn.net/20161025120804299" alt="这里写图片描述"></p><p>从编译到运行示例 APP 的流程简单归纳如下：</p><ol><li><p>Gradle 调用外部构建脚本，也就是 CMakeLists.txt 。</p></li><li><p>CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是 native-lib.cpp ，并将编译后的产物扔进共享对象库中，并将其命名为 libnative-lib.so ，然后 Gradle 将其打包到 APK 中。</p></li><li><p>在运行期间，APP 的 MainActivity 会调用 System.loadLibrary() 方法，加载 native library。而这个库的原生函数， stringFromJNI() ，就可以为 APP 所用了。</p></li><li><p>MainActivity.onCreate() 方法会调用 stringFromJNI() ，然后返回 “Hello from C++”，并更新 TextView 的显示。</p></li></ol><blockquote><p>注意： Instant Run 并不兼容使用了 native code 的项目。Android Studio 会自动禁止 Instant<br>Run 功能。</p></blockquote><p>如果你想验证一下 Gradle 是否将 native library 在APK中是否存在，你可以使用 <strong>APK Analyzer</strong>:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 选择 Build &gt; Analyze APK 。</span><br><span class="line"><span class="number">2</span>. 从 app/build/outputs/apk/ 路径中选择 APK，并点击 OK 。</span><br><span class="line"><span class="number">3</span>. 如下图，在 APK Analyzer 窗口中，选择 <span class="class"><span class="keyword">lib</span>/&lt;<span class="title">ABI</span>&gt;/ ，你就可以看见 <span class="title">libnative</span>-<span class="title">lib</span>.<span class="title">so</span> 。</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20161025122320133" alt="这里写图片描述"></p><hr><h3 id="将-C-C-代码添加到现有的项目中"><a href="#将-C-C-代码添加到现有的项目中" class="headerlink" title="将 C/C++ 代码添加到现有的项目中"></a><strong>将 C/C++ 代码添加到现有的项目中</strong></h3><p>如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤：</p><ol><li><p>创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。</p></li><li><p>创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。</p></li><li><p>将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。</p></li></ol><p>一旦你配置好了你的项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击 Run 按钮，就可以编译运行你的 APP 了。</p><hr><h3 id="创建新的-native-source-文件"><a href="#创建新的-native-source-文件" class="headerlink" title="创建新的 native source 文件"></a><strong>创建新的 native source 文件</strong></h3><p>请按照下面的方法来创建一个 cpp/ 文件夹和源文件（native source files）：</p><ol><li><p>打开IDE左边的 Project 面板，选择 Project 视图。</p></li><li><p>找到你项目的 module &gt; src 目录，右键点击 main 文件夹，选择 New &gt; Directory 。</p></li><li><p>输入文件夹的名字（比如 cpp），然后点击 OK 。</p></li><li><p>右键点击刚才创建好的文件夹，选择 New &gt; C/C++ Source File 。</p></li><li><p>输入文件名，比如 native-lib 。</p></li><li><p>在 Type 菜单下拉选项中，选择源文件的扩展后缀名，比如 .cpp 。</p></li><li><p>如果你也想创建一个头文件，点击 Create an associated header 选项框。</p></li><li><p>点击 OK 。</p></li></ol><hr><h3 id="创建-CMake-构建脚本"><a href="#创建-CMake-构建脚本" class="headerlink" title="创建 CMake 构建脚本"></a><strong>创建 CMake 构建脚本</strong></h3><p>如果没有一个 CMake 构建脚本，你需要自己手动创建一个，并添加一些合适的 CMake 命令。CMake 构建脚本是一个空白的文本文档（后缀为 .txt 的文件），名字必须为 CMakeLists.txt 。</p><blockquote><p><strong>注意：</strong>如果你的项目使用了 ndk-build，你就不需要创建 CMake 构建脚本，只需要提供一个路径链，将你的 Android.mk<br>文件链接到 Gradle 中即可。</p></blockquote><p>将一个空白的文本文档变成一个 CMake 构建脚本，你需要这么做：</p><ol><li><p>打开 IDE 左边的 Project 面板，选择 Project 视图。</p></li><li><p>在你的 module 根目录下，右键，选择 New &gt; File 。</p></li><li><p>输入 “CMakeLists.txt” 作为文件名，并点击 OK 。</p></li></ol><p>现在，你可以添加 CMake 命令来配置你的构建脚本了。为了让 CMake 将源代码（native source code）编译成 native library。需要在编译文件中添加 <strong>cmake_minimum_required()</strong> 和 <strong>add_library()</strong> 命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置建立你的本地库所需的CMake的最低版本。</span></span><br><span class="line"><span class="comment"># 这为了确保某些功能在你构建的时候是可用的。</span></span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库名</span></span><br><span class="line"><span class="comment"># 并提供源代码的相对路径. </span></span><br><span class="line"><span class="comment"># 你可以通过add.library()命令定义多个库,CMake会去构建他们，</span></span><br><span class="line"><span class="comment"># 当你构建App 的时候，Gradle 会自动把库打包到你的apk 中</span></span><br><span class="line"></span><br><span class="line">add_library( <span class="comment"># Specifies the name of the library.</span></span><br><span class="line">             native-<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">            src/main/cpp/native-<span class="class"><span class="keyword">lib</span>.<span class="title">cpp</span> )</span></span><br></pre></td></tr></table></figure><p>当你使用 <strong>add_library()</strong> ，将一个源文件（source file）或库添加到你的 CMake 构建脚本，同步你的项目，然后你会发现 Android studio 将关联的头文件也显示了处理。然而，为了让 CMake 在编译时期能定位到你的头文件，你需要在 CMake 构建脚本中添加 <strong>include_directories()</strong> 命令，并指定头文件路径：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies a path to native header files.</span></span><br><span class="line"><span class="keyword">include_directories</span>(src/main/cpp/<span class="keyword">include</span>/)</span><br></pre></td></tr></table></figure><p>CMake的使用命名库的文件的约定下面的形式：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">lib</span>*<span class="title">library</span>-<span class="title">name</span>*.<span class="title">so</span></span></span><br></pre></td></tr></table></figure><p>例如 ，如果你在构建脚本中，将 library 命名为 “native-lib”，那么 CMake 会创建叫 libnative-lib.so 的文件。但是，当你将 library 加载到 Java 代码中的时候， 你需要使用在 CMake 中指定的名称：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        System.loadLibrary(“native-<span class="class"><span class="keyword">lib</span>”);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>如果你将 CMake 脚本里面的 library 重命名了，或者移除了。你需要清理一下你的工程。在 IDE 的菜单栏中选择 Build &gt; Clean Project 。</p></blockquote><p>Android Studio 会在 Project 面板中的 cpp 文件夹中自动添加源文件和头文件。你可以多次使用 add_library() 命令，来添加额外的 library。</p><h4 id="添加-NDK-APIs"><a href="#添加-NDK-APIs" class="headerlink" title="添加 NDK APIs"></a><strong>添加 NDK APIs</strong></h4><p>Android NDK 提供了一些有用的 native APIs。将 NDK librarys 添加到 CMakeLists.txt 脚本文件中，就可以使用这些 API 了。</p><p>预编译的 NDK librarys 已经存在在 Android 平台中了，所以你不需要编译它们，或者是将其打包到你的 APK 中。因为这些 NDK librarys 已经是 CMake 搜索路径的一部分，你甚至不需要提供你本地安装的 NDK 路径。你只需要向 CMake 提供你想使用的 library 名字。</p><p>将 <strong>find_library()</strong> 命令添加到你的 CMake 构建脚本中，这样就可以定位 NDK library 的位置，并将其位置存储在一个变量之中。你可以在构建脚本的其他地方使用这个变量，来代指 NDK library。下面的示例代码将 Android-specific log support library 的位置存储到变量 log-lib 中：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_library( <span class="comment"># Defines the name of the path variable that stores the</span></span><br><span class="line">              <span class="comment"># location of the NDK library.</span></span><br><span class="line">              log-<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># CMake needs to locate.</span></span><br><span class="line">              log )</span><br></pre></td></tr></table></figure><p>NDK 同样也包含一些只包含源码的 library，这些就需要你去编译，然后链接到你的本地库（native library）。你可以在 CMake 构建脚本中使用 add_library() 命令将源码编译进本地库。这时就需要提供你的本地 NDK 安装路径，通常将该路径保存在 ANDROID_NDK 变量中，这样 Android Studio 可以自动为你定义。</p><p>下面的命令告诉 CMake 去构建 android_native_app_glue.c ，这个命令可以管理 NativeActivity 的生命周期以及点击输入，并将其导入静态库中，然后将其链接至 native-lib ：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_library( app-glue</span><br><span class="line">             STATIC</span><br><span class="line">             $&#123;ANDROID_NDK&#125;/sources/android/native_app_glue/android_native_app_glue.c )</span><br><span class="line"></span><br><span class="line"><span class="comment"># You need to link static libraries against your shared native library.</span></span><br><span class="line">target_link_libraries( native-<span class="class"><span class="keyword">lib</span> <span class="title">app</span>-<span class="title">glue</span> $&#123;<span class="title">log</span>-<span class="title">lib</span>&#125; )</span></span><br></pre></td></tr></table></figure><h4 id="添加其他的预编译库"><a href="#添加其他的预编译库" class="headerlink" title="添加其他的预编译库"></a><strong>添加其他的预编译库</strong></h4><p>添加预编译库和添加本地库（native library）类似。由于预编译库是已经构建好的，你想就要使用 IMPORTED 标志去告诉 CMake ，你只需要将其导入到你的项目中即可：</p><p>add_library( imported-lib<br>             SHARED<br>             IMPORTED )<br>然后你需要使用 set_target_properties() 命令去指定库的路径，就像下面的代码那样。</p><p>一些库会根据不同的 CPU 使用不同的包，或者是 Application Binary Interfaces(ABI) ，并且将他们归类到不同的目录中。这样做的好处是，可以充分发挥特定的 CPU 架构。你可以使用 ANDROID_ABI 路径变量，将多个 ABI 版本的库添加到你的 CMake 构建脚本中。这个变量使用了一些 NDK 默认支持的 ABI，以及一些需要手动配置到 Gradle 的 ABI，比如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_library(...)</span><br><span class="line">set_target_properties( ＃指定目标库。</span><br><span class="line">                       imported-<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line">                       ＃指定要定义的参数。</span><br><span class="line">                       PROPERTIES IMPORTED_LOCATION</span><br><span class="line"></span><br><span class="line">                       ＃提供的路径，你要导入的库。</span><br><span class="line">                       imported-<span class="class"><span class="keyword">lib</span>/<span class="title">src</span>/$&#123;<span class="title">ANDROID_ABI</span>&#125;/<span class="title">libimported</span>-<span class="title">lib</span>.<span class="title">so</span> )</span></span><br></pre></td></tr></table></figure><p>为了让 CMake 在编译时期能找到你的头文件，你需要使用 include_directories() 命令，并且将你的头文件地址传进去：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories( imported-<span class="class"><span class="keyword">lib</span>/<span class="title">include</span>/ )</span></span><br></pre></td></tr></table></figure><p>在 CMake 构建脚本中使用 target_link_libraries() 命令，将预构建库与你本地库相关联：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries( native-<span class="class"><span class="keyword">lib</span> <span class="title">imported</span>-<span class="title">lib</span> <span class="title">app</span>-<span class="title">glue</span> $&#123;<span class="title">log</span>-<span class="title">lib</span>&#125; )</span></span><br></pre></td></tr></table></figure><p>当你构建你的 APP 的时候，Gradle 会自动将导入的库打包到你的 APK 中。你可以使用 <strong>APK Analyzer</strong> 来检查。有关CMake的命令的详细信息，请参阅<a href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html" target="_blank" rel="noopener">CMake的文档。</a></p><hr><h3 id="关联本地库与-Gradle"><a href="#关联本地库与-Gradle" class="headerlink" title="关联本地库与 Gradle"></a><strong>关联本地库与 Gradle</strong></h3><p>为了将本地库与 Gradle 相关联，你需要在 CMake 或 ndk-build 构建脚本中提供一个路径地址。当你构建你的 APP 时，Gradle 会将 CMake 或 ndk-build 作为一个依赖运行，然后将共享库（.so 文件）打包到你的 APK 中。Gradle 同样使用构建脚本来识别哪些文件需要导入到 Android Studio 项目，你可以从 Project 窗口面板中看到相应的文件。如果你还没有一个为 native sources 准备的构建脚本，你需要先创建一个<a href="http://blog.csdn.net/u011974987/article/details/52888864#t7" target="_blank" rel="noopener">CMake脚本</a>，然后在继续。</p><p>一旦你使用Gradle关联了本地项目，AndroidStudio会在窗口更新项目的C/C++源文件和本地库，和你外部构建的脚本文件。</p><blockquote><p><strong>注意：</strong> 当你改变Gradle配置的时候，请确保在工具栏中点击<strong>Sync Project</strong></p></blockquote><h4 id="使用-Android-Studio-图形化界面"><a href="#使用-Android-Studio-图形化界面" class="headerlink" title="使用 Android Studio 图形化界面"></a><strong>使用 Android Studio 图形化界面</strong></h4><p>你可以使用 Android Studio 的图形化界面来将 Gradle 与外部 CMake 或者 ndk-build 项目关联起来。</p><ol><li>打开 IDE 左边的 <strong>Project</strong> 面板，选择 Android 。</li><li>右键点击你想链接本地库的 module，比如 <strong>app module</strong>，然后从菜单中选择 <strong>Link C++ Project with Gradle</strong> 。你应该能看见一个和下面图片中的对话框。</li><li>在下拉菜单中，选择 CMake 或者 ndk-build 。<br>a. 如果你选择 CMake ，需要在 Project Path 中指定 CMakeLists.txt 脚本文件的路径。<br>b. 如果你选择 ndk-build ，你需要在 Project Path 中指定 Android.mk 脚本文件的路径。</li><li>点击 OK。</li></ol><h4 id="配置-Gradle"><a href="#配置-Gradle" class="headerlink" title="配置 Gradle"></a><strong>配置 Gradle</strong></h4><p>如果要手动将 Gradle 与你的本地库相关联，你需要在 module 层级的 build.gradle 文件中添加 externalNativeBuild {} 代码块，并且在该代码块中配置 <strong>cmake {}</strong> 或 <strong>ndkBuild {} ：</strong></p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig <span class="meta">&#123;...&#125;</span></span><br><span class="line">  buildTypes <span class="meta">&#123;...&#125;</span></span><br><span class="line"></span><br><span class="line">  // <span class="type">Encapsulates</span> your external native build configurations.</span><br><span class="line">  externalNativeBuild &#123;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Encapsulates</span> your <span class="type">CMake</span> build configurations.</span><br><span class="line">    cmake &#123;</span><br><span class="line"></span><br><span class="line">      // <span class="type">Provides</span> a relative path to your <span class="type">CMake</span> build script.</span><br><span class="line">      path <span class="string">"CMakeLists.txt"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选配置"><a href="#可选配置" class="headerlink" title="可选配置"></a><strong>可选配置</strong></h4><p>你可以在你的 module 层级的 build.gradle 文件中的 defaultConfig {} 代码块中，添加 externalNativeBuild {} 代码块，为 CMake 或 ndk-build 配置一些额外参数。当然，你也可以在你的构建配置中的其他每一个生产渠道重写这些属性。</p><p>比如，如果你的 CMake 或者 ndk-build 项目中定义了多个本地库，你想在某个生产渠道使用这些本地库中的几个，你就可以使用 targets 属性来构建和打包。下面的代码展示了一些你可能会用到的属性：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    // <span class="type">This</span> <span class="keyword">block</span> <span class="keyword">is</span> different <span class="keyword">from</span> the one you use to link <span class="type">Gradle</span></span><br><span class="line">    // to your <span class="type">CMake</span> <span class="keyword">or</span> ndk-build script.</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line"></span><br><span class="line">      // <span class="type">For</span> ndk-build, instead use ndkBuild &#123;&#125;</span><br><span class="line">      cmake &#123;</span><br><span class="line"></span><br><span class="line">        // <span class="type">Passes</span> optional arguments to <span class="type">CMake</span>.</span><br><span class="line">        arguments <span class="string">"-DCMAKE_VERBOSE_MAKEFILE=TRUE"</span></span><br><span class="line"></span><br><span class="line">        // <span class="type">Sets</span> optional flags <span class="keyword">for</span> the C compiler.</span><br><span class="line">        cFlags <span class="string">"-D_EXAMPLE_C_FLAG1"</span>, <span class="string">"-D_EXAMPLE_C_FLAG2"</span></span><br><span class="line"></span><br><span class="line">        // <span class="type">Sets</span> a flag to enable format <span class="keyword">macro</span> constants <span class="keyword">for</span> the C++ compiler.</span><br><span class="line">        cppFlags <span class="string">"-D__STDC_FORMAT_MACROS"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildTypes <span class="meta">&#123;...&#125;</span></span><br><span class="line">  productFlavors &#123;</span><br><span class="line">    ...</span><br><span class="line">    demo &#123;</span><br><span class="line">      ...</span><br><span class="line">      externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">          ...</span><br><span class="line">          // <span class="type">Specifies</span> which native libraries to build <span class="keyword">and</span> package <span class="keyword">for</span> this</span><br><span class="line">          // product flavor. <span class="type">If</span> you don't configure this property, <span class="type">Gradle</span></span><br><span class="line">          // builds <span class="keyword">and</span> packages all <span class="literal">shared</span> <span class="keyword">object</span> libraries that you define</span><br><span class="line">          // <span class="keyword">in</span> your <span class="type">CMake</span> <span class="keyword">or</span> ndk-build project.</span><br><span class="line">          targets <span class="string">"native-lib-demo"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    paid &#123;</span><br><span class="line">      ...</span><br><span class="line">      externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">          ...</span><br><span class="line">          targets <span class="string">"native-lib-paid"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // <span class="type">You</span> use this <span class="keyword">block</span> to link <span class="type">Gradle</span> to your <span class="type">CMake</span> <span class="keyword">or</span> ndk-build script.</span><br><span class="line">  externalNativeBuild &#123;</span><br><span class="line">    cmake <span class="meta">&#123;...&#125;</span></span><br><span class="line">    // <span class="keyword">or</span> ndkBuild <span class="meta">&#123;...&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><h4 id="指定-ABI"><a href="#指定-ABI" class="headerlink" title="指定 ABI"></a><strong>指定 ABI</strong></h4><p>默认的情况下，Gradle 会将你的本地库构建成 .so 文件，然后将其打包到你的 APK 中。如果你想 Gradle 构建并打包某个特定的 ABI 。你可以在你的 module 层级的 build.gradle 文件中使用 ndk.abiFilters 标签来指定他们：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">      cmake <span class="meta">&#123;...&#125;</span></span><br><span class="line">      // <span class="keyword">or</span> ndkBuild <span class="meta">&#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ndk &#123;</span><br><span class="line">      // <span class="type">Specifies</span> the <span class="type">ABI</span> configurations <span class="keyword">of</span> your native</span><br><span class="line">      // libraries <span class="type">Gradle</span> should build <span class="keyword">and</span> package <span class="keyword">with</span> your <span class="type">APK</span>.</span><br><span class="line">      abiFilters 'x86', 'x86_64', 'armeabi', 'armeabi-v7a',</span><br><span class="line">                   'arm64-v8a'</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  buildTypes <span class="meta">&#123;...&#125;</span></span><br><span class="line">  externalNativeBuild <span class="meta">&#123;...&#125;</span></span><br><span class="line">  //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况，你只需要在 ndk {} 代码块中指定 abiFilters 就可以了；如上代码。它会告诉Gradle来构建编译不同的平台，但是，如果你想控制 Gradle 构建什么，独立打包到你的apk中，那就在<strong>defaultConfig.externalNativeBuild.cmake {}</strong> 代码块或 <strong>defaultConfig.externalNativeBuild.ndkBuild {}</strong> 代码块中，配置其他的 abiFilters 标签。Gradle 会构建那些 ABI 配置，但是只会将 defaultConfig.ndk {} 代码块中指定的配置打包到 apk 中。</p><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK 开发（四）JNI 中局部引用、全局引用和弱全局引用</title>
      <link href="/2016/10/18/ndk/jni-4/"/>
      <url>/2016/10/18/ndk/jni-4/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做过Java的朋友都知道，内存管理这一块是完全透明的，new一个类的实例时，只知道创建完这个类的实例后，会返回这个实例的一个引用，然后拿着这个引用去访问它的成员了（属性、方法），完全不用管JVM内部怎么实现的，如何为新建的对象申请内存，使用完之后如何释放内存，只需要知道有个垃圾回收器在处理这些事情就行了，然而，从Java虚拟机创建的对象传到C/C++代码时会产生引用，根据Java的垃圾回收机制，只要有引用存在就不回触发该引用所指向Java对象的垃圾回收；这些引用在JNI 中分为3种：全局引用（Global Reference）、局部引用 (Local Reference)、弱全局引用 (Week Global Reference) since JDK1.2。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="三种引用的区别"><a href="#三种引用的区别" class="headerlink" title="三种引用的区别"></a><strong>三种引用的区别</strong></h3><h4 id="1、全局引用"><a href="#1、全局引用" class="headerlink" title="1、全局引用"></a><strong>1、全局引用</strong></h4><p>全局引用可以跨方法、跨线程使用，直到被开发者显式释放。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。和局部引用不同的是，没有那么多函数能够创建全局引用。能创建全局引用的函数只有 NewGlobalRef。以下例子说明了如何使用一个全局引用。</p><p>java native方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">createGlobalRef</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function">String <span class="title">getGlobalRef</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">deleteGlobalRef</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>jni实现：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局引用</span></span><br><span class="line"><span class="comment">//共享(可以跨多个线程)，手动控制内存使用</span></span><br><span class="line">jstring global_str;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">JNIEXPORT void JNICALL Java_com_study_jni_JniTest_createGlobalRef(JNIEnv *<span class="keyword">env</span>, jobject jobj)&#123;</span><br><span class="line">jstring obj = (*<span class="keyword">env</span>)-&gt;NewStringUTF(<span class="keyword">env</span>, <span class="string">"jni development is powerful!"</span>);</span><br><span class="line">global_str = (*<span class="keyword">env</span>)-&gt;NewGlobalRef(<span class="keyword">env</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getGlobalRef(JNIEnv *<span class="keyword">env</span>, jobject jobj)&#123;</span><br><span class="line"><span class="keyword">return</span> global_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">JNIEXPORT void JNICALL Java_com_study_jni_JniTest_deleteGlobalRef(JNIEnv *<span class="keyword">env</span>, jobject jobj)&#123;</span><br><span class="line">(*<span class="keyword">env</span>)-&gt;DeleteGlobalRef(<span class="keyword">env</span>, global_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="2、局部引用"><a href="#2、局部引用" class="headerlink" title="2、局部引用"></a><strong>2、局部引用</strong></h4><p>一个局部引用仅在创建它的native函数及该函数调用的函数中有效。在一个native函数执行期间创建的所有局部引用将在该函数返回时被释放，创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟：循环创建数组</span></span><br><span class="line">JNIEXPORT void JNICALL Java_com_study_jni_JniTest_localRef(JNIEnv *<span class="keyword">env</span>, jobject jobj)&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="comment">//创建Date对象</span></span><br><span class="line">jclass cls = (*<span class="keyword">env</span>)-&gt;FindClass(<span class="keyword">env</span>, <span class="string">"java/util/Date"</span>);</span><br><span class="line">jmethodID constructor_mid = (*<span class="keyword">env</span>)-&gt;GetMethodID(<span class="keyword">env</span>, cls, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">jobject obj = (*<span class="keyword">env</span>)-&gt;NewObject(<span class="keyword">env</span>, cls, constructor_mid);</span><br><span class="line"><span class="comment">//此处省略一百行代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不在使用jobject对象了</span></span><br><span class="line"><span class="comment">//通知垃圾回收器回收这些对象</span></span><br><span class="line"><span class="comment">//释放局部引用</span></span><br><span class="line">(*<span class="keyword">env</span>)-&gt;DeleteLocalRef(<span class="keyword">env</span>, obj);</span><br><span class="line"><span class="comment">//此处省略一百行代码...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，省略了和我们无关紧要的代码，通过FindClass返回一个对java.util.Date对象的局部引用。</p><hr><h4 id="3、弱全局引用"><a href="#3、弱全局引用" class="headerlink" title="3、弱全局引用"></a><strong>3、弱全局引用</strong></h4><p>节省内存，在内存不足时可以是释放所引用的对象，可以引用一个不常用的对象，如果为NULL，临时创建，弱全局引用使用NewGlobalWeakRef创建，使用DeleteGlobalWeakRef释放。下面简称弱引用。与全局引用类似，弱引用可以跨方法、线程使用。但与全局引用很重要不同的一点是，弱引用不会阻止GC回收它引用的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。</p><h5 id="1-创建弱全局引用"><a href="#1-创建弱全局引用" class="headerlink" title="1.创建弱全局引用"></a><strong>1.创建弱全局引用</strong></h5><p>用NewWeakGlobalRef函数对弱全局引用进行初始化，例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass weakGlobalcls</span><br><span class="line">weakGlobalcls = (<span class="name">*env</span>)-&gt;NewWeakGlobalRef(<span class="name">env</span>,localclazz)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h5 id="2-引用的比较"><a href="#2-引用的比较" class="headerlink" title="2.引用的比较"></a><strong>2.引用的比较</strong></h5><p>给定两个引用（不管是全局、局部还是弱全局引用），我们只需要调用IsSameObject来判断它们两个是否指向相同的对象。例如：<code>（*env)-&gt;IsSameObject(env, obj1, obj2)</code><br>如果obj1和obj2指向相同的对象，则返回<strong>JNI_TRUE（或者1）</strong>，否则返回<strong>JNI_FALSE（或者0）</strong>。有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象。如果obj是一个局部或全局引用，使用<code>(*env)-&gt;IsSameObject(env, obj, NULL) 或者 obj == NULL</code> 来判断obj是否指向一个null对象即可。但需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。比如：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(JNI_FALSE == (*<span class="keyword">env</span>)-&gt;IsSameObject(<span class="keyword">env</span>,weakGlobalcls,NULL))&#123;</span><br><span class="line"><span class="comment">//TODO 对象未被回收，可以使用</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//TODO 对象被垃圾回收器回收，不能使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是学习这jni 的三种引用的简单使用，相关的知识并没有深入详细的说明！O(∩_∩)O~~</p><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK开发（三）C访问Java属性和方法</title>
      <link href="/2016/10/06/ndk/jni-3/"/>
      <url>/2016/10/06/ndk/jni-3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>native方法虽然是native的，但毕竟是方法，那么就应该同其他方法一样，能够访问类的属性和方法。实际上，JNI的确可以做到这一点，我们通过几个例子来说明~</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>继<a href="http://blog.csdn.net/u011974987/article/details/52743495" target="_blank" rel="noopener"> Android NDK 开发（二）JNI 传递参数和返回值</a>之后。</p><h3 id="1-访问类方法"><a href="#1-访问类方法" class="headerlink" title="1.访问类方法"></a><strong>1.访问类方法</strong></h3><p>初始化了Java虚拟机后，就可以开始调用Java的方法。要调用一个Java对象的方法必须经过几个步骤：</p><h4 id="1-1获取指定对象的类定义（jclass）"><a href="#1-1获取指定对象的类定义（jclass）" class="headerlink" title="1.1获取指定对象的类定义（jclass）"></a><strong>1.1获取指定对象的类定义（jclass）</strong></h4><p>有两种方式来获取对象的类定义：<br>第一种是在已知类名的情况下使用FindClass来查找对应的类。但是要注意类名并不同于平时写的Java代码，例如要得到类jni.test.Demo的定义必须调用如下代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass cls = (<span class="name">*env</span>)-&gt;FindClass(<span class="name">env</span>, <span class="string">"jni/test/Demo"</span>)<span class="comment">; //把点号换成斜杠</span></span><br></pre></td></tr></table></figure><p>第二种是通过对象直接得到其所对应的类定义：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jclass cls = (<span class="name">*env</span>)-&gt; GetObjectClass(<span class="name">env</span>, obj)<span class="comment">; //其中obj是要引用的对象，类型是jobject</span></span><br></pre></td></tr></table></figure><hr><h4 id="1-2读取要调用方法的定义"><a href="#1-2读取要调用方法的定义" class="headerlink" title="1.2读取要调用方法的定义"></a><strong>1.2读取要调用方法的定义</strong></h4><p>我们先来看看JNI中获取方法定义的函数：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmethodID </span>(<span class="keyword">JNICALL </span>*GetMethodID)(<span class="keyword">JNIEnv </span>*env, <span class="keyword">jclass </span>clazz, const char *name,  </span><br><span class="line">const char *sig)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">jmethodID </span>(<span class="keyword">JNICALL </span>*GetStaticMethodID)(<span class="keyword">JNIEnv </span>*env, <span class="keyword">jclass </span>class, const char  </span><br><span class="line">*name, const char *sig)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这两个函数的区别明显都能猜到，GetStaticMethodID 是用来获取静态方法的定义，而GetMethodID 则是获取非静态的方法定义。</p><p>这两个函数都需要提供四个参数：</p><ul><li>第一个参数env 就是初始化虚拟机得到的jni环境；</li><li>第二个参数class 是对象的类定义，也就是第一步得到的obj；</li><li>第三个参数是方法名称；</li><li>第四个参数是最重要德，这个参数是方法的定义。</li></ul><p>因为我们知道Java中允许方法的多态，仅仅是通过方法名是没有办法定位到一个具体的方法，因此就需要第 四个参数来指定方法的具体定义（也就是所谓的签名）；但是怎么利用一个字符串来表示方法的具体定义呢？JDK中已经准备好一个反编译工具javap。</p><p>通过这个工具就可以得到类 中每个属性、方法的定义。下面就来看看jni.test.Demo的定义：</p><p>打开命令行窗口进入到项目目录德的bin目录下，并运行 javap -s -p jni.test.Demo 得到运行结果如下： </p><p><img src="http://img.blog.csdn.net/20161006210123652" alt="cmd签名"></p><p>从上图中，我们看到类中每个属性和方法下面都有一段注释。注释中不包含空格的内容就是第四个参数要填的内容。基本数据的签名如下：</p><p><img src="http://img.blog.csdn.net/20161006213959982" alt="这里写图片描述"></p><p>下面这段代码将调用accessConstructor（）的方法。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问构造方法</span></span><br><span class="line"><span class="comment">//使用java.util.Date产生一个当前的时间戳</span></span><br><span class="line">JNIEXPORT jobject JNICALL Java_com_dongnaoedu_jni_JniTest_accessConstructor</span><br><span class="line">(JNIEnv *<span class="keyword">env</span>, jobject jobj)&#123;</span><br><span class="line">jclass cls = (*<span class="keyword">env</span>)-&gt;FindClass(<span class="keyword">env</span>, <span class="string">"java/util/Date"</span>);</span><br><span class="line"><span class="comment">//jmethodID</span></span><br><span class="line">jmethodID constructor_mid = (*<span class="keyword">env</span>)-&gt;GetMethodID(<span class="keyword">env</span>, cls, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line"><span class="comment">//实例化一个Date对象</span></span><br><span class="line">jobject date_obj = (*<span class="keyword">env</span>)-&gt;NewObject(<span class="keyword">env</span>, cls, constructor_mid);</span><br><span class="line"><span class="comment">//调用getTime方法</span></span><br><span class="line">jmethodID mid = (*<span class="keyword">env</span>)-&gt;GetMethodID(<span class="keyword">env</span>, cls, <span class="string">"getTime"</span>, <span class="string">"()J"</span>);</span><br><span class="line">jlong time = (*<span class="keyword">env</span>)-&gt;CallLongMethod(<span class="keyword">env</span>, date_obj, mid);</span><br><span class="line"></span><br><span class="line">printf(<span class="string">"\ntime:%lld\n"</span>,time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> date_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在java 端调用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.accessConstructor()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://img.blog.csdn.net/20161006211824441" alt="这里写图片描述"></p><hr><h4 id="1-3-调用方法"><a href="#1-3-调用方法" class="headerlink" title="1.3 调用方法"></a><strong>1.3 调用方法</strong></h4><p>为了调用对象的某个方法，可以使用函数</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;<span class="keyword">TYPE</span>&gt;<span class="function"><span class="keyword">Method</span>或者 <span class="title">CallStatic</span>&lt;<span class="title">TYPE</span>&gt;<span class="title">Method</span>（访问类的静态方法），</span></span><br></pre></td></tr></table></figure><p>&lt; TYPE&gt;根据不同的返回类型而定。这些方法都是使用可 变参数的定义，如果访问某个方法需要参数时，只需要把所有参数按照顺序填写到方法中就可以。在讲到构造函数的访问时，将演示如何访问带参数的构造函数。</p><hr><h3 id="2-访问类属性"><a href="#2-访问类属性" class="headerlink" title="2.访问类属性"></a><strong>2.访问类属性</strong></h3><h4 id="2-1-获取指定对象的类（jclass）"><a href="#2-1-获取指定对象的类（jclass）" class="headerlink" title="2.1 获取指定对象的类（jclass）"></a><strong>2.1 获取指定对象的类（jclass）</strong></h4><p> 这一步，与访问类方法完全一样，具体就参考上面德步骤吧~</p><hr><h4 id="2-2-读取类属性的定义（jfieldID）"><a href="#2-2-读取类属性的定义（jfieldID）" class="headerlink" title="2.2 读取类属性的定义（jfieldID）"></a><strong>2.2 读取类属性的定义（jfieldID）</strong></h4><p>在JNI中是这样定义获取类属性的方法的：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jfieldID </span>(<span class="keyword">JNICALL </span>*GetFieldID)</span><br><span class="line">(<span class="keyword">JNIEnv </span>*env, <span class="keyword">jclass </span>clazz, const char *name, const char *sig)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">jfieldID </span>(<span class="keyword">JNICALL </span>*GetStaticFieldID) </span><br><span class="line">(<span class="keyword">JNIEnv </span>*env, <span class="keyword">jclass </span>clazz, const char *name, const char *sig)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这两个函数中第一个参数为JNI环境；clazz为类的定义；name为属性名称；第四个参数同样是为了表达属性的类型。前面我们使用javap工具获取类的详细定义的时候有这样两行： </p><p>public java.lang.String key;<br>/<em>   Ljava/lang/String;   </em>/ </p><p>其中第二行注释的内容就是第四个参数要填的信息，这跟访问类方法时是相同的。</p><hr><h4 id="2-3-读取和设置属性值"><a href="#2-3-读取和设置属性值" class="headerlink" title="2.3 读取和设置属性值"></a><strong>2.3 读取和设置属性值</strong></h4><p>有了属性的定义要访问属性值就很容易了。有几个方法用来读取和设置类的属性，它们是：<code>Get&lt;TYPE&gt;Field、 Set&lt;TYPE&gt;Field、GetStatic&lt;TYPE&gt;Field、 SetStatic&lt;TYPE&gt;Field。</code><br>比如读取Demo类的key属性就可以用GetFieldID，相关代码如下： </p><p>java调用代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">key</span> = <span class="string">"xuhao"</span>;</span><br><span class="line"><span class="comment">//访问属性，返回修改之后的属性内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">String</span> accessField();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    JniTest t = <span class="keyword">new</span> JniTest();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"key修改前："</span>+t.<span class="built_in">key</span>);</span><br><span class="line">t.accessField();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"key修改后："</span>+t.<span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地方法实现：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C/C++访问Java的成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.访问属性</span></span><br><span class="line"><span class="comment">//修改属性key</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_dongnaoedu_jni_JniTest_accessField</span><br><span class="line">(JNIEnv *<span class="keyword">env</span>, jobject jobj)&#123;</span><br><span class="line"><span class="comment">//jobj是t对象，JniTest.class</span></span><br><span class="line">jclass cls = (*<span class="keyword">env</span>)-&gt;GetObjectClass(<span class="keyword">env</span>, jobj);</span><br><span class="line"><span class="comment">//jfieldID</span></span><br><span class="line"><span class="comment">//属性名称，属性签名</span></span><br><span class="line">jfieldID fid = (*<span class="keyword">env</span>)-&gt;GetFieldID(<span class="keyword">env</span>, cls, <span class="string">"key"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//xuhao &gt;&gt; super xuhao</span></span><br><span class="line"><span class="comment">//获取key属性的值</span></span><br><span class="line"><span class="comment">//Get&lt;Type&gt;Field</span></span><br><span class="line">jstring jstr = (*<span class="keyword">env</span>)-&gt;GetObjectField(<span class="keyword">env</span>, jobj, fid);</span><br><span class="line">printf(<span class="string">"jstr:%#x\n"</span>,&amp;jstr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jstring -&gt; c字符串</span></span><br><span class="line"><span class="comment">//isCopy 是否复制（true代表赋值，false不复制）</span></span><br><span class="line">char *c_str = (*<span class="keyword">env</span>)-&gt;GetStringUTFChars(<span class="keyword">env</span>,jstr,JNI_FALSE);</span><br><span class="line"><span class="comment">//拼接得到新的字符串</span></span><br><span class="line">char <span class="keyword">text</span>[<span class="number">20</span>] = <span class="string">"super "</span>;</span><br><span class="line">strcat(<span class="keyword">text</span>,c_str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//c字符串 -&gt;jstring</span></span><br><span class="line">jstring new_jstr = (*<span class="keyword">env</span>)-&gt;NewStringUTF(<span class="keyword">env</span>, <span class="keyword">text</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改key</span></span><br><span class="line"><span class="comment">//Set&lt;Type&gt;Field</span></span><br><span class="line">(*<span class="keyword">env</span>)-&gt;SetObjectField(<span class="keyword">env</span>, jobj, fid, new_jstr);</span><br><span class="line"></span><br><span class="line">printf(<span class="string">"new_jstr:%#x\n"</span>, &amp;new_jstr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> new_jstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用结果如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">key</span>修改前：xuhao</span><br><span class="line"><span class="built_in">key</span>修改后：<span class="keyword">super</span> xuhao</span><br></pre></td></tr></table></figure><p>其他的访问方式都是按照这些套路来的，理解就可以了，今天连续赶了两篇博客，后面再抽出时间继续，坚持，坚持，再坚持！！！</p><hr><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK开发（二）JNI传递参数和返回值</title>
      <link href="/2016/10/06/ndk/jni-2/"/>
      <url>/2016/10/06/ndk/jni-2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在使用 JNI 时最常问到的是 JAVA 和 C/C++之间如何传递数据，以及数据类型之间如何 互相映射。我们从整数等基本类型和数组、字符串等普通的对象类型开始讲述。至于如何传递任意对象，将在后面会更新。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>继<a href="http://blog.csdn.net/u011974987/article/details/52602913" target="_blank" rel="noopener">JNI简介及调用流程</a>这篇文章，我们再来实现一个非静态的native方法。</p><p>Java端：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class JniTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">String</span> getStringFromC();</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">String</span> getString2FromC(<span class="built_in">int</span> i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = getStringFromC();</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">JniTest t = <span class="keyword">new</span> JniTest();</span><br><span class="line"><span class="built_in">text</span> = t.getString2FromC(<span class="number">6</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载动态库</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.loadLibrary(<span class="string">"jni_study"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- more --><p>在native层实现 getString2FromC 非静态方法；</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JNIEXPORT </span><span class="keyword">jstring </span><span class="keyword">JNICALL </span><span class="keyword">Java_com_study_jni_JniTest_getString2FromC</span></span><br><span class="line"><span class="keyword">(JNIEnv </span>*env, <span class="keyword">jobject </span><span class="keyword">jobj, </span><span class="keyword">jint </span>num)&#123;</span><br><span class="line">return (*env)-&gt;NewStringUTF(env,<span class="string">"C String2"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看出，每个native函数，都至少有两个参数（JNIEnv*,jclass或者jobject)</p><ul><li><strong>当native方法为静态方法时：</strong><br>jclass 代表native方法所属类的class对象(JniTest.class)</li><li><strong>当native方法为非静态方法时：</strong><br>jobject 代表native方法所属的对象</li></ul><hr><h3 id="1-Java基本数据类型传递"><a href="#1-Java基本数据类型传递" class="headerlink" title="1.Java基本数据类型传递"></a><strong>1.Java基本数据类型传递</strong></h3><p>用过Java的人都知道，Java中的基本类型包括boolean，byte，char，short，int，long，float，double这样几种，如果你用这几种类型做native方法的参数，当你通过javah -jni生成.h文件的时候，只要看一下生成的.h文件，就会一清二楚，这些类型分别对应的类型是jboolean，jbyte，jchar，jshort，jint，jlong，jfloat，jdouble 。这几种类型几乎都可以当成对应的C++类型来用。</p><p>Java基本数据类型与JNI数据类型的映射关系如下：</p><p><img src="http://img.blog.csdn.net/20161006145447006" alt="JNI的基本数据类型"></p><p>对应的java引用数据类型：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct _jobject<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef struct _jobject *<span class="keyword">jobject;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jobject </span><span class="keyword">jclass;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jobject </span><span class="keyword">jthrowable;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jobject </span><span class="keyword">jstring;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jobject </span><span class="keyword">jarray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jbooleanArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jbyteArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jcharArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jshortArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jintArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jlongArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jfloatArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jdoubleArray;</span></span><br><span class="line"><span class="keyword">typedef </span><span class="keyword">jarray </span><span class="keyword">jobjectArray;</span></span><br></pre></td></tr></table></figure><p>关系图：</p><p><img src="http://img.blog.csdn.net/20161006153213851" alt="这里写图片描述"></p><p>最终都是jobject 的结构体指针类型。</p><hr><h3 id="2-String参数的传递"><a href="#2-String参数的传递" class="headerlink" title="2.String参数的传递"></a><strong>2.String参数的传递</strong></h3><p>Java的String和C++的string是不能对等起来的，所以处理起来比较麻烦。先看一个例子</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prompt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native method that prints a prompt and reads a line</span></span><br><span class="line"><span class="keyword">private</span> native <span class="keyword">String</span> getLine(<span class="keyword">String</span> prompt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span> args[]) &#123;</span><br><span class="line">Prompt p = <span class="keyword">new</span> <span class="type">Prompt</span>();</span><br><span class="line"><span class="keyword">String</span> input = p.getLine(<span class="string">"Type a line: "</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"User typed: "</span> + input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.loadLibrary(<span class="string">"Prompt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们要实现一个native方法，String getLine(String prompt);读入一个String参数，返回一个String值。通过执行javah -jni得到的头文件是这样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_Prompt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_Prompt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_Prompt_getLine</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jstring prompt)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>jstring是JNI中对应于String的类型，但是和基本类型不同的是，jstring不能直接当作C++的string用。如果你用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; prompt &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>编译器肯定会扔给你一个错误信息的。<br>其实要处理jstring有很多种方式，这里只讲一种我认为最简单的方式，看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Prompt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_Prompt_getLine</span><span class="params">(JNIEnv *env, jobject obj, jstring prompt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str;</span><br><span class="line">str = env-&gt;GetStringUTFChars(prompt, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(str == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">env-&gt;ReleaseStringUTFChars(prompt, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个字符串</span></span><br><span class="line"><span class="keyword">char</span>* tmpstr = <span class="string">"return string succeeded"</span>;</span><br><span class="line">jstring rtstr = env-&gt;NewStringUTF(tmpstr);</span><br><span class="line"><span class="keyword">return</span> rtstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的列子代码中，作为参数的prompt不能直接被C++程序使用，先做了如下转换</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str</span> = env-&gt;GetStringUTFChars(prompt, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>将jstring类型变成一个char*类型。<br>返回的时候，要生成一个jstring类型的对象，也必须通过如下方式，</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">jstring rtstr</span> = env-&gt;NewStringUTF(tmpstr);</span><br></pre></td></tr></table></figure><p>这里用到的<strong>GetStringUTFChars</strong>和<strong>NewStringUTF</strong>都是JNI提供的处理String类型的函数。</p><hr><h3 id="3-数组类型的传递"><a href="#3-数组类型的传递" class="headerlink" title="3.数组类型的传递"></a><strong>3.数组类型的传递</strong></h3><p>和String一样，JNI为Java基本类型的数组提供了j*Array类型，比如int[]对应的就是jintArray。来看一个传递int数组的例子。</p><p>java端主要代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> native <span class="keyword">void</span> <span class="title">giveArray</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = &#123;<span class="number">9</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="number">37</span>,<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">t.giveArray(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : <span class="built_in">array</span>) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C实现主要代码：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> compare(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)&#123;</span><br><span class="line"><span class="keyword">return</span> (*a) - (*b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入</span></span><br><span class="line">JNIEXPORT void JNICALL Java_com_study_jni_JniTest_giveArray</span><br><span class="line">(JNIEnv *<span class="keyword">env</span>, jobject jobj, jintArray arr)&#123;</span><br><span class="line"><span class="comment">//jintArray -&gt; jint指针 -&gt; c int 数组</span></span><br><span class="line">jint *elems = (*<span class="keyword">env</span>)-&gt;GetIntArrayElements(<span class="keyword">env</span>, arr, NULL);</span><br><span class="line"><span class="comment">//printf("%#x,%#x\n", &amp;elems, &amp;arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的长度</span></span><br><span class="line"><span class="keyword">int</span> len = (*<span class="keyword">env</span>)-&gt;GetArrayLength(<span class="keyword">env</span>, arr);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">qsort(elems, len, sizeof(jint), compare);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步</span></span><br><span class="line"><span class="comment">//mode</span></span><br><span class="line"><span class="comment">//0, Java数组进行更新，并且释放C/C++数组</span></span><br><span class="line"><span class="comment">//JNI_ABORT, Java数组不进行更新，但是释放C/C++数组</span></span><br><span class="line"><span class="comment">//JNI_COMMIT，Java数组进行更新，不释放C/C++数组（函数执行完，数组还是会释放）</span></span><br><span class="line"></span><br><span class="line">(*<span class="keyword">env</span>)-&gt;ReleaseIntArrayElements(<span class="keyword">env</span>, arr, elems, JNI_COMMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码中的<strong>GetIntArrayElements</strong>和<strong>ReleaseIntArrayElements</strong>函数就是JNI提供用于处理int数组的函数。</p><p>如果用arr[i]的方式去访问jintArray类型，不用问肯定会出错。<br>JNI还提供了另一对函数<strong>GetIntArrayRegion</strong>和<strong>ReleaseIntArrayRegion</strong>访问int数组，不在这里做介绍，至于其他的类型数组，方法类似。</p><hr><h3 id="4-返回数组"><a href="#4-返回数组" class="headerlink" title="4.返回数组"></a><strong>4.返回数组</strong></h3><p>在JNI中，二维数组和String数组都被视为object数组，因为数组和String被视为object。最后一个示例说明如何在本地代码中创建一个字符串数组并将它返回给 Java 调用者。</p><p>java端的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array2 = t.getArray(<span class="number">10</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"------------"</span>);</span><br><span class="line"><span class="built_in">for</span> (<span class="keyword">int</span> i : array2) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数实现：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回数组</span></span><br><span class="line">JNIEXPORT jintArray JNICALL Java_com_study_jni_JniTest_getArray(JNIEnv *<span class="keyword">env</span>, jobject jobj, jint len)&#123;</span><br><span class="line"><span class="comment">//创建一个指定大小的数组</span></span><br><span class="line">jintArray jint_arr = (*<span class="keyword">env</span>)-&gt;NewIntArray(<span class="keyword">env</span>, len);</span><br><span class="line">jint *elems = (*<span class="keyword">env</span>)-&gt;GetIntArrayElements(<span class="keyword">env</span>, jint_arr, NULL);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; len; i++)&#123;</span><br><span class="line">elems[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步</span></span><br><span class="line">(*<span class="keyword">env</span>)-&gt;ReleaseIntArrayElements(<span class="keyword">env</span>, jint_arr, elems, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jint_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>jintArray jint_arr ;因为要返回值，所以需要创建一个指定大小jintArray对象。根据jintArray对象拿到jint 指针。然后，赋值，同步，这样通过参数返回就可以了。<br>下一篇将会介绍C 访问Java 属性和方法。</p><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 脚本基础学习之函数（五）</title>
      <link href="/2016/10/01/linux/shell-script-05/"/>
      <url>/2016/10/01/linux/shell-script-05/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux shell脚本基础学习我们这里就差不多讲完了，函数相信大家都不陌生吧，直接入正题吧~</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="http://xuhaoblog.com/linux/shell-script-04.html">继上篇博客之后</a></p><h4 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a><strong>shell 函数</strong></h4><p>Linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。<br>shell 中函数的定义格式如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span><span class="number">_n</span>ame () &#123;</span><br><span class="line">    list <span class="keyword">of</span> commands</span><br><span class="line">    [ <span class="keyword">return</span> <span class="keyword">value</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a id="more"></a><p>说明：</p><ul><li>1、函数名前面也可以加上关键字function；</li><li>2、函数的返回值，可以显示加：return 返回，如果不加，将以最后一条命令的运行结果作为返回值。</li></ul><p>shell 函数返回值只能是整数，一般用来表示函数执行是否政工，0表示成功，其他则表示失败。</p><p>如果要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在访问这个变量来获得函数的返回值。</p><p>比如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>#!/bin/bash                                                            </span><br><span class="line"><span class="symbol">2 </span>Hello () &#123;</span><br><span class="line"><span class="symbol">3 </span>        echo <span class="string">"My name is xu hao"</span></span><br><span class="line"><span class="symbol">4 </span>&#125;</span><br><span class="line"><span class="symbol">5 </span></span><br><span class="line"><span class="symbol">6 </span>#调用上面的函数</span><br><span class="line"><span class="symbol">7 </span>Hello</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># ./06.sh </span></span><br><span class="line">My name is xu hao</span><br></pre></td></tr></table></figure><p><strong>调用函数只需要给出函数名，不需要加括号。</strong></p><p>再来看一个带有return语句的函数：</p><p>在上面例子后面添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithReturn</span></span>() &#123;</span><br><span class="line">11         <span class="built_in">echo</span> <span class="string">"这个函数功能是得到两个数字的和"</span></span><br><span class="line">12         <span class="built_in">echo</span> -n <span class="string">"请输入第一个数字"</span></span><br><span class="line">13         <span class="built_in">read</span> aNum;</span><br><span class="line">14         <span class="built_in">echo</span> -n <span class="string">"请输入第二个数字"</span></span><br><span class="line">15         <span class="built_in">read</span> bNum;</span><br><span class="line">16         <span class="built_in">echo</span> <span class="string">"这两个数分别是 <span class="variable">$aNum</span> 和 <span class="variable">$bNum</span> !"</span></span><br><span class="line">17   <span class="built_in">return</span> $((<span class="variable">$aNum</span>+<span class="variable">$bNum</span>))</span><br><span class="line">18 &#125; </span><br><span class="line">19 </span><br><span class="line">20 <span class="comment">#调用funWithReturn这个函数</span></span><br><span class="line">21 funWithReturn</span><br><span class="line">22 </span><br><span class="line">23 ret=$?</span><br><span class="line">24 <span class="built_in">echo</span> <span class="string">"The sun of two numbers is <span class="variable">$ret</span> !"</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># ./06.sh </span></span><br><span class="line">My name is xu hao</span><br><span class="line">这个函数功能是得到两个数字的和</span><br><span class="line">请输入第一个数字<span class="number">56</span></span><br><span class="line">请输入第二个数字<span class="number">23</span></span><br><span class="line">这两个数分别是 <span class="number">56</span> 和 <span class="number">23</span> !</span><br><span class="line">The sun of two numbers is <span class="number">79</span> !</span><br></pre></td></tr></table></figure><blockquote><p>$?最后运行的命令的结束代码（返回值），这个在后面会总结的。</p></blockquote><hr><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">shell</span><span class="bash"> 中，调用函数时可以向其传递参数，在函数体内部，通过<span class="variable">$n</span> 的形式来获取参数，比如,<span class="variable">$1</span>表示第一个参数，<span class="variable">$2</span>表示第二个参数</span></span><br></pre></td></tr></table></figure><p>再来看一个带参数的函数例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">28 </span>funWithParam() &#123;</span><br><span class="line"><span class="symbol">29 </span>        echo <span class="string">"第一个param为 $1"</span></span><br><span class="line"><span class="symbol">30 </span>        echo <span class="string">"第二个param为 $2"</span></span><br><span class="line"><span class="symbol">31 </span>        echo <span class="string">"第十个param为 $10"</span></span><br><span class="line"><span class="symbol">32 </span>        echo <span class="string">"第十个param为 $&#123;10&#125;"</span></span><br><span class="line"><span class="symbol">33 </span>        echo <span class="string">"参数总共有 $#"</span></span><br><span class="line"><span class="symbol">34 </span>        echo <span class="string">"作为一个字符串输出所有参数 $* !"</span></span><br><span class="line"><span class="symbol">35 </span></span><br><span class="line"><span class="symbol">36 </span>&#125;</span><br><span class="line"><span class="symbol">37 </span>#调用函数并传递参数</span><br><span class="line"><span class="symbol">38 </span>funWithParam <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">23</span> <span class="number">45</span> <span class="number">22</span> <span class="number">9</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>运行脚本输出的结果为：</p><p><img src="http://img.blog.csdn.net/20161001175800334" alt="这里写图片描述"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里注意下，$ <span class="number">10</span>不能获取第<span class="number">10</span>个参数，当n&gt;=<span class="number">10</span>时，需要$&#123;n&#125;来获取参数。</span><br></pre></td></tr></table></figure><p><strong>另外：在补充几个特殊字符来处理的参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="comment">#传递到脚本的参数个数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">*以一个单字符串显示所有向脚本传递的参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash">$脚本运行的当前进程ID号</span></span><br><span class="line"><span class="meta">$</span><span class="bash">!后台运行的最后一个进程的ID号</span></span><br><span class="line"><span class="meta">$</span><span class="bash">@与$*相同，但是使用时加引号，并在引号中返回每个参数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">-显示Shell使用的当前选项，与<span class="built_in">set</span>命令功能相同。</span></span><br><span class="line"><span class="meta">$</span><span class="bash">?显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span></span><br></pre></td></tr></table></figure><p>一下午整理这两篇博客，算是把Linux shell 脚本的基础的理论学习讲完了，更多的细节只有等我们遇到了在慢慢琢磨吧！吃饭~</p><hr><h2 id="更多相关系列传送门："><a href="#更多相关系列传送门：" class="headerlink" title="更多相关系列传送门："></a>更多相关系列传送门：</h2><p><strong>【个人博客】shel 脚本系列</strong></p><ul><li><a href="http://xuhaoblog.com/linux/shell-script-01.html">【Linux 系统编程】shell 脚本基础学习（一）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-02.html">【Linux 系统编程】shell 命令和流程控制（二）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-03.html">【Linux 系统编程】shell 流程控制loop和引号（三）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-04.html">【Linux 系统编程】shell 输入/输出重定向（四）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-05.html">【Linux 系统编程】shell 脚本基础学习之函数（五）</a></li></ul><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 输入/输出重定向（四）</title>
      <link href="/2016/10/01/linux/shell-script-04/"/>
      <url>/2016/10/01/linux/shell-script-04/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><font size="4">原本计划国庆节第一天假期休息一天，但是想想自己还有很多事情没有完成，就立马打开电脑，开始干活了。打算这7天的假期好好整理下之前学的知识和巩固练习，充实每一天，好了入正题，Linux shell脚本基础前面我们在介绍Linux shell脚本的控制流程时，还有一部分内容没讲就是有关here document的内容这里继续，Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</font></p><p>原文链接请标明：<br><a href="http://xuhaoblog.com/linux/shell-script-04.html">http://xuhaoblog.com/linux/shell-script-04.html</a><br>本文出自:【<a href="http://xuhaoblog.com">stromxu</a>的博客】</p><a id="more"></a><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><a href="http://xuhaoblog.com/2016/09/30/linux/shell-script-03.html">接着上一篇继续…</a></p><h4 id="1、Shell-输入-输出重定向"><a href="#1、Shell-输入-输出重定向" class="headerlink" title="1、Shell 输入/输出重定向"></a><strong>1、Shell 输入/输出重定向</strong></h4><h5 id="重定向命令列表如下："><a href="#重定向命令列表如下：" class="headerlink" title="重定向命令列表如下："></a>重定向命令列表如下：</h5><table><thead><tr><th>命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td style="text-align:left">将输出重定向到 file。</td></tr><tr><td>command &lt; file</td><td style="text-align:left">将输入重定向到 file。</td></tr><tr><td>command &gt;&gt; file</td><td style="text-align:left">将输出以追加的方式重定向到 file。</td></tr><tr><td>n &gt; file</td><td style="text-align:left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td>n &gt;&gt; file</td><td style="text-align:left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td>n &gt;&amp; m</td><td style="text-align:left">将输出文件 m 和 n 合并。</td></tr><tr><td>n &lt;&amp; m</td><td style="text-align:left">将输入文件 m 和 n 合并。</td></tr><tr><td>&lt;&lt; tag</td><td style="text-align:left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><ul><li><font color="red"> <strong>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</strong></font></li></ul><hr><h5 id="1-1、输出重定向"><a href="#1-1、输出重定向" class="headerlink" title="1.1、输出重定向"></a><strong>1.1、输出重定向</strong></h5><p>重定向一般通过在命令间插入特定的符号来实现，语法如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comma<span class="symbol">nd1</span> &gt; file<span class="number">1</span></span><br></pre></td></tr></table></figure><p>上面这个命令执行command1然后将输出的内容存入file1。</p><p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新的内容添加到文件的末尾，则使用&gt;&gt;操作符。</p><p><strong>例子</strong>：</p><p>我们先新建一个文件test2，然后执行 ls -al 重定向到test2文件中，在命令行的操作符代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">新建test2文件</span></span><br><span class="line">touch test2    </span><br><span class="line"><span class="meta">#</span><span class="bash">输出重定向</span></span><br><span class="line">ls -al &gt; test2</span><br></pre></td></tr></table></figure><p>然后我们使用cat命令查看文件内容：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@iZ28t5k4ny4Z:/usr/xiho/shell<span class="comment"># cat test3</span></span><br><span class="line">total 132</span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root <span class="number"> 4096 </span>Oct <span class="number"> 1 </span>13:19 .</span><br><span class="line">drwxr-xr-x<span class="number"> 4 </span>root root <span class="number"> 4096 </span>Sep<span class="number"> 27 </span>16:29 ..</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 27 </span>19:15 .01.sh.swo</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 27 </span>16:35 .01.sh.swp</span><br><span class="line">-rwxr--r--<span class="number"> 1 </span>root root  <span class="number"> 347 </span>Sep<span class="number"> 28 </span>21:07 02.sh</span><br><span class="line">-rwxr--r--<span class="number"> 1 </span>root root  <span class="number"> 100 </span>Sep<span class="number"> 28 </span>21:28 03.sh</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 28 </span>21:15 .03.sh.swp</span><br><span class="line">-rwxr--r--<span class="number"> 1 </span>root root  <span class="number"> 109 </span>Sep<span class="number"> 28 </span>22:17 04.sh</span><br><span class="line">-rw-------<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 30 </span>18:03 .04.swp</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root    <span class="number"> 0 </span>Sep<span class="number"> 28 </span>22:45 05.sh</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 28 </span>22:47 .05.sh.swp</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root    <span class="number"> 0 </span>Sep<span class="number"> 30 </span>20:57 06.sh</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 30 </span>21:00 .06.sh.swp</span><br><span class="line">-rwxrwxrwx<span class="number"> 1 </span>root root  <span class="number"> 223 </span>Sep<span class="number"> 30 </span>17:50 b.sh</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 30 </span>18:03 .b.sh.swo</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 12288 </span>Sep<span class="number"> 28 </span>16:50 .b.sh.swp</span><br><span class="line">-rwxrwxrwx<span class="number"> 1 </span>root root  <span class="number"> 119 </span>Oct <span class="number"> 1 </span>13:12 demo.sh</span><br><span class="line">-rwxr--r--<span class="number"> 1 </span>root root   <span class="number"> 68 </span>Sep<span class="number"> 30 </span>14:09 test1.sh</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root  <span class="number"> 954 </span>Oct <span class="number"> 1 </span>13:10 test2</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root    <span class="number"> 0 </span>Oct <span class="number"> 1 </span>13:19 test3</span><br></pre></td></tr></table></figure><p>就会把当前目录下的所有文件给显示出来了。</p><p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，这个请自行练习使用。</p><hr><h5 id="1-2、输入重定向"><a href="#1-2、输入重定向" class="headerlink" title="1.2、输入重定向"></a><strong>1.2、输入重定向</strong></h5><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comma<span class="symbol">nd1</span> &lt; file<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。注意：输出重定向是大于号（&gt;），出入重定向是小于号（&lt;）。</p><p><strong>例子</strong></p><p>接着上面的例子，我们统计test2文件的行数，(不熟悉命令的同学，请查看我的 <a href="http://blog.csdn.net/u011974987/article/details/52703177" target="_blank" rel="noopener">shell命令（二）</a>的文章），执行以下命令：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l test2</span><br><span class="line"><span class="number">21</span> test2</span><br></pre></td></tr></table></figure><p>也可以将输入重定向到test2文件中：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l &lt; test2</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>上面两个例子的结果不同；第一个例子，会输出文件名；第二不会，因为它仅仅知道从标准输入读取内容。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; <span class="keyword">infile</span> &gt; <span class="keyword">outfile</span></span><br></pre></td></tr></table></figure><p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p><hr><h5 id="1-3、重定向深入理解"><a href="#1-3、重定向深入理解" class="headerlink" title="1.3、重定向深入理解"></a><strong>1.3、重定向深入理解</strong></h5><p>一般情况下，每一个Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件（stdin）: stdin的文件描述符为0，linux程序默认从stdin读取数据。</li><li>标准输出文件（stdout）: stdout 的文件描述为1，linux程序默认想stdout输出数据。</li><li>标准错误文件（stderr）: stderr 的文件描述符为2，linux程序会想stderr流中写入错误信息。</li></ul><hr><p> 以后打开文件后。新增文件绑定描述符 可以依次增加。 一条shell命令执行，都会继承父进程的文件描述符。因此，所有运行的shell命令，都会有默认3个文件描述符。 </p><p>正常情况下，command &gt; file 将stdout重定向file，command &lt; file 将stdin 重定向到 file。</p><p>一个命令执行了：<br>先有一个输入：输入可以从键盘，也可以从文件得到<br>命令执行完成：成功了，会把成功结果输出到屏幕：standard output默认是屏幕<br>命令执行有错误：会把错误也输出到屏幕上面：standard error默认也是指的屏幕</p><p>如果希望stderr 重定向 到file 可以这样写：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span> <span class="title">2</span>&gt; <span class="title">file</span></span><br></pre></td></tr></table></figure><p>如果希望stderr追加到file 文件末尾，可以这样写：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command <span class="number">2</span><span class="meta">&gt;&gt; </span>file</span><br></pre></td></tr></table></figure><ul><li><strong>实例（通俗易懂）</strong></li></ul><p>显示当前目录文件，写一个实际存在和一个不存在的，方便理解。比如当前目录存在test1.sh，不存在xiho。代码如下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># ls test1.sh xiho </span></span><br><span class="line"><span class="symbol">ls:</span> cannot access <span class="symbol">xiho:</span> No such file <span class="keyword">or</span> directory</span><br><span class="line">test1.sh</span><br></pre></td></tr></table></figure></p><p>看到上面代码显示在屏幕上面，找不到文件路劲报错，正确输出与错误输出都显示在屏幕了，<strong>但是现在需要把正确输出写入suc.txt， 1&gt; 可以省略，不写，默认所至标准输出，把错误输出到err.txt，不输出到屏幕。</strong></p><p>例子如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls test1<span class="selector-class">.sh</span> xiho <span class="number">1</span>&gt; suc<span class="selector-class">.txt</span> <span class="number">2</span>&gt;err.txt</span><br></pre></td></tr></table></figure><p>然后我们分别查看suc.txt和err .txt的信息。</p><p><img src="http://img.blog.csdn.net/20161001150059408" alt="这里写图片描述"></p><p>将错误输出信息关闭掉</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># ls test1.sh xiho 2&gt;&amp;-</span></span><br><span class="line">test1.sh</span><br><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># ls test1.sh xiho 2&gt;/dev/null</span></span><br><span class="line">test1.sh</span><br><span class="line"></span><br><span class="line">&amp;[n] 代表是已经存在的文件描述符，&amp;<span class="number">1</span> 代表输出 &amp;<span class="number">2</span>代表错误输出 &amp;-代表关闭与它绑定的描述符</span><br><span class="line">/dev/null 这个设备，是linux 中黑洞设备，什么信息只要输出给这个设备，都会给吃掉，哈哈~</span><br></pre></td></tr></table></figure><p>其他的追加操作符等，好玩的自己去试试。</p><p><strong>注意：</strong><br>1、shell遇到”&gt;”操作符，会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。 无论左边命令执行是否成功。右边文件都会变为空。<br>2、“&gt;&gt;”操作符，判断右边文件，如果不存在，先创建。以添加方式打开文件，会分配一个文件描述符[不特别指定，默认为1,2]然后，与左边的标准输出（1）或错误输出（2） 绑定。<br>3、当命令：执行完，绑定文件的描述符也自动失效。0,1,2又会空闲。<br>4、一条命令启动，命令的输入，正确输出，错误输出，默认分别绑定0,1,2文件描述符。<br>5、一条命令在执行前，先会检查输出是否正确，如果输出设备错误，将不会进行命令执行。</p><hr><h4 id="2、Here-Document"><a href="#2、Here-Document" class="headerlink" title="2、Here Document"></a><strong>2、Here Document</strong></h4><p>Here Document是shell 中的一种特殊重定向方式，用来将输入重定向到一个交互式的shell脚本或程序。</p><p>基本的格式如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span> &lt;&lt; <span class="title">EOF</span></span><br><span class="line">document</span><br><span class="line"><span class="literal">EOF</span></span><br></pre></td></tr></table></figure><p>它的作用是将两个EOF之间的内容（docuemnt）作为输入传递给command。</p><blockquote><p>注意：</p><ul><li>结尾的EOF一定要顶个写，前面不能有任何字符，后面也不能有任何字符，包括空格和tab缩进。</li><li>开始的EOF前后的空格不要被忽略掉。</li></ul></blockquote><ul><li><strong>实例</strong></li></ul><p>在命令行中通过wc -l 命令计算Here Document 的行数：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># wc -l &lt;&lt; EOF</span></span><br><span class="line">&gt; 学习使用shell 编程</span><br><span class="line">&gt; www.xuhaoblog.com</span><br><span class="line">&gt; EOF</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出的结果为2行。</p><p>我们也可以将Here Document 用在脚本中，例如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash                                                            </span><br><span class="line">  <span class="number">2</span> cat &lt;&lt; <span class="literal">EOF</span></span><br><span class="line">  <span class="number">3</span> 学习使用shell脚本编程</span><br><span class="line">  <span class="number">4</span> www.xuhaoblog.com</span><br><span class="line">  <span class="number">5</span> <span class="literal">EOF</span></span><br></pre></td></tr></table></figure><p>执行以上脚本输出的结果：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># chmod u+x 05.sh </span></span><br><span class="line">root<span class="variable">@iZ28t5k4ny4Z</span><span class="symbol">:/usr/xiho/shell</span><span class="comment"># ./05.sh</span></span><br><span class="line">学习使用shell脚本编程</span><br><span class="line">www.xuhaoblog.com</span><br></pre></td></tr></table></figure><p>Here Document 的简单使用就到这里，还有更多的操作符需要我们去练习。Linux shell脚本基础学习，我们差不多介绍完了，还有一个关于函数的，准备放到下一篇来讲。欢迎关注~</p><hr><h3 id="更多相关系列传送门："><a href="#更多相关系列传送门：" class="headerlink" title="更多相关系列传送门："></a>更多相关系列传送门：</h3><p><strong>【个人博客】shel 脚本系列</strong></p><ul><li><a href="http://xuhaoblog.com/linux/shell-script-01.html">【Linux 系统编程】shell 脚本基础学习（一）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-02.html">【Linux 系统编程】shell 命令和流程控制（二）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-03.html">【Linux 系统编程】shell 流程控制loop和引号（三）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-04.html">【Linux 系统编程】shell 输入/输出重定向（四）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-05.html">【Linux 系统编程】shell 脚本基础学习之函数（五）</a></li></ul><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 流程控制Loop和引号（三）</title>
      <link href="/2016/09/30/linux/shell-script-03/"/>
      <url>/2016/09/30/linux/shell-script-03/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux shell 脚本基础学习第三篇；<br><a href="http://xuhaoblog.com/linux/shell-script-02.html">上一篇</a>Liunx shell  脚本基础学习中，我们讲到了Linux shell 脚本中控制流程的if、select、case，这里接着介绍Linux shell 脚本控制流程的loop和引导，控制流程这部分内容较多，还有一部分是关于here document。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><a href="http://xuhaoblog.com/linux/shell-script-02.html">继上篇之后</a></p><h4 id="4、loop"><a href="#4、loop" class="headerlink" title="4、loop"></a><strong>4、loop</strong></h4><p>loop 表达式：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="params">...</span>; <span class="keyword">do</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>while- loop 将运行一直到表达式测试为真。<br>（will run while the expression that we test for is true.）</p><p>关键字“break”用来跳出循环。而关键字“continue”用来不执行余下的部分而直接太偶倒下一个循环。</p><p>for-loop 表达式查看一个字符串列表（字符串用空格分隔）然后将其赋给一个变量：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">..</span><span class="built_in">..</span>; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><!-- more --><p>在下面的例子中，将分别打印ABC到屏幕上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> A B C ; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"var is <span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面是一个更为有用的脚本<strong>showrpm</strong>，其功能是打印一些RPM包的统计信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># list a content summary of a number of RPM packages</span></span><br><span class="line"><span class="comment"># USAGE: showrpm rpmfile1 rpmfile2 ...</span></span><br><span class="line"><span class="comment"># EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rpmpackage <span class="keyword">in</span> $*; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$rpmpackage</span>"</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=============== <span class="variable">$rpmpackage</span> =============="</span></span><br><span class="line">rpm -qi -p <span class="variable">$rpmpackage</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ERROR: cannot read file <span class="variable">$rpmpackage</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。<br>如果您运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showrpm openssh<span class="selector-class">.rpm</span> w3m<span class="selector-class">.rpm</span> webgrep.rpm</span><br></pre></td></tr></table></figure><p><strong>此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm</strong></p><hr><h4 id="5、引号"><a href="#5、引号" class="headerlink" title="5、引号"></a><strong>5、引号</strong></h4><p>在想程序传递任何参数之前，程序会扩展通配符和变量。这里所谓的扩展的意思是程序会把通配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防止程序做这种替换，您可以使用引号。</p><p><font color="blue" size="4"><strong>下面是shell引用类型:</strong></font></p><ul><li>“”  双引号</li><li>‘’   单引号</li><li>`    反引号</li><li>\    反斜线</li></ul><h5 id="5-1、双引号"><a href="#5-1、双引号" class="headerlink" title="5.1、双引号"></a><strong>5.1、双引号</strong></h5><p>使用双引号，可引用除了字符$、`、\外的任意字符或字符串。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">STR=<span class="string">"My name is xuhao"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$STR</span>"</span></span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My <span class="built_in">name</span> <span class="keyword">is</span> xuhao</span><br></pre></td></tr></table></figure><p>也可以去掉双引号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$STR</span></span><br></pre></td></tr></table></figure><p>执行脚本输出的结果还是一样的。</p><p><font color="red">双引号可以使具有特殊含义的词失去其原本的意义，如下：</font></p><p><img src="http://img.blog.csdn.net/20160930140550992" alt="这里写图片描述"></p><p>特殊含义的cal,执行的是显示出2016年 12月的日历。</p><p>但是我们将cal 命令复制给一个变量，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAL=<span class="string">"cal"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$CAL</span></span><br></pre></td></tr></table></figure><p>最后输出cal<br>这里，双引号使cal 命令失去了原有的显示日历的功能；在这里双引号类似于转义字符。</p><h5 id="5-2、单引号"><a href="#5-2、单引号" class="headerlink" title="5.2、单引号"></a><strong>5.2、单引号</strong></h5><p>　　单引号与双引号类似，不同的是shell 会忽略任何引用值，即屏蔽的单引号内的特殊字符的原本含义。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo ‘<span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $LOGNAME’</span><br><span class="line">其结果为：</span><br><span class="line"><span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $LOGNAME</span><br></pre></td></tr></table></figure><h5 id="5-3、单引号和双引号的区别"><a href="#5-3、单引号和双引号的区别" class="headerlink" title="5.3、单引号和双引号的区别"></a><strong>5.3、单引号和双引号的区别</strong></h5><p>单引号‘’：取消除单引号以外的任何字符的特殊含义。<br>如：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`echo ‘<span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $<span class="built_in">name</span>`’</span><br></pre></td></tr></table></figure><p>其结果为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $<span class="built_in">name</span></span><br><span class="line">此时$只作为一个普通字符使用了。 </span><br><span class="line">双引号“”：取消除双引号、$号以及_号以外的所有字符的特殊含义</span><br></pre></td></tr></table></figure><p>单引号是强引用，引号里的值是什么，变量的值就是什么；</p><p>双引号是弱引用，引号里的值若再包含变量，那在赋值的时候，所有这些变量就被立即替换了。</p><h5 id="5-4、反引号"><a href="#5-4、反引号" class="headerlink" title="5.4、反引号"></a><strong>5.4、反引号</strong></h5><p>反引号（`）用于设置系统命令输出到变量，shell认为反引号中的内容是一个系统命令，<br>所以将会执行之：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br><span class="line"><span class="symbol">Mon Dec 24 16:06:</span><span class="number">55</span> CST <span class="number">2012</span></span><br></pre></td></tr></table></figure><p>这和直接输入date命令是一样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">date</span></span><br><span class="line"><span class="selector-tag">Mon</span> <span class="selector-tag">Dec</span> 24 16<span class="selector-pseudo">:07</span><span class="selector-pseudo">:12</span> <span class="selector-tag">CST</span> 2012</span><br></pre></td></tr></table></figure><p>若输入一个非系统命令，则shell不认识此命令，将会报错：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">DATE</span>`</span><br><span class="line">ksh: <span class="built_in">DATE</span>: <span class="built_in">not</span> found</span><br></pre></td></tr></table></figure></p><h5 id="5-5、反斜杠"><a href="#5-5、反斜杠" class="headerlink" title="5.5、反斜杠"></a><strong>5.5、反斜杠</strong></h5><p>反斜杠起的作用是将一些特殊字符按原样输出，这些特殊字符有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">、*、`、+、^、&amp;、|、<span class="string">"、?。</span></span></span><br></pre></td></tr></table></figure><p>例如：echo *<br>将当前目录下的文件名和目录名都列出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \*</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>而使用反斜杠转义之后，就输出了星号。</p><hr><h2 id="更多相关系列传送门："><a href="#更多相关系列传送门：" class="headerlink" title="更多相关系列传送门："></a>更多相关系列传送门：</h2><p><strong>【个人博客】shel 脚本系列</strong></p><ul><li><a href="http://xuhaoblog.com/linux/shell-script-01.html">【Linux 系统编程】shell 脚本基础学习（一）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-02.html">【Linux 系统编程】shell 命令和流程控制（二）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-03.html">【Linux 系统编程】shell 流程控制loop和引号（三）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-04.html">【Linux 系统编程】shell 输入/输出重定向（四）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-05.html">【Linux 系统编程】shell 脚本基础学习之函数（五）</a></li></ul><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 命令和流程控制（二）</title>
      <link href="/2016/09/29/linux/shell-script-02/"/>
      <url>/2016/09/29/linux/shell-script-02/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linxu shell 脚本基础这里介绍到第二篇，详细介绍shell 命令和流程控制，这部分介绍三类命令，在学习时大家应该加以比较学习。<br>Linux shell脚本基础课程<a href="http://xuhaoblog.com/linux/shell-script-01.html">前面一篇</a>介绍的都是语法基础的开头、注释、变量和 环境变量，这里将介绍shell命令和控制流程的第一部分，在shell脚本中可以使用三类命令，而控制流程就放在下一讲吧。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="1-1-5-Shell命令和流程控制"><a href="#1-1-5-Shell命令和流程控制" class="headerlink" title="1.1.5 Shell命令和流程控制"></a><strong>1.1.5 Shell命令和流程控制</strong></h2><p>在shell脚本中可以使用三类命令：</p><h3 id="1-Unix-命令"><a href="#1-Unix-命令" class="headerlink" title="1)Unix 命令:"></a><strong>1)Unix 命令:</strong></h3><p>虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。</p><p>常用命令语法及功能</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"some text"</span>: 将文字内容打印在屏幕上</span><br><span class="line"></span><br><span class="line"><span class="keyword">l</span><span class="variable">s:</span> 文件列表</span><br><span class="line"></span><br><span class="line">wc –<span class="keyword">l</span> filewc -<span class="keyword">w</span> filewc -<span class="keyword">c</span> <span class="keyword">file</span>: 计算文件行数计算文件中的单词数计算文件中的字符数</span><br><span class="line"></span><br><span class="line"><span class="keyword">cp</span> sourcefile destfile: 文件拷贝</span><br><span class="line"></span><br><span class="line">mv oldname newname : 重命名文件或移动文件</span><br><span class="line"></span><br><span class="line">rm <span class="keyword">file</span>: 删除文件</span><br><span class="line"></span><br><span class="line"><span class="keyword">grep</span> <span class="string">'pattern'</span> <span class="keyword">file</span>: 在文件内搜索字符串比如：<span class="keyword">grep</span> <span class="string">'searchstring'</span> <span class="keyword">file</span>.txt</span><br><span class="line"></span><br><span class="line">cut -<span class="keyword">b</span> colnum <span class="keyword">file</span>: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第<span class="number">5</span>个到第<span class="number">9</span>个字</span><br><span class="line">符cut -b5-<span class="number">9</span> <span class="keyword">file</span>.txt千万不要和<span class="keyword">cat</span>命令混淆，这是两个完全不同的命令</span><br><span class="line"></span><br><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.tx<span class="variable">t:</span> 输出文件内容到标准输出设备（屏幕）上</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span> somefile: 得到文件类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">read</span> var: 提示用户输入，并将输入赋值给变量</span><br><span class="line"></span><br><span class="line"><span class="keyword">sort</span> <span class="keyword">file</span>.tx<span class="variable">t:</span> 对<span class="keyword">file</span>.txt文件中的行进行排序</span><br><span class="line"></span><br><span class="line">uniq: 删除文本文件中出现的行列比如： <span class="keyword">sort</span> <span class="keyword">file</span>.txt | uniq</span><br><span class="line"></span><br><span class="line">expr: 进行数学运算Example: <span class="built_in">add</span> <span class="number">2</span> <span class="built_in">and</span> <span class="number">3</span>expr <span class="number">2</span> <span class="string">"+"</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">find</span>: 搜索文件比如：根据文件名搜索<span class="keyword">find</span> . -name filename -<span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile</span><br><span class="line"></span><br><span class="line">basename <span class="keyword">file</span>: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux</span><br><span class="line"></span><br><span class="line">dirname <span class="keyword">file</span>: 返回文件所在路径比如：dirname /bin/tux将返回 /bin</span><br><span class="line"></span><br><span class="line">head <span class="keyword">file</span>: 打印文本文件开头几行</span><br><span class="line"></span><br><span class="line">tail <span class="keyword">file</span> : 打印文本文件末尾几行</span><br><span class="line"></span><br><span class="line">sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将</span><br><span class="line">结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和<span class="keyword">shell</span>中的通配符相混淆。比如：将linuxfocus 替换为LinuxFocus ：<span class="keyword">cat</span> text.<span class="keyword">file</span> | sed <span class="string">'s/linuxfocus/LinuxFocus/'</span> &gt; </span><br><span class="line"></span><br><span class="line">newtext.fileawk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。</span><br><span class="line"></span><br><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt | awk -F, <span class="string">'&#123;print $1 "," $3 &#125;'</span>这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, <span class="number">34</span>, IndiaKerry Miller, <span class="number">22</span>, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA</span><br></pre></td></tr></table></figure><hr><h3 id="2-概念-管道-重定向和-backtick"><a href="#2-概念-管道-重定向和-backtick" class="headerlink" title="2) 概念: 管道, 重定向和 backtick"></a><strong>2) 概念: 管道, 重定向和 backtick</strong></h3><font color="red">这些不是系统命令，但是他们真的很重要。</font><p><strong>管道 (|)：</strong><br> 将一个命令的输出作为另外一个命令的输入。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">"hello"</span> <span class="keyword">file</span>.txt | wc -l</span><br></pre></td></tr></table></figure><p>在file.txt中搜索包含有”hello”的行并计算其行数。<br>在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。</p><p><strong>重定向：</strong><br>将命令的结果输出到文件，而不是标准输出（屏幕）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 写入文件并覆盖旧文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; 加到文件的尾部，保留旧文件内容。</span></span><br></pre></td></tr></table></figure><p><strong>反短斜线：</strong><br>使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br>命令：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -mtime -<span class="number">1</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># The ticks are backticks (`) not normal quotes ('):</span></span><br><span class="line">tar -zcvf lastmod.tar.gz `find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">print</span>`</span><br></pre></td></tr></table></figure><hr><h3 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3) 流程控制"></a><strong>3) 流程控制</strong></h3><h4 id="1-if"><a href="#1-if" class="headerlink" title="1.if"></a><strong>1.if</strong></h4><p>“if” 表达式 如果条件为真则执行then后面的部分：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">..</span><span class="built_in">..</span>; then</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">elif <span class="built_in">..</span><span class="built_in">..</span>; then</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…</p><p>通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ -f <span class="string">"somefile"</span> ] ：判断是否是一个文件</span><br><span class="line">[ -x <span class="string">"/bin/ls"</span> ] ：判断/bin/ls是否存在并有可执行权限</span><br><span class="line">[ -n <span class="string">"<span class="variable">$var</span>"</span> ] ：判断<span class="variable">$var</span>变量是否有值</span><br><span class="line">[ <span class="string">"<span class="variable">$a</span>"</span> = <span class="string">"<span class="variable">$b</span>"</span> ] ：判断<span class="variable">$a</span>和<span class="variable">$b</span>是否相等</span><br></pre></td></tr></table></figure><p>执行man test可以查看所有测试表达式可以比较和判断的类型。<br>直接执行以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHELL</span>"</span> = <span class="string">"/bin/bash"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"your login shell is the bash (bourne again shell)"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"your login shell is not bash but <span class="variable">$SHELL</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。<br>快捷操作符<br>熟悉C语言的朋友可能会很喜欢下面的表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -f <span class="string">"/etc/shadow"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"This computer uses shadow passwors"</span></span><br></pre></td></tr></table></figure><p>这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。</p><p>您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mailfolder=/var/spool/mail/james</span><br><span class="line">[ -r <span class="string">"<span class="variable">$mailfolder</span>"</span> ]<span class="string">' '</span>&#123; <span class="built_in">echo</span> <span class="string">"Can not read <span class="variable">$mailfolder</span>"</span> ; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$mailfolder</span> has mail from:"</span></span><br><span class="line">grep <span class="string">"^From "</span> <span class="variable">$mailfolder</span></span><br></pre></td></tr></table></figure><p>该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：</p><ul><li>打印错误信息</li><li>退出程序<br>我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。<br>不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。</li></ul><h4 id="2-case"><a href="#2-case" class="headerlink" title="2.case"></a><strong>2.case</strong></h4><p><strong>case :</strong>表达式可以用来匹配一个给定的字符串，而不是数字。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="params">...</span> <span class="keyword">in</span></span><br><span class="line"><span class="params">...</span>) <span class="keyword">do</span> something here ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：<br>file lf.gz<br>这将返回：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lf</span><span class="selector-class">.gz</span>: <span class="selector-tag">gzip</span> <span class="selector-tag">compressed</span> <span class="selector-tag">data</span>, <span class="selector-tag">deflated</span>, <span class="selector-tag">original</span> <span class="selector-tag">filename</span>,</span><br><span class="line"><span class="selector-tag">last</span> <span class="selector-tag">modified</span>: <span class="selector-tag">Mon</span> <span class="selector-tag">Aug</span> 27 23<span class="selector-pseudo">:09</span><span class="selector-pseudo">:18</span> 2001, <span class="selector-tag">os</span>: <span class="selector-tag">Unix</span></span><br></pre></td></tr></table></figure><p>我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ftype=`file <span class="string">"<span class="variable">$1</span>"</span>`</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$ftype</span>"</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">"<span class="variable">$1</span>: Zip archive"</span>*)</span><br><span class="line">unzip <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line"><span class="string">"<span class="variable">$1</span>: gzip compressed"</span>*)</span><br><span class="line">gunzip <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line"><span class="string">"<span class="variable">$1</span>: bzip2 compressed"</span>*)</span><br><span class="line">bunzip2 <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line">*) <span class="built_in">echo</span> <span class="string">"File <span class="variable">$1</span> can not be uncompressed with smartzip"</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。<br>也就是说，当我们运行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">smartzip</span> <span class="selector-tag">articles</span><span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure><p>$1 就是字符串 articles.zip</p><h4 id="3-selsect"><a href="#3-selsect" class="headerlink" title="3. selsect"></a><strong>3. selsect</strong></h4><p>select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">var</span> <span class="keyword">in</span> <span class="params">...</span> ; <span class="keyword">do</span></span><br><span class="line">break</span><br><span class="line">done</span><br><span class="line"><span class="params">...</span>. now $var can be used <span class="params">...</span>.</span><br></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"What is your favourite OS?"</span></span><br><span class="line">select var <span class="keyword">in</span> <span class="string">"Linux"</span> <span class="string">"Gnu Hurd"</span> <span class="string">"Free BSD"</span> <span class="string">"Other"</span>; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"You have selected <span class="variable">$var</span>"</span></span><br></pre></td></tr></table></figure><p>下面是该脚本运行的结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">What is your favourite OS?</span><br><span class="line"><span class="number">1</span>) Linux</span><br><span class="line"><span class="number">2</span>) Gnu Hurd</span><br><span class="line"><span class="number">3</span>) Free BSD</span><br><span class="line"><span class="number">4</span>) Other</span><br><span class="line">#? <span class="number">1</span></span><br><span class="line">You have selected Linux</span><br></pre></td></tr></table></figure><p>上面就是这一篇的内容，控制流程比较多，这里先介绍这三个。下篇继续。。。</p><hr><h2 id="更多相关系列传送门："><a href="#更多相关系列传送门：" class="headerlink" title="更多相关系列传送门："></a>更多相关系列传送门：</h2><p><strong>【个人博客】shel 脚本系列</strong></p><ul><li><a href="http://xuhaoblog.com/linux/shell-script-01.html">【Linux 系统编程】shell 脚本基础学习（一）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-02.html">【Linux 系统编程】shell 命令和流程控制（二）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-03.html">【Linux 系统编程】shell 流程控制loop和引号（三）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-04.html">【Linux 系统编程】shell 输入/输出重定向（四）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-05.html">【Linux 系统编程】shell 脚本基础学习之函数（五）</a></li></ul><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见,共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 脚本基础学习（一）</title>
      <link href="/2016/09/29/linux/shell-script-01/"/>
      <url>/2016/09/29/linux/shell-script-01/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux shell 脚本基础我们将分几篇文章来记录，希望对我们这些初次接触Linxu shell脚本编程的初学者有帮助；<br>Linxu shell 脚本基础学习先来介绍shell的语法，开头、注释、变量和环境，虽然不涉及到具体的东西，但是大号基础是以后学习的前提，很多时候我们拿到别人的开源库，需要编译使用，但是由于各种原因，总是编译不成功，其中就有shell 脚本，如果我们看不懂别人的脚本，编译出错，还查不来原因。（比如一个空格导致编译失败，你能查出原因么？）<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Linux-脚本编写基础"><a href="#1-Linux-脚本编写基础" class="headerlink" title="1.Linux 脚本编写基础"></a>1.Linux 脚本编写基础</h3><h4 id="1-1-语法的基本介绍"><a href="#1-1-语法的基本介绍" class="headerlink" title="1.1 语法的基本介绍"></a>1.1 语法的基本介绍</h4><h5 id="1-1-1-开头"><a href="#1-1-1-开头" class="headerlink" title="1.1.1 开头"></a><strong>1.1.1 开头</strong></h5><p>程序必须以下面的行开始（必须放在文件的第一行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><p>符号”#!”用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br>当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br>要使脚本可执行：<br>编译 chmod  u+x filename 这样才能用./filename 来运行</p><h5 id="1-1-2-注释"><a href="#1-1-2-注释" class="headerlink" title="1.1.2 注释"></a><strong>1.1.2 注释</strong></h5><p>在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。<br>如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。</p><h5 id="1-1-3-变量"><a href="#1-1-3-变量" class="headerlink" title="1.1.3 变量"></a><strong>1.1.3 变量</strong></h5><p>在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#对变量赋值：</span></span><br><span class="line">a=<span class="string">"hello world"</span></span><br><span class="line"><span class="comment"># 现在打印变量a的内容：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A is:"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p>有时候变量名很容易与其他文字混淆，比如：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">num</span>=2</span><br><span class="line">echo <span class="string">"this is the <span class="variable">$numnd</span>"</span></span><br></pre></td></tr></table></figure></p><p>这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">num</span>=2</span><br><span class="line">echo <span class="string">"this is the <span class="variable">$&#123;num&#125;</span>nd"</span></span><br></pre></td></tr></table></figure></p><p>这将打印： this is the 2nd</p><h5 id="1-1-4-环境变量"><a href="#1-1-4-环境变量" class="headerlink" title="1.1.4 环境变量"></a><strong>1.1.4 环境变量</strong></h5><p>由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。</p><p>这一篇就介绍到这里，下面我们会接触到具体的Linux shell脚本基础的实质部分。</p><hr><h2 id="更多相关系列传送门："><a href="#更多相关系列传送门：" class="headerlink" title="更多相关系列传送门："></a>更多相关系列传送门：</h2><p><strong>【个人博客】shel 脚本系列</strong></p><ul><li><a href="http://xuhaoblog.com/linux/shell-script-01.html">【Linux 系统编程】shell 脚本基础学习（一）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-02.html">【Linux 系统编程】shell 命令和流程控制（二）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-03.html">【Linux 系统编程】shell 流程控制loop和引号（三）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-04.html">【Linux 系统编程】shell 输入/输出重定向（四）</a></li><li><a href="http://xuhaoblog.com/linux/shell-script-05.html">【Linux 系统编程】shell 脚本基础学习之函数（五）</a></li></ul><blockquote><p>本文由博主辛苦整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux环境下 Vim的安装配置及使用</title>
      <link href="/2016/09/29/linux/vim-config/"/>
      <url>/2016/09/29/linux/vim-config/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Learn vim and it will be your last text editor. There isn’t any better text editor that I know of. It is hard to learn, but incredible to use.<br>学习VIM，它会是你最后的文本编辑器。没有任何好转的文本编辑器，我知道的。这是很难学，但令人难以置信的使用。</p><p>VI是LINUX下最老牌的编辑工具，而VIM则是VI的升级版本，LINUX系统必备啊~~</p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p><strong>（以下已Ubuntu系统为例）</strong></p><h4 id="VIM的安装和配置"><a href="#VIM的安装和配置" class="headerlink" title="VIM的安装和配置"></a><strong>VIM的安装和配置</strong></h4><h5 id="1、VIM安装"><a href="#1、VIM安装" class="headerlink" title="1、VIM安装"></a><strong>1、VIM安装</strong></h5><p>既然VIM编辑器是在Linux 系统环境下运行的，那么我们首先要在Ubuntu上安装VIM；<br>在命令行敲入“vi”后按”tab”键，可以查看到目前系统中有没有安装Vim，如果没有的话就只会显示vi和vim.tiny。如下图(我是已经安装了的）</p><p><img src="http://img.blog.csdn.net/20160929104119636" alt="这里写图片描述"></p><p>如果没有安装VIM，普通用户下输入命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install vim-gtk</span><br></pre></td></tr></table></figure><p>然后按照提示，输入“y”后，回车，之后不要进行任何操作，等待安装完成。安装完成后，在命令行输入vi，按“tab”键。如上图，说明vim已经安装成功~</p><h5 id="2、VIM配置"><a href="#2、VIM配置" class="headerlink" title="2、VIM配置"></a><strong>2、VIM配置</strong></h5><p>刚安装的VIM，默认的配置可能不是很好使用，这就需要我们去配置VIM，在命令下，输入命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/<span class="keyword">vim</span>/vimrc</span><br></pre></td></tr></table></figure><p>必须加上sudo，否则你是没有权限编辑vimrc的。</p><p>在这个文件中，会有这么一句：<br><strong>syntax on</strong><br>意思是语法高亮，如果您的被注释掉了，请“让它出来”，就如下图所示：</p><p><img src="http://img.blog.csdn.net/20160929105720795" alt="这里写图片描述"></p><p>接着我们在VIM配置文件的最后一行，加入以下配置，会使我们方便很多。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> nu                           // 在左侧行号</span><br><span class="line"><span class="keyword">set</span> <span class="comment">tabstop</span>                  //<span class="comment">tab</span> 长度设置为<span class="comment"> 4</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">nobackup</span>               //覆盖文件时不备份</span><br><span class="line"><span class="keyword">set</span> <span class="comment">cursorline</span>               //突出显示当前行</span><br><span class="line"><span class="keyword">set</span> <span class="comment">ruler</span>                       //在右下角显示光标位置的状态行</span><br><span class="line"><span class="keyword">set</span> <span class="comment">autoindent</span>             //自动缩进</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160929110041781" alt="这里写图片描述"></p><p>保存之后，配置完毕。<br>上面的配置，其实是非常简单的，比如一些配色方案等，小编并没有写入，如果您还有其他需求的话，建议多查些资料。</p><hr><h4 id="VIM常用的基本命令"><a href="#VIM常用的基本命令" class="headerlink" title="VIM常用的基本命令"></a><strong>VIM常用的基本命令</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">1. vim #在命令行中输入vim,进入vim编辑器 </span><br><span class="line"></span><br><span class="line">2. i #按一下i键,下端显示 --INSERT-- </span><br><span class="line"><span class="meta">#</span><span class="bash">插入命令,在vim中可能任意字符都有作用 </span></span><br><span class="line"></span><br><span class="line">3. Esc </span><br><span class="line"><span class="meta">#</span><span class="bash">退出i(插入)命令进行其它命令使用</span></span><br><span class="line"></span><br><span class="line">4. :r filename </span><br><span class="line"><span class="meta">#</span><span class="bash">读入一个文件内容,并写入到当前编辑器中 </span></span><br><span class="line"></span><br><span class="line">5. :w newfilename </span><br><span class="line"><span class="meta">#</span><span class="bash">将该编辑器中的内容写入到一个新文件中 </span></span><br><span class="line"></span><br><span class="line">6. :w </span><br><span class="line"><span class="meta">#</span><span class="bash">在编辑的过程中保存文件,相当于word中的ctrl+s </span></span><br><span class="line"></span><br><span class="line">7. :! command </span><br><span class="line">暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 :!ls </span><br><span class="line"><span class="meta">#</span><span class="bash">在编辑过程中执行shell命令ls </span></span><br><span class="line"></span><br><span class="line">8. :sh </span><br><span class="line"><span class="meta">#</span><span class="bash">进入shell命令行,执行完命令后ctrl+d退出重新进入vim编辑继续编辑 在shell命令下，执行ctral+l完成清屏 </span></span><br><span class="line"></span><br><span class="line">9. :wq </span><br><span class="line"><span class="meta">#</span><span class="bash">保存文件并退出 </span></span><br><span class="line"></span><br><span class="line">10. ZZ </span><br><span class="line"><span class="meta">#</span><span class="bash">保存文件并退出,同上一个命令,注意大写 </span></span><br><span class="line"></span><br><span class="line">11. :q! </span><br><span class="line"><span class="meta">#</span><span class="bash">强制退出,不保存 </span></span><br><span class="line"></span><br><span class="line">12. :set number或者：set nu </span><br><span class="line"><span class="meta">#</span><span class="bash">使编辑中的文件显示行号 </span></span><br><span class="line"></span><br><span class="line">13. :set nonumber或者：set nonu  </span><br><span class="line"><span class="meta">#</span><span class="bash">与上一条命令相反,不显示行号 </span></span><br><span class="line"></span><br><span class="line">14. :help i </span><br><span class="line"><span class="meta">#</span><span class="bash">查看插入命令帮助 </span></span><br><span class="line"></span><br><span class="line">15. u  </span><br><span class="line"><span class="meta">#</span><span class="bash">撤消上一步操作 </span></span><br><span class="line"></span><br><span class="line">16. /Fedora </span><br><span class="line"><span class="meta">#</span><span class="bash">查找Fedora字符 </span></span><br><span class="line"></span><br><span class="line">17. :s /Fedora/Redhat </span><br><span class="line"><span class="meta">#</span><span class="bash">将Fedora字符替换为Redhat(只替换在光标所在的行) </span></span><br><span class="line"></span><br><span class="line">18. dw #删除单词 </span><br><span class="line">    dd #删除行 </span><br><span class="line"></span><br><span class="line">19. o </span><br><span class="line"><span class="meta">#</span><span class="bash">打开空白一行 </span></span><br><span class="line"></span><br><span class="line">20. vim + filename </span><br><span class="line"><span class="meta">#</span><span class="bash">进行文件最后一行进行编辑 </span></span><br><span class="line"></span><br><span class="line">21. vim +n filename </span><br><span class="line"><span class="meta">#</span><span class="bash">进入文件第n行进行编辑 </span></span><br><span class="line"></span><br><span class="line">22. :1,.s/redhat/fedora </span><br><span class="line"><span class="meta">#</span><span class="bash">.号表示当前行,即光标所在行 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">将第1行到当前行(.)第一次出现的redhat字符代替为fedora </span></span><br><span class="line"></span><br><span class="line">23. :1,.s/redhat/fedora/g </span><br><span class="line"><span class="meta">#</span><span class="bash">将第1行到当前行(.)所有出现的redhat字符代替为fedora,g 全局标志 </span></span><br><span class="line"></span><br><span class="line">24. :1,$s/redhat/fedora/g </span><br><span class="line"><span class="meta">#</span><span class="bash">$表示最后一行 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">将第1行到最后一行所有出现的redhat字符代替为fedora </span></span><br><span class="line"></span><br><span class="line">25. :%s/redhat/fedora/g #同上一个命令 </span><br><span class="line"></span><br><span class="line">26. :%s/\/fedora/g </span><br><span class="line"><span class="meta">#</span><span class="bash">将第1行到最后一行所有出现的redhat字代替为fedora <span class="comment">#字,而不是字符</span></span></span><br><span class="line"></span><br><span class="line">27. :f </span><br><span class="line"><span class="meta">#</span><span class="bash">显示文件内容,状态等等 <span class="comment">#同ctrl+g命令 </span></span></span><br><span class="line"></span><br><span class="line">28. :e! </span><br><span class="line"><span class="meta">#</span><span class="bash">当前文件,返回到上次保存 :e file </span></span><br><span class="line"><span class="meta">#</span><span class="bash">切换编辑文件 </span></span><br><span class="line"></span><br><span class="line">29. :n </span><br><span class="line"><span class="meta">#</span><span class="bash">当编辑时有多个文件(比如vim file1 file2)时切换到下一个文件,与:e file 结合使用</span></span><br></pre></td></tr></table></figure><blockquote><p>学习理解并整理下来的笔记;<br>希望大家能够指点或提出宝贵意见,共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 常用的一些基本命令</title>
      <link href="/2016/09/28/linux/cmd/"/>
      <url>/2016/09/28/linux/cmd/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><p>Linux提供了大量的命令，利用它可以有效地完成大量的工作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。所以，在Linux系统上工作离不开使用系统提供的命令。要想真正理解Linux系统，就必须从Linux命令学起，通过基础的命令学习可以进一步理解Linux系统，<br>下面就来简单总结下常用的基础操作命令。</p><a id="more"></a><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h4><h5 id="（1）指令名称：pwd"><a href="#（1）指令名称：pwd" class="headerlink" title="（1）指令名称：pwd"></a><strong>（1）指令名称：pwd</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> 命令也是最常用最基本的命令之一，用于显示用户当前所在的目录。</span><br></pre></td></tr></table></figure><h5 id="（2）指令名称：cd"><a href="#（2）指令名称：cd" class="headerlink" title="（2）指令名称：cd"></a><strong>（2）指令名称：cd</strong></h5><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span>命令不仅显示当前状态，还改变当前状态，它的用法跟dos下的<span class="keyword">cd</span>命令基本一致。 </span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span>可进入上一层目录 </span><br><span class="line"><span class="keyword">cd</span> -可进入上一个进入的目录 </span><br><span class="line"><span class="keyword">cd</span> ~可进入用户的home目录</span><br></pre></td></tr></table></figure><h5 id="（3）指令名称：cp"><a href="#（3）指令名称：cp" class="headerlink" title="（3）指令名称：cp"></a><strong>（3）指令名称：cp</strong></h5><p>  使用方式：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> [<span class="keyword">options</span>] <span class="keyword">source</span> dest </span><br><span class="line"><span class="keyword">cp</span> [<span class="keyword">options</span>] <span class="keyword">source</span>... directory</span><br></pre></td></tr></table></figure><p>说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。</p><table><thead><tr><th>参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>-a</td><td style="text-align:left">尽可能将档案状态、权限等资料都照原状予以复制。</td></tr><tr><td>-r</td><td style="text-align:left">若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。</td></tr><tr><td>-f</td><td style="text-align:left">若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。</td></tr></tbody></table><p>比如： </p><p>将档案 aaa 复制(已存在)，并命名为 bbb : </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp<span class="built_in"> aaa </span>bbb</span><br></pre></td></tr></table></figure><p>将所有的C语言文件拷贝至 Finished 子目录中 : </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cp</span> <span class="regexp">*.c</span> Finished</span><br></pre></td></tr></table></figure><p>复制文件<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> src.txt dest.txt</span><br><span class="line"><span class="keyword">cp</span> -i src.txt dest.txt 询问</span><br><span class="line"><span class="keyword">cp</span> src.txt . 复制到当前目录</span><br><span class="line"><span class="keyword">cp</span> -R 目录 dest 复制整个目录到指定路径</span><br><span class="line"><span class="keyword">cp</span> c_?<span class="number">1</span> ../  通配符复制到上级目录</span><br></pre></td></tr></table></figure></p><h5 id="（4）指令名称：mv"><a href="#（4）指令名称：mv" class="headerlink" title="（4）指令名称：mv"></a><strong>（4）指令名称：mv</strong></h5><p>使用方式：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [<span class="keyword">options</span>] <span class="keyword">source</span> dest </span><br><span class="line">mv [<span class="keyword">options</span>] <span class="keyword">source</span>... directory</span><br></pre></td></tr></table></figure><p>说明：将一个档案移至另一档案，或将数个档案移至另一目录。<br>参数：-i 若目的地已有同名档案，则先询问是否覆盖旧档。 </p><p>将档案 aaa 更名为 bbb : </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv<span class="built_in"> aaa </span>bbb</span><br></pre></td></tr></table></figure><p>将所有的C语言程序移至 Finished 子目录中 : </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -<span class="selector-tag">i</span> *<span class="selector-class">.c</span> /Finished</span><br></pre></td></tr></table></figure><h5 id="（5）指令名称-chmod"><a href="#（5）指令名称-chmod" class="headerlink" title="（5）指令名称 : chmod"></a><strong>（5）指令名称 : chmod</strong></h5><p>使用方式 : </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure><p>说明 : Linux/Unix 的档案存取权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所存取。</p><p><strong>mode :</strong> 权限设定字串，格式如下 : [ugoa…][+-=][rwxX]…][,…]，其中u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 </p><ul><li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</li></ul><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">c若该档案权限确实已经更改，才显示其更改动作</span></span><br><span class="line"><span class="ruby">-f若该档案权限无法被更改也不要显示错误讯息</span></span><br><span class="line"><span class="ruby">-v显示权限变更的详细资料</span></span><br><span class="line"><span class="ruby">-R对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</span></span><br></pre></td></tr></table></figure><p>将档案 file1.txt 设为所有人皆可读取 : </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> <span class="selector-tag">ugo</span>+<span class="selector-tag">r</span> <span class="selector-tag">file1</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将档案 file1.txt 设为所有人皆可读取 : </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> <span class="selector-tag">a</span>+<span class="selector-tag">r</span> <span class="selector-tag">file1</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> <span class="selector-tag">ug</span>+<span class="selector-tag">w</span>,<span class="selector-tag">o-w</span> <span class="selector-tag">file1</span><span class="selector-class">.txt</span> <span class="selector-tag">file2</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>将 ex1.py 设定为只有该档案拥有者可以执行 : </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> <span class="selector-tag">u</span>+<span class="selector-tag">x</span> <span class="selector-tag">ex1</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure><p>将目前目录下的所有档案与子目录皆设为任何人可读取 : </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R <span class="keyword">a</span>+r *</span><br></pre></td></tr></table></figure><p>此外chmod也可以用数字来表示权限如 chmod 777 file </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法为：chmod <span class="keyword">abc</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r=<span class="number">4</span>，w=<span class="number">2</span>，x=<span class="number">1</span> </span><br><span class="line">若要rwx属性则<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span>=<span class="number">7</span>； </span><br><span class="line">若要rw-属性则<span class="number">4</span>+<span class="number">2</span>=<span class="number">6</span>；</span><br><span class="line">若要r-x属性则<span class="number">4</span>+<span class="number">1</span>=<span class="number">7</span>。</span><br></pre></td></tr></table></figure><p><strong>创建用户</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -m <span class="keyword">jack </span>创建用户的同时，创建了home目录</span><br><span class="line">userdel -r <span class="keyword">jack </span>删除用户</span><br></pre></td></tr></table></figure><p><strong>创建组</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">groupadd androidgroup</span></span><br></pre></td></tr></table></figure><p><strong>分配用户到组</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">usermod</span> -G <span class="keyword">androidgroup </span>jack</span><br></pre></td></tr></table></figure><p><strong>文件权限</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r读 w写 <span class="keyword">x</span>执行</span><br><span class="line">drwxr-xr-<span class="keyword">x</span></span><br><span class="line">d rwx r-<span class="keyword">x</span> r-<span class="keyword">x</span></span><br></pre></td></tr></table></figure><p><strong>d目录</strong></p><p>1.文件所属用户具备的权限（root对该文件具备读写执行权限）<br>2.文件所属用户的所属组具备的权限（读、执行）<br>3.系统的其他用户具备的权限（读、执行）</p><p>rwx必须是固定顺序</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">权限二进制八进制</span><br><span class="line">---<span class="number">000</span><span class="number">0</span></span><br><span class="line">--x<span class="number">001</span><span class="number">1</span></span><br><span class="line">-w-<span class="number">010</span><span class="number">2</span></span><br><span class="line">-wx<span class="number">011</span><span class="number">3</span></span><br><span class="line">r--<span class="number">100</span><span class="number">4</span></span><br><span class="line">r-x<span class="number">101</span><span class="number">5</span></span><br><span class="line">rw-<span class="number">110</span><span class="number">6</span></span><br><span class="line">rwx<span class="number">111</span><span class="number">7</span></span><br></pre></td></tr></table></figure><p>修改文件权限</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">644</span> <span class="built_in">file</span></span><br></pre></td></tr></table></figure><p>给用户加上执行权限</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x <span class="built_in">file</span></span><br></pre></td></tr></table></figure><p>改变创建目录的默认权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">umask</span> 026</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">777</span><span class="number">-026</span></span><br></pre></td></tr></table></figure><p>改变文件的所属</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown user.group file</span><br><span class="line">chown<span class="built_in"> user </span>file</span><br><span class="line">chown .group file</span><br></pre></td></tr></table></figure><h5 id="（6）指令名称-ls"><a href="#（6）指令名称-ls" class="headerlink" title="（6）指令名称 : ls"></a><strong>（6）指令名称 : ls</strong></h5><p>使用方式 :</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="string">[-alrtAFR]</span> <span class="string">[name...]</span></span><br></pre></td></tr></table></figure><p>说明 : 显示指定工作目录下之内容（列出目前工作目录所含之档案及子目录)。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数说明</span><br><span class="line">-<span class="ruby">a显示所有档案及目录 (ls内定将档案名或目录名称开头为<span class="string">"."</span>的视为隐藏档，不会列出) </span></span><br><span class="line"><span class="ruby">-l除档案名称外，亦将档案型态、权限、拥有者、档案大小等资讯详细列出 </span></span><br><span class="line"><span class="ruby">-r将档案以相反次序显示(原定依英文字母次序) </span></span><br><span class="line"><span class="ruby">-t将档案依建立时间之先后次序列出</span></span><br><span class="line"><span class="ruby">-A同 -a ，但不列出 <span class="string">"."</span> (目前目录) 及 <span class="string">".."</span> (父目录) </span></span><br><span class="line"><span class="ruby">-F在列出的档案名称后加一符号；例如可执行档则加 <span class="string">"*"</span>, 目录则加 <span class="string">"/"</span></span></span><br><span class="line"><span class="ruby">-R若目录下有档案，则以下之档案亦皆依序列出</span></span><br></pre></td></tr></table></figure><p>ls -l<br>ls -la 所有<br>ls -l ja* 通配符查找</p><p>例子：</p><p>列出目前工作目录下所有名称是 s 开头的档案，愈新的排愈后面 : </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -ltr s*</span><br></pre></td></tr></table></figure><p>将 /bin 目录以下所有目录及档案详细资料列出 : </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -lR <span class="string">/bin</span></span><br></pre></td></tr></table></figure><p>列出目前工作目录下所有档案及目录；目录于名称后加 “/“, 可执行档于名称后加 “*” : </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ls -AF</span></span><br></pre></td></tr></table></figure><h5 id="（7）指令名称：rm"><a href="#（7）指令名称：rm" class="headerlink" title="（7）指令名称：rm"></a><strong>（7）指令名称：rm</strong></h5><p>使用方式：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure><p>说明：删除档案及目录。 </p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数说明</span><br><span class="line">-<span class="ruby">i删除前逐一询问确认。</span></span><br><span class="line"><span class="ruby">-f即使原档案属性设为唯读，亦直接删除，无需逐一确认。</span></span><br><span class="line"><span class="ruby">-r将目录及以下之档案亦逐一删除。</span></span><br></pre></td></tr></table></figure><p>范例：<br>删除所有C语言程式档；删除前逐一询问确认 : </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rm</span> -i <span class="regexp">*.c</span></span><br></pre></td></tr></table></figure><p>将 Finished 子目录及子目录中所有档案删除 : </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rm -r Finished</span></span><br></pre></td></tr></table></figure><h5 id="（8）指令名称：rmdir"><a href="#（8）指令名称：rmdir" class="headerlink" title="（8）指令名称：rmdir"></a><strong>（8）指令名称：rmdir</strong></h5><p>使用方式：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir <span class="string">[-p]</span> dirName</span><br></pre></td></tr></table></figure><p>说明： 删除空的目录。 </p><p>参数： -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。<br>范例：<br>将工作目录下，名为 AAA 的子目录删除 : </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> AAA</span><br></pre></td></tr></table></figure><p>在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除。 </p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rmdir</span> -p BBB/<span class="keyword">Test</span></span><br></pre></td></tr></table></figure><h5 id="（9）指令名称：touch"><a href="#（9）指令名称：touch" class="headerlink" title="（9）指令名称：touch"></a><strong>（9）指令名称：touch</strong></h5><p> 使用方式： </p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch <span class="string">[-acfm]</span></span><br></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[-r reference-file]</span> <span class="comment">[--file=reference-file]</span> </span><br><span class="line"><span class="comment">[-t MMDDhhmm<span class="comment">[CC]</span>YY]</span><span class="comment">[.ss]</span> </span><br><span class="line"><span class="comment">[-d time]</span> <span class="comment">[--date=time]</span> <span class="comment">[--time=&#123;atime,access,use,mtime,modify&#125;]</span></span><br><span class="line"><span class="comment">[--no-create]</span> <span class="comment">[--help]</span> <span class="comment">[--version]</span> </span><br><span class="line">file1 <span class="comment">[file2 ...]</span></span><br></pre></td></tr></table></figure><p>说明：<br>touch 指令改变档案的时间记录。 ls -l 可以显示档案的时间记录。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数说明</span><br><span class="line"><span class="keyword">a</span>改变档案的读取时间记录</span><br><span class="line">m改变档案的修改时间记录</span><br><span class="line">c假如目的档案不存在，不会建立新的档案。</span><br><span class="line">f不使用，是为了与其他 unix 系统的相容性而保留</span><br><span class="line">r使用参考档的时间记录，与 <span class="comment">--file 的效果一样</span></span><br><span class="line">d设定时间与日期，可以使用各种不同的格式</span><br><span class="line">t设定档案的时间记录，格式与 <span class="built_in">date</span> 指令相同</span><br></pre></td></tr></table></figure><h5 id="（10）指令名称：gzip"><a href="#（10）指令名称：gzip" class="headerlink" title="（10）指令名称：gzip"></a><strong>（10）指令名称：gzip</strong></h5><p>说明：gzip命令用于压缩文件。<br>参数 ： -d 将压缩文件解压<br>范例：<br>如果要将ye.txt文件压缩，可用如下命令： </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gzip</span> <span class="selector-tag">ye</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>这样就可以压缩文件并在文件名后面加上gz扩展名，变成文件ye.txt.gz。<br>解压缩文件可用gzip -d命令实现： </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d ye<span class="selector-class">.txt</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>这样就可以解压缩文件并删除gz扩展名。</p><h5 id="（11）指定reset"><a href="#（11）指定reset" class="headerlink" title="（11）指定reset"></a><strong>（11）指定reset</strong></h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reset</span> 清空命令行</span><br></pre></td></tr></table></figure><p>好了，暂时用到的命令就先整理出来，以免忘记咯，等不记得时候翻出来瞅瞅~~</p><blockquote><p>学习理解并整理下来的笔记;<br>希望大家能够指点或提出宝贵意见,共同学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NDK开发（一）JNI简介及调用流程</title>
      <link href="/2016/09/23/ndk/jni-1/"/>
      <url>/2016/09/23/ndk/jni-1/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>前段时间学习了C、C++的一些基础知识后，了解了它们的编码风格，要想掌握NDK开发，前提是会使用JNI，下面我们开始简单的介绍吧！</p><h3 id="JNI简介"><a href="#JNI简介" class="headerlink" title="JNI简介"></a><strong>JNI简介</strong></h3><p>　　JNI全称是Java Native Interface（Java本地接口），本地接口就是指用C和C++开发的接口。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。<br>　　<br><a id="more"></a> </p><p>　　开发JNI程序会受到系统环境的限制，因为用C/C++语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和CPU指令集，而且各个平台对标准C/C++的规范和标准库函数实现方式也有所区别。这就造成使用了JNI接口的JAVA程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。</p><p><strong>JNI的开发流程主要分为以下几个步骤：</strong></p><ol><li><p>编写带有native声明方法的java类；</p></li><li><p>用”javac”命令来编译所编写的java类；</p></li><li><p>使用”javah”java类的名生成扩展名为h的头文件；</p></li><li><p>复制jni.h和jni_md.h文件到CPP工程中;</p></li><li><p>实现.h头文件中声明的函数</p></li><li><p>生成dll动态链接库</p></li><li><p>配置dll文件所在目录到环境变量</p></li><li><p>重启Eclipse</p></li></ol><p><font color="green"><strong>jni调用dill的流程图如下：</strong></font></p><p><img src="http://img.blog.csdn.net/20160921002729113" alt="这里写图片描述"></p><p>通过上面的分析，相信大家已经对jni的开发流程有一个整体的认识，接下来，我们将通过实例更进一步的了解。</p><h4 id="第一步：编写带有native声明方法的java类"><a href="#第一步：编写带有native声明方法的java类" class="headerlink" title="第一步：编写带有native声明方法的java类"></a><font color="blue"><strong>第一步：编写带有native声明方法的java类</strong></font></h4><p>JniTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.jni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">getStringFromC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="第二步：用”javac”命令来编译所编写的java类；"><a href="#第二步：用”javac”命令来编译所编写的java类；" class="headerlink" title="第二步：用”javac”命令来编译所编写的java类；"></a><font color="blue"><strong>第二步：用”javac”命令来编译所编写的java类；</strong></font></h4><p>首先我们必须得配有java环境变量，然后我们右键点击项目-&gt;properties,复制项目路径；</p><p><img src="http://img.blog.csdn.net/20160921004851299" alt="这里写图片描述"></p><p>然后进入dos命令，</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\u</span>uxuh&gt;cd E:<span class="symbol">\D</span>ocuments<span class="symbol">\1</span>1<span class="symbol">\J</span>niTest</span><br><span class="line"></span><br><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\u</span>uxuh&gt;E:</span><br><span class="line"></span><br><span class="line">E:<span class="symbol">\D</span>ocuments<span class="symbol">\1</span>1<span class="symbol">\J</span>niTest&gt;cd src</span><br><span class="line"></span><br><span class="line">E:<span class="symbol">\D</span>ocuments<span class="symbol">\1</span>1<span class="symbol">\J</span>niTest<span class="symbol">\s</span>rc&gt;</span><br></pre></td></tr></table></figure><h4 id="第三步：使用”javah”java类的名生成-h的头文件"><a href="#第三步：使用”javah”java类的名生成-h的头文件" class="headerlink" title="第三步：使用”javah”java类的名生成.h的头文件"></a><font color="blue"><strong>第三步：使用”javah”java类的名生成.h的头文件</strong></font></h4><p>接着，复制我们的完整类名（包名+类名），执行命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Documents\<span class="number">11</span>\JniTest\src&gt;javah com<span class="selector-class">.study</span><span class="selector-class">.jni</span><span class="selector-class">.JniTest</span></span><br></pre></td></tr></table></figure><p>回到工程目录下，刷新项目，编译后的.h头文件就出现了。</p><p>源码：</p><p>com_study_jni_JniTest.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_study_jni_JniTest */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_study_jni_JniTest</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_study_jni_JniTest</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_study_jni_JniTest</span></span><br><span class="line"><span class="comment"> * Method:    getStringFromC</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getStringFromC</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h4 id="第四步：复制jni-h和jni-md-h文件到CPP工程中"><a href="#第四步：复制jni-h和jni-md-h文件到CPP工程中" class="headerlink" title="第四步：复制jni.h和jni_md.h文件到CPP工程中"></a><font color="blue"><strong>第四步：复制jni.h和jni_md.h文件到CPP工程中</strong></font></h4><p>将要编译的文件中引入了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude<span class="meta-string">&lt;jni.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>头文件，所以我们手动导入这两个文件到CPP工程中，</p><p>以我的jdk1.7.0_75为例，两个头文件的位置分别为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jni.h    jdk1<span class="number">.7</span><span class="number">.0</span>_75/include</span><br><span class="line">jni_md.h    jdk1<span class="number">.7</span><span class="number">.0</span>_75/include/linux</span><br></pre></td></tr></table></figure></p><p>将我们生成.h头文件复制到项目的代码文件目录下 ， 在解决方案中的头文件目录-&gt; 右键-&gt; 添加 -&gt; 添加现有项 。 将我们的头文件添加进来，还有jni.h和jni_md.h一起添加进来，如图：</p><p><img src="http://img.blog.csdn.net/20160921011013003" alt="这里写图片描述"></p><h4 id="第五步：实现-h头文件中声明的函数"><a href="#第五步：实现-h头文件中声明的函数" class="headerlink" title="第五步：实现.h头文件中声明的函数"></a><font color="blue"><strong>第五步：实现.h头文件中声明的函数</strong></font></h4><p>c代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_study_jni_JniTest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数实现</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_study_jni_JniTest_getStringFromC</span><br><span class="line">(JNIEnv *env, jclass jcls)&#123;</span><br><span class="line"><span class="comment">//简单的实现</span></span><br><span class="line"><span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"C String"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="第六步：生成dll动态链接库"><a href="#第六步：生成dll动态链接库" class="headerlink" title="第六步：生成dll动态链接库"></a><font color="blue"><strong>第六步：生成dll动态链接库</strong></font></h4><p>我们以VS2013为例：</p><p>操作步骤：</p><p>选中项目 -&gt; 右键 -&gt; 属性 -&gt; 常规 -&gt; 项目默认值 -&gt; 配置类型 , 选择动态库.dll，</p><p><img src="http://img.blog.csdn.net/20160921011522662" alt="这里写图片描述"></p><p>如图，右上角配置管理器，根据我们所使用的平台进去配置一下：</p><p><img src="http://img.blog.csdn.net/20160921011811821" alt="这里写图片描述"></p><p>这里我使用64位的，所以活动解决方案平台下新建了一个x64，部署项目配置也选择x64。</p><p>配置完了之后，最后生成解决方案。去项目目录下查看dll动态库。</p><p><img src="http://img.blog.csdn.net/20160921012257530" alt="这里写图片描述"></p><h4 id="第七步：配置dll文件所在目录到环境变量"><a href="#第七步：配置dll文件所在目录到环境变量" class="headerlink" title="第七步：配置dll文件所在目录到环境变量"></a><font color="blue"><strong>第七步：配置dll文件所在目录到环境变量</strong></font></h4><p>我们把生成dll文件的路径配置java环境变量里面，这样java 才会知道有dll动态库存在，配置完之后，重启下Eclipse。</p><p>最后我们在java中调用动态库，完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.jni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">getStringFromC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getStringFromC());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载动态库</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">   System.loadLibrary(<span class="string">"jni_study"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行一下项目控制台打印出C中返回给我们的字符串。</p><p><img src="http://img.blog.csdn.net/20160921013119011" alt="这里写图片描述"></p><p>好了，整个jni的调用流程已经说的非常详细了，但这只是jni入门的基础，后续会继续更新！</p><blockquote><p>学习理解并整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，一起学习，谢谢！ </p></blockquote>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xshell 远程连接Linux服务器</title>
      <link href="/2016/09/20/linux/xshell/"/>
      <url>/2016/09/20/linux/xshell/</url>
      <content type="html"><![CDATA[<p>我这里有一台电脑，装的Ubuntu系统，当我想使用时，又要去使用另外一台机器（如果没有，可以直接去阿里云整一台主机），更何况文件传输也不方便，比较麻烦，后来，看着同事用的Xshell 远程连接linux，挺方便的就折腾了一番，当然，putty，xftp是个很不错的选择。</p><p>xshell和xftp是windows下访问ubuntu（linux）服务器的一个非常好使的工具。</p><h4 id="ubuntu安装ssh服务器"><a href="#ubuntu安装ssh服务器" class="headerlink" title="ubuntu安装ssh服务器"></a><strong>ubuntu安装ssh服务器</strong></h4><p>首先，判断Ubuntu是否安装了ssh服务：<br>1、输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ps -e |grep ssh</span></span><br></pre></td></tr></table></figure><p> 如果服务已经启动，则可以同时看到“ssh-agent”和“sshd”，否则表示没有安装服务，或没有开机启动 。<br><a id="more"></a></p><p>2、安装ssh服务，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sudo apt-get install openssh-server</span></span><br></pre></td></tr></table></figure><p>出现问题时，重启ssh服务：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>ssh restart</span><br></pre></td></tr></table></figure><p>3、启动服务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/etc/init.d/ssh start</span></span><br></pre></td></tr></table></figure><p>4、本机测试是否能够成功登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ssh 用户名@本机ip地址</span></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh xuhao@192.168.xxx</span></span><br></pre></td></tr></table></figure><p>最后测试成功如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Ubuntu <span class="number">15.10</span> (GNU/Linux <span class="number">4.2</span><span class="number">.0</span><span class="number">-42</span>-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * <span class="string">Documentation:</span>  <span class="string">https:</span><span class="comment">//help.ubuntu.com/</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">package</span> can be updated.</span><br><span class="line"><span class="number">0</span> updates are security updates.</span><br><span class="line"></span><br><span class="line">Last <span class="string">login:</span> Sun Sep <span class="number">18</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">27</span> <span class="number">2016</span> from <span class="number">192.168</span>.xxx</span><br></pre></td></tr></table></figure><h4 id="在ubuntu-上查看其IP"><a href="#在ubuntu-上查看其IP" class="headerlink" title="在ubuntu 上查看其IP"></a><strong>在ubuntu 上查看其IP</strong></h4><p>在windows 使用xshell连接 远程linux 双方必须是有网络的，不然无法连接。</p><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.blog.csdn.net/20160919180446941" alt="这里写图片描述"></p><p>红色箭头指向的地方就是Ubuntu的IP。</p><h4 id="在windows-上查看其IP"><a href="#在windows-上查看其IP" class="headerlink" title="在windows 上查看其IP"></a><strong>在windows 上查看其IP</strong></h4><p>在管理员 dos命令控制台上输入</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span></span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.blog.csdn.net/20160919180921364" alt="这里写图片描述"></p><h4 id="检测是否能互相ping通"><a href="#检测是否能互相ping通" class="headerlink" title="检测是否能互相ping通"></a><strong>检测是否能互相ping通</strong></h4><p>在windows 同dos命令下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ping</span> Ubuntu 的<span class="built_in">ip</span></span><br></pre></td></tr></table></figure><p>在Ubuntu 下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ping</span> Windows的<span class="built_in">ip</span></span><br></pre></td></tr></table></figure><p>查看他们是否能ping。</p><h4 id="配置Xshell远程登录"><a href="#配置Xshell远程登录" class="headerlink" title="配置Xshell远程登录"></a><strong>配置Xshell远程登录</strong></h4><p>如果没有Xshell的，去网上下载一个。</p><p>我们打开Xshell：</p><p><img src="http://img.blog.csdn.net/20160919182058291" alt="这里写图片描述"></p><p><font color="red"><strong>参数说明：</strong></font></p><p><strong>名称：</strong> 自己随便起个名字；<br><strong>协议：</strong> 选择SSH协议；<br><strong>主机：</strong> 填写ubuntu的IP。</p><p>下面的重新连接，根据需要选择就行，</p><p>填完之后，点击OK，填写Ubuntu的密码，contect（连接）。最后就连接成功了。</p><p><img src="http://img.blog.csdn.net/20160919182711229" alt="这里写图片描述"></p><p>连接成功就可以控制远程服务器了，然后在去下载一个Xftp，进行文件传输，很方便，哈哈。~~</p><blockquote><p>学习理解并整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习；</p></blockquote>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ New和delete操作符使用</title>
      <link href="/2016/09/12/cpp/string/"/>
      <url>/2016/09/12/cpp/string/</url>
      <content type="html"><![CDATA[<p>在C语言中，动态分配内存用 malloc() 函数，释放内存用 free() 函数。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span> );  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p);  <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure><p>在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。</p><a id="more"></a><p><strong>用 new 和 delete 分配内存更加简单：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br></pre></td></tr></table></figure><p>new 操作符会根据后面的数据类型来推断所需空间的大小。</p><p>如果希望分配一组连续的数据，可以使用 new[]：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><p>用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。</p><p>和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。</p><p>在C++中，建议使用 new 和 delete 来管理内存，它们可以使用C++的一些新特性，最明显的是可以自动调用构造函数和析构函数等。</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ String字符串的增删改查</title>
      <link href="/2016/09/11/cpp/aduc/"/>
      <url>/2016/09/11/cpp/aduc/</url>
      <content type="html"><![CDATA[<p>c++ 提供的string类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。</p><h4 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h4><p>insert（）函数可以在string字符串中置顶的位置插入另一个字符串，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">insert</span> <span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>;</span><br></pre></td></tr></table></figure><p>看这个插入的格式我们就能猜想到，pos表示要插入的下标；str表示要插入的字符串，它可以是string变量，也可以是C风格的字符串。<br><a id="more"></a></p><p>看下面的代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line">void main()&#123;</span><br><span class="line">string <span class="built_in">s1</span>, <span class="built_in">s2</span>, <span class="built_in">s3</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">s1</span> = <span class="built_in">s2</span> = <span class="string">"1234567890"</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">s3</span> = <span class="string">"aaa"</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">s1</span>.<span class="keyword">insert(5, </span><span class="built_in">s3</span>)<span class="comment">;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">s1</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line"><span class="built_in">s2</span>.<span class="keyword">insert(5, </span><span class="string">"bbb"</span>)<span class="comment">;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">s2</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12345</span>aaa67890</span><br><span class="line"><span class="number">12345</span>bbb67890</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>insert()函数的第一个参数有越界的可能，如果越界，则会产生运行时异常。我恶魔你要捕获这个异常。</p><hr><h4 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a><strong>删除字符串</strong></h4><p>erase()函数可以删除string变量中的一个字符串，原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span></span>;</span><br></pre></td></tr></table></figure><p>pos 表示要删除的子字符串的起始下标，len表示要删除子字符串的长度。如果不指明len的话，那么直接删除pos到字符串结束处的所有字符（此时len =str.length-pos)。</p><p>示例代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line">void main()&#123;</span><br><span class="line">    string <span class="built_in">s1</span>, <span class="built_in">s2</span>, <span class="built_in">s3</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">s1</span> = <span class="built_in">s2</span> = <span class="built_in">s3</span> = <span class="string">"1234567890"</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">s2</span>.erase(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">s3</span>.erase(<span class="number">5</span>, <span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">s1</span> &lt;&lt;endl<span class="comment">;</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">s2</span> &lt;&lt;endl<span class="comment">;</span></span><br><span class="line">    cout&lt;&lt; <span class="built_in">s3</span> &lt;&lt;endl<span class="comment">;</span></span><br><span class="line">     system(<span class="string">"pause"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="number">1234590</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：</p><ul><li>len的值</li><li>字符串长度减去 pos 的值。</li></ul><p>简单的说，就是待删除字符串最多只能删除到字符串结尾。</p><hr><h4 id="提取字符串"><a href="#提取字符串" class="headerlink" title="提取字符串"></a><strong>提取字符串</strong></h4><p>substr()函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>pos为要提取的子字符串的起始下标，len为要提取的子字符串的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line"><span class="built_in">string</span> s2;</span><br><span class="line">s2 = s1.substr(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">first</span> <span class="keyword">second</span> <span class="keyword">third</span></span><br><span class="line"><span class="keyword">second</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>系统对 substr() 参数的处理和 erase() 类似：</p><ul><li>如果 pos 越界，会抛出异常；</li><li>如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。</li></ul><hr><h4 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a><strong>字符串的查找</strong></h4><h5 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a><strong>find()函数</strong></h5><p>find（）函数用于string字符串中查找子字符串出现的位置，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> find (<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">size_t</span> find (<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = <span class="number">0</span>) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>第一个参数的表示为待查找的子字符串，它可以是string变量，也可以是C风格的字符串，第二个参数表示开始查找的位置（下标）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/字符串查找替换</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"apple google apple iphone"</span>;</span><br><span class="line"><span class="comment">//从0开始查找"google"的位置</span></span><br><span class="line"><span class="keyword">int</span> idx = s1.find(<span class="string">"google"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; idx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计apple出现的次数</span></span><br><span class="line"><span class="keyword">int</span> idx_app = s1.find(<span class="string">"apple"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//npos大于任何有效下标的值</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (idx_app != <span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到的索引:"</span> &lt;&lt; idx_app &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">idx_app+=<span class="number">5</span>;</span><br><span class="line">idx_app = s1.find(<span class="string">"apple"</span>, idx_app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">找到的索引<span class="selector-pseudo">:0</span></span><br><span class="line">找到的索引<span class="selector-pseudo">:13</span></span><br><span class="line">2</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>find函数最终返回的是子字符串 第一次出现在字符串的其实下标，如果没有查找到子字符串，那么会返回一个无穷大的值 4294967295。统计apple出现的次数。先查找第一次出现的位置，接着<br>和npos大于任何有效下标的值，来判断，while循环，每次加上自身的长度，最后统计出现的次数。。。</p><hr><h5 id="rfind-函数"><a href="#rfind-函数" class="headerlink" title="rfind()函数"></a><strong>rfind()函数</strong></h5><p>rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line"><span class="keyword">int</span> index = s1.rfind(s2, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">if</span> (index &lt; s1.length())</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Found at index : "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found <span class="keyword">at</span> index : 6</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><hr><h5 id="find-first-of-函数"><a href="#find-first-of-函数" class="headerlink" title="find_first_of() 函数"></a><strong>find_first_of() 函数</strong></h5><p>find_first_of() 函数用于查找子字符串和字符串共同具有的字符在再辅传中首先出现的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"asecond"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.find_first_of(s2);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found <span class="keyword">at</span> index : 3</span><br></pre></td></tr></table></figure><p>s1 和 s2 共同具有的字符是 ’s’，该字符在 s1 中首次出现的下标是3，故查找结果返回3。</p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。 </p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ String类和字符串的访问和拼接操作</title>
      <link href="/2016/09/11/cpp/string/"/>
      <url>/2016/09/11/cpp/string/</url>
      <content type="html"><![CDATA[<p>C++ 增强了对字符串的支持，除了可以使用c中的字符串，还可以使用内置的数据类型string，string类处理字符串会翻遍很多，完全可以代替C语言中的char 数组和char 指针。</p><p>使用sting类需要包含头文件&lt; sting &gt;, 下面我们就来介绍怎么使用。</p><p><strong>string 的几种用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"c plus plus"</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s2;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">5</span>, <span class="string">'s'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; s3 &lt;&lt; s4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c <span class="keyword">plus</span> plusc <span class="keyword">plus</span> plussssss</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的几行代码介绍了 几种定义string 类型变量的方法，变量s1只是定义但是没有初始化，编译器会将默认的值附给s1，默认值是””（空字符串）。<br>变量s2再定义的同时被初始化为”c plus plus ”与C语言中的char 字符串不同，string类型的变量结尾没有<br>‘\0’,string 类型的本质是一个个string类，而我们定义的变量则是一个个的string类的对象，变量s3在定义的时候直接用s2进行初始化，因此s3的内容也是‘c plus plus’。变量s4被初始化为由5个’s’字符串组成的字符串，也就是’sssss‘。</p><hr><p>与C语言中的字符串不同，当我们需要知道字符串长度时，可以调用string类提供的length（）函数。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"c plus plus"</span>;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>编译运行的结果：</p><p>11</p><p>这里，变量 s 也是 string 类的对象，length() 是它的成员函数。由于 string 变量的末尾没有 ‘\0’ 字符，所以 length() 返回的是字符串的真实长度，而不是长度 +1。</p><hr><h4 id="转换为-char-数组字符串"><a href="#转换为-char-数组字符串" class="headerlink" title="转换为 char 数组字符串"></a><strong>转换为 char 数组字符串</strong></h4><p> C++虽然提供了string类来替代C语言中的char 数组形式的字符串，但是有时候编程中必须要使用C风格的字符串，为此，string类提供了一个转换的函数c_str();函数能够将 string 变量转换为一个 const 字符串数组的形式，并将指向该数组的指针返回。请看下面的代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filename = <span class="string">"input.txt"</span>;</span><br><span class="line">ifstream <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">in</span>.<span class="built_in">open</span>(filename.c_str());</span><br></pre></td></tr></table></figure><p>为了使用文件打开函数 open()，必须将 string 类型的变量转换为字符串数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ITERATOR_DEBUG_LEVEL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ITERATOR_DEBUG_LEVEL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ITERATOR_DEBUG_LEVEL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ITERATOR_DEBUG_LEVEL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string字符串-&gt;c字符串转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//string -&gt; char*</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"far away"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c = s1.c_str();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">string</span> s2 = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string-&gt;char[]</span></span><br><span class="line"><span class="comment">//从string中赋值字符到char[]</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">s1.copy(arr,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译输出结果：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">far</span> away</span><br><span class="line"><span class="keyword">far</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><hr><h4 id="string-字符串的输入输出"><a href="#string-字符串的输入输出" class="headerlink" title="string 字符串的输入输出"></a><strong>string 字符串的输入输出</strong></h4><p>string类重载了输入输出的运算符，用“&gt;&gt;”进行输入，用”&lt;&lt;”进行输出，请看下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;  <span class="comment">//输入字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出字符串</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">c</span> plus</span><br><span class="line"><span class="keyword">c</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>虽然我们输入了两个由空格隔开的”c plus’,但是只输出了一个，这是因为输入的运算符“&gt;&gt;”默认会忽略空格，遇到空格就认为输入结束，所以最后输入的plus没有被存储到变量里面。</p><hr><h4 id="访问字符串中的字符"><a href="#访问字符串中的字符" class="headerlink" title="访问字符串中的字符"></a><strong>访问字符串中的字符</strong></h4><p>string 字符串也可以像字符串数组一样按照下标来访问其中的每一个字符。string 字符串的起始下标仍是从 0 开始。请看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"abcdefg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、数组方式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"数组方式:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;s1[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、迭代方式</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代方式:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">string</span>::iterator it = s1.begin(); it != s1.end(); it++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数组方式:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">迭代方式:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">g</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><hr><h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a><strong>字符串的拼接</strong></h4><p>有了string 类，我们可以使用”+“ 或者”+=“运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的strcat(),strcopy(),malloc()等函数来拼接字符串了，再也不用担心空间不够溢出了。<br>下面来看列子：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//字符串拼接</span><br><span class="line"><span class="symbol">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">string </span><span class="built_in">s1</span> = <span class="string">"alan"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">string </span><span class="built_in">s2</span> = <span class="string">"xiho"</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//<span class="number">1</span>.</span><br><span class="line"><span class="keyword">string </span><span class="built_in">s3</span> = <span class="built_in">s1</span> + <span class="built_in">s2</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string </span><span class="built_in">s4</span> = <span class="string">" wahaha"</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//<span class="number">2</span>.</span><br><span class="line"><span class="built_in">s3</span>.append(<span class="built_in">s4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">s3</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果为：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alanxiho wahaha</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><hr><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。 </p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中签名、证书、公钥密钥的概念及使用</title>
      <link href="/2016/09/02/sign/"/>
      <url>/2016/09/02/sign/</url>
      <content type="html"><![CDATA[<p>资料来源于Android 官方文档：<br><a href="https://developer.android.com/studio/publish/app-signing.html" target="_blank" rel="noopener">https://developer.android.com/studio/publish/app-signing.html</a><br>还有些资料来源于网络。加以整理！</p><h2 id="公钥和私钥的概念"><a href="#公钥和私钥的概念" class="headerlink" title="公钥和私钥的概念"></a><strong>公钥和私钥的概念</strong></h2><p>在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是公开密钥算法（也叫非对称算法、双钥算法）”，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。<br> <a id="more"></a></p><h4 id="证书的概念"><a href="#证书的概念" class="headerlink" title="证书的概念"></a><strong>证书的概念</strong></h4><p>数字证书则是由证书认证机构（CA）对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机 构的公章）后形成的一个数字文件。CA完成签发证书后，会将证书发布在CA的证书库（目录服务器）中，任何人都可以查询和下载，因此数字证书和公钥一样是公开的。实际上，数字证书就是经过CA认证过的公钥。</p><p><strong>原则：</strong></p><pre><code>1、一个公钥对应一个私钥。2、密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。3、如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。4、如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。5、非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的</code></pre><p><strong>基于公开密钥的加密过程</strong></p><p>比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下：</p><pre><code>1、Bob将他的公开密钥传送给Alice。2、Alice用Bob的公开密钥加密她的消息，然后传送给Bob。3、Bob用他的私人密钥解密Alice的消息。</code></pre><h2 id="Android中的签名："><a href="#Android中的签名：" class="headerlink" title="Android中的签名："></a><strong>Android中的签名：</strong></h2><h4 id="是什么签名？"><a href="#是什么签名？" class="headerlink" title="是什么签名？"></a><strong>是什么签名？</strong></h4><hr><p>Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由应用开发者持有，</p><p><font color="red"> Android使用证书作为标示应用程序作者的一种方式，并在应用程序之间建立信任的关系。</font> 证书并不用来控制用户能否安装哪个应用。证书不需要由证书认证中心签名；完全可以使用自制签名证书。</p><p>没有正确签名的应用，Android系统不会安装或运行。此规则适用于在任何地方运行的Android系统，不管是在模拟器还是真实设备上。因为这个原因。在真机或模拟器上运行或者调试应用前，必须为其设置好签名。</p><h4 id="为什么要有签名？"><a href="#为什么要有签名？" class="headerlink" title="为什么要有签名？"></a><strong>为什么要有签名？</strong></h4><hr><p>开发Android的人这么多，完全有可能把类名，包名命名成同样的名字，这个时候该如何区分？所以，这时候就需要签名来区分了，由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证相当名字，但是签名不同的包不被替换。<br>发布过Android应用的朋友们应该都知道，Android APK的发布是需要签名的。签名机制在Android应用和框架中有着十分重要的作用。例如，Android系统禁止更新安装签名不一致的APK；如果应用需要使用system权限，必须保证APK签名与Framework签名一致。</p><h4 id="签名策略"><a href="#签名策略" class="headerlink" title="签名策略"></a><strong>签名策略</strong></h4><hr><p>应用程序签名的一些方面可能会影响应用程序的开发过程, 尤其是当你计划发布多个应用时. 通常情况下, 对于所有开发者而言,推荐的策略是:在应用程序的整个生命周期,所有的应用程序使用相同的证书签名.</p><p><strong>为什么这么做的原因:</strong></p><ul><li>应用程序升级 – 当发布应用的更新时, 如果想让用户无缝地升级到新版本, 需要继续使用相同的某个或者某一套证书来签名更新包.当系统安装应用的更新时, 它会比较现有版本和新版本的证书. 如果证书吻合, 包括证书数据和顺序都吻合, 那么系统允许更新.如果新版本所做的签名不是匹配的, 那么将需要给应用起一个不同的包名 — 在这种情况下, 用户相当于安装了一个完全的新程序.</li><li>应用程序模块化 – Android允许由相同证书签名的应用程序运行在相同的进程中, 此时系统会将它们作为单个应用程序对待.在这种方式中, 可以按模块化的方式部署应用, 用户可以根据需要独立地更新每一个模块.</li><li>代码/数据 的授权共享 – Android 提供模式匹配的权限控制机制,因此一个应用可以暴露功能给另一个用指定证书签名的应用. 通过用相同证书签名多个应用,以及使用模式匹配的权限检查,应用程序可以以安全的方式共享代码和数据.</li></ul><p><strong>另一个影响签名策略的重要考量是, 如何设置签名应用的key的有效期.</strong></p><ul><li>如果计划为某个单独的应用程序提供更新支持, 那么应该确认key的有效期要比应用的寿命长. 推荐25年或者更长的有效期.当key的有效期过期, 用户将再也不能无缝地更新到应用程序的新版本.</li><li>如果要使用相同的key为多个不同的应用签名, 应当确认key的有效期比所有这些应用的所有版本的生命周期还长,包括要比将来加到这个套件中的额外的关联应用的生命周期更长.</li><li>如果计划将应用程序发布到Android Market, 为应用签名的key的有效期必须在2033年10月22日以后.Market服务器强制执行这个规则, 来保证当新版本可用时, 用户可以无缝地更新Market应用.</li></ul><p><strong>当设计的时候, 须牢记这些要点, 以确保使用合适的证书来签名应用程序。</strong></p><h4 id="Debug模式下的签名"><a href="#Debug模式下的签名" class="headerlink" title="Debug模式下的签名"></a><strong>Debug模式下的签名</strong></h4><hr><p>运行或从IDE调试项目时，Android的Studio会自动由Android SDK工具生成的调试证书签名的APK。您运行或调试Android Studio中的项目第一次，IDE会自动在调试密钥库和证书 $HOME/.android/debug.keystore，并设置密钥库和密钥的密码。</p><p>因为Debug模式下的证书由构建工具创建，这样是不安全的，大部分应用程序商店（包括谷歌Play商店）不会接受的APK有出版调试证书签名。</p><p>所以你不用每次调试时都输入的Android Studio自动存储在签约配置调试签约信息。签名的配置是由所有必要的信息，以签署APK，包括密钥存储位置，存储密码，密钥名称，密钥密码的对象。您不能直接编辑调试签约配置，但可以配置你如何签上你的发布版本。</p><p>有关如何构建和调试运行的应用程序，看到更多的信息， 生成并运行您的应用程序。</p><h4 id="调试证书到期"><a href="#调试证书到期" class="headerlink" title="调试证书到期"></a><strong>调试证书到期</strong></h4><hr><p>用来签署APK调试的自签名证书有365天，从它的创建日期的截止日期。证书过期后，你在构建的时候会报错的。</p><p>为了解决这个问题，只需删除该debug.keystore文件。该文件存储在以下位置：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.android/ 在OS X和Linux</span><br><span class="line">C:<span class="symbol">\D</span>ocuments and Settings<span class="symbol">\&lt;</span>user&gt;<span class="symbol">\.</span>android<span class="symbol">\ </span>在Windows XP上</span><br><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\&lt;</span>user&gt;<span class="symbol">\.</span>android<span class="symbol">\ </span>在Windows Vista和Windows 7，8，和10</span><br></pre></td></tr></table></figure><p>接下来，你构建和运行调试版本的时候，构建工具将重新生成一个新的秘钥库和Debug key，请注意！你必须运行你的程序，不然就不会重新生成秘钥库和Debug key。</p><h4 id="发布版的签名"><a href="#发布版的签名" class="headerlink" title="发布版的签名"></a><strong>发布版的签名</strong></h4><p>你可以使用AndroidStudio 来手动生成签名的apk，但是这样每次发布不同的版本的时候就都手动生成一次，比较麻烦的，所以，我们还可以配置Gradle文件，在构建的过程中会自动签名。</p><p>在AndroidStudio中要手动生成签名的apk，按照以下步骤：</p><ol><li>在菜单栏中，Build &gt; Generate Signed APK<br><img src="http://img.blog.csdn.net/20160902150733659" alt="这里写图片描述"></li><li>选择您想从下拉释放下来，然后单击模块 下一步。</li><li>如果你已经有一个密钥库，请转到步骤5.如果你想创建一个新的密钥库，单击 新建。</li><li>在新的密钥库窗口，为您提供密钥库和密钥以下信息，如图1所示。<br><img src="http://img.blog.csdn.net/20160902151403849" alt="这里写图片描述"><br>图1。创建Android Studio中一个新的密钥库。</li></ol><p><strong>Keystore</strong></p><ul><li>Key store path:：选择您的密钥存储应该创建的位置。</li><li>Password：创建并确认您的密钥库安全的密码。</li></ul><p><strong>Key</strong></p><ul><li>Alias：你的Enter键的标识名称。</li><li>Password: 创建并确认你的密钥的安全密码。这应该是从你选择你的密钥库的密码不同</li><li>Validity (years)：设置的时间长度在几年，你的key将是有效的。你的key应该是有效期至少为25年来，这样你就可以通过你的应用程序的寿命相同的密钥签名的应用程序更新。</li><li>Certificate：输入有关自己的一些信息，为您的证书。这个信息是不是在你的应用程序中显示，但是属于apk的一部分。<br>填完上面信息，然后单击确定。</li></ul><p>在生成签名APK窗口中，选择一个密钥库，私钥，并输入密码两种。（如果在上一步中创建您的密钥库，这些字段已经为您填充。）然后单击 下一步。</p><p><img src="http://img.blog.csdn.net/20160902152553403" alt="这里写图片描述"><br>图2。选择Android Studio中的私钥。</p><p>在下一个窗口中，选择签署的apk的输出目录，和签名的环境，然后单击 Finish（完成）。</p><p><img src="http://img.blog.csdn.net/20160902152859138" alt="这里写图片描述"><br>图3。生成所选Flavors的APK。</p><p>该过程完成后，你会发现在你上面选择的目标文件夹已经有签名的APK。您现在可以通过一个应用市场，如谷歌Play商店，或使用你选择的机制分发签署的APK。</p><h4 id="配置build-gradle文件自动签名你的apk"><a href="#配置build-gradle文件自动签名你的apk" class="headerlink" title="配置build.gradle文件自动签名你的apk"></a><strong>配置build.gradle文件自动签名你的apk</strong></h4><hr><p>在Android Studio中，你可以通过build.gradle 配置来构建你的项目，在构建的过程中会自动生成你的apk。步骤如下：</p><ol><li>在当前你的项目，右键点击你的程序，然后打开Projec Structure，</li><li>再打开的窗口中，在模块的左侧面板中选择你想签署的Module。</li><li>选择你的密码存储文件，然后输入相关的信息；如图：<br><img src="http://img.blog.csdn.net/20160902164510994" alt="这里写图片描述"><br>图4。用于创建新签名构造的窗口。</li><li>点击Ok。</li><li>然后在build types配置中 选择刚刚签名的配置。如图：<br><img src="http://img.blog.csdn.net/20160902154255284" alt="这里写图片描述"></li></ol><p>最后点击ok。</p><p>然后AndroidStudio 自动构建编译，成功后可以在build/outputs/apk/为您构建模块项目目录内的文件夹中找到我们输出的apk。</p><h4 id="签名注意事项"><a href="#签名注意事项" class="headerlink" title="签名注意事项"></a><strong>签名注意事项</strong></h4><hr><p>你应该签名所有的APK与整个应用程序的寿命预期相同的证书。有几个原因，你应该这样做：</p><ul><li>应用程序升级：当系统安装更新到一个应用程序，它在新版本中与那些在现有版本的证书（S）比较。该系统允许更新，如果证书相匹配。如果你用不同的证书签名的新版本，你必须在不同的包名称分配给应用程序，在这种情况下，用户安装新版本作为一个全新的应用程序。</li><li>应用模块：如果是app，Android 允许同一证书签名在同一个进程中运行的APK，因此，系统会将其视为一个单一的应用程序。通过这种方式，你可以部署模块你的应用程序。</li><li>代码/数据，通过共享的权限：Android提供了基于签名的权限执行，这样应用程序可以公开的功能到与指定的证书签名的另一个应用程序。通过签署多个APK使用相同的证书，并使用基于签名的权限检查，您的应用程序可以在一个安全的方式共享代码和数据。</li></ul><h4 id="保护您的私钥"><a href="#保护您的私钥" class="headerlink" title="保护您的私钥"></a><strong>保护您的私钥</strong></h4><hr><p>保护你的私钥的安全性是至关重要的，无论是你还是用户，如果允许别人使用你的秘钥，或者你泄露你的秘钥文件，使得第三方找到他们并使用它们，那么你的app安全性将会受到损失~</p><p>作为一个开发者，在任何时候，都要保护好你的私钥，直到密钥已过期。以下是一些技巧让你的密钥的安全：</p><ul><li>选择不容易破解的密码，和keystore；</li><li>不要给外人你的私钥和keystore文件；</li><li>把他们放置在一个安全的地方。</li></ul><h4 id="删除签名信息"><a href="#删除签名信息" class="headerlink" title="删除签名信息"></a><strong>删除签名信息</strong></h4><hr><p>当你创建一个签名的配置的时候，Android的Studio将在纯文本模块的您的签名信息build.gradle的文件。如果你是一个团队或用你的代码工作，你应该让它变成一个不容易给别人访问的移动的文件。要做到这一点，你应该创建一个单独的属性文件来存储安全的信息，</p><p>创建一个文件名 ​​为keystore.properties在项目的根目录。这个文件应该包含您的签名信息，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword = myStorePassword </span><br><span class="line">keyPassword = mykeyPassword </span><br><span class="line">keyAlias ​​= myKeyAlias </span><br><span class="line">​​storeFile = myStoreFileLocation</span><br></pre></td></tr></table></figure><p>在你的模块的build.gradle文件中，添加的代码加载你keystore.properties的文件之前android 块。</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a variable called keystorePropertiesFile, and initialize it to your</span></span><br><span class="line"><span class="comment">// keystore.properties file, in the rootProject folder.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keystorePropertiesFile</span> </span>= rootProject.file(<span class="string">"keystore.properties"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize a new Properties() object called keystoreProperties.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keystoreProperties</span> </span>= new Properties()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load your keystore.properties file into the keystoreProperties object.</span></span><br><span class="line">keystoreProperties.load(new FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用语法，来引用存储的签名信息：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        config &#123;</span><br><span class="line">            keyAlias keystoreProperties[<span class="string">'keyAlias'</span>]</span><br><span class="line">            keyPassword keystoreProperties[<span class="string">'keyPassword'</span>]</span><br><span class="line">            storeFile file(keystoreProperties[<span class="string">'storeFile'</span>])</span><br><span class="line">            storePassword keystoreProperties[<span class="string">'storePassword'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="使用工具签名"><a href="#使用工具签名" class="headerlink" title="使用工具签名"></a><strong>使用工具签名</strong></h4><hr><p>如果你不用AndroidStudio来签名你的apk，你还可以使用Android SDK 和 JDK 自带的工具，步骤如下：</p><ol><li><strong>使用keytool 生成私钥，例如：</strong></li></ol><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ keytool -genkey -v -keystore my-release-<span class="type">key</span>.keystore</span><br><span class="line">-alias alias_name -keyalg RSA -keysize <span class="number">2048</span> -validity <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>提示您输入密钥库和密钥的密码，并为你的key设置别名。然后生成密钥库作为一个名为my-release-key.keystore。密钥库包含单个键，有效10000天。别名是签署您的应用程序时，您将在以后使用的名称。</p><ol><li><strong>编译发布模式下您的应用程序，以获得一个无符号的APK。</strong></li><li><strong>使用jarsigner来签名你的app：</strong><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">jarsigner </span>-verbose -sigalg <span class="keyword">SHA1withRSA </span>-<span class="keyword">digestalg </span><span class="keyword">SHA1</span></span><br><span class="line"><span class="keyword">-keystore </span>my-release-key.keystore my_application.apk alias_name</span><br></pre></td></tr></table></figure></li></ol><p>上面提示您输入密钥库和密钥的密码。然后签名apk。</p><ol><li><strong>验证你的apk签名：</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jarsigner -verify -verbose -certs my_application.apk</span></span><br></pre></td></tr></table></figure></li></ol><p>…</p><ol><li><strong>使用zipalign来对齐apk包：</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk</span></span><br></pre></td></tr></table></figure><p>zipalign 确保所有的未压缩数据与特定字节对齐相对于文件，从而降低apk文件的大小。</p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。 </p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公钥 </tag>
            
            <tag> 私钥 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Gradle和Nexus 搭建私有Maven仓库</title>
      <link href="/2016/08/30/maven/"/>
      <url>/2016/08/30/maven/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h2><p>随着业务的增长，需求量增多，我们的App 组件也越来越多，几乎大部分组件都有用到同样的第三方库和公司内部封装的库，而团队中的所有人都重复的从maven 远程的中央仓库下载构建，这样就会加大了仓库的负载和浪费了外网的带宽，网速慢的话，就要等很久很久，半个小时，几个小时，都有可能！这样明显影响项目的开发进度，有的公司还是在内网的情况下开发，连接不到中央仓库怎么办？公司内部开发的公共组件怎么让其他项目共用呢？这个时候，我们不得不为自己的团队搭建一个私服maven仓库，来提高我们的开发效率。</p><p>起初，对gradle和maven不是很熟，看了网上的教程一脸懵逼，后来，花了点时间，发现整个过程也还是很简单的。↓↓</p><p>首先我们来了解一下，</p><h2 id="一、什么是Maven-Gradle"><a href="#一、什么是Maven-Gradle" class="headerlink" title="一、什么是Maven,Gradle?"></a><strong>一、什么是Maven,Gradle?</strong></h2><p><strong>Maven</strong> 是一个项目管理和自动构建工具。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。下开发用的库列表：</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mavenCentral();</span><br><span class="line">jcenter()</span><br><span class="line"><span class="keyword">maven</span> &#123;</span><br><span class="line">     url <span class="string">'file:///Users/my-user-name/Documents/Android/repo/'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">maven</span> &#123;</span><br><span class="line">    url <span class="string">'http://localhost:8081/nexus/content/repositories/releases/'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Android Studio Gradle 主要支持两个 Maven 中央库：mavenCentral 和 jcenter。</p><ul><li>mavenCentral 是最早的 maven 中央仓库</li><li>jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库</li><li>第三个是我的本机的仓库</li><li>第四个是笔者部署在内网服务器的私有仓库</li></ul><p><strong>Gradle</strong> 是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言来声明项目设置，而不是传统的XML</p><h2 id="二、使用Nexus搭建maven私服"><a href="#二、使用Nexus搭建maven私服" class="headerlink" title="二、使用Nexus搭建maven私服 "></a><strong>二、使用Nexus搭建maven私服 </strong></h2><h3 id="1-Nexus-下载安装："><a href="#1-Nexus-下载安装：" class="headerlink" title="1.Nexus  下载安装："></a>1.Nexus  下载安装：</h3><p>官网下载地址：<a href="http://www.sonatype.org/nexus/go/，我的开发环境是Windows，我下载的是Nexus" target="_blank" rel="noopener">http://www.sonatype.org/nexus/go/，我的开发环境是Windows，我下载的是Nexus</a> Repository Manager OSS 2.xx下面的 All platforms    nexus-2.13.0-01-bundle.zip压缩文件。↓<br><img src="http://img.blog.csdn.net/20160830184129972" alt="这里写图片描述"></p><h3 id="2-Nexus-启动："><a href="#2-Nexus-启动：" class="headerlink" title="2.Nexus 启动："></a>2.Nexus 启动：</h3><p>下载完成之后，解压后进入\nexus-2.1.2-bundle\nexus-2.1.2\bin\jsw\，根据操作系统类型选择文件夹，我选的是windows-x86-32文件夹，进入后可看到如下所示bat文件。<br><img src="http://img.blog.csdn.net/20160830185642150" alt="这里写图片描述"></p><p>双击console-nexus.bat运行。再浏览器中输入<a href="http://127.0.0.1:8081/nexus/" target="_blank" rel="noopener">http://127.0.0.1:8081/nexus/，</a>出现图（2）所示就代表nexus已经启动成功了。</p><p><img src="http://img.blog.csdn.net/20160830190207761" alt="这里写图片描述"><br>图(2)</p><p> 8081是默认的端口号，要修改端口号，进入\conf\打开nexus.properties文件，修改application-port属性值就可以了。<br>默认的用户名和密码分别是：admin和admin123。点击右上角的log in 登录后如图所示：<br>点击左侧的 repositories 查看现有的仓库列表：<br><img src="http://img.blog.csdn.net/20160830190723138" alt="这里写图片描述"></p><h3 id="3-Nexus仓库："><a href="#3-Nexus仓库：" class="headerlink" title="3.Nexus仓库："></a>3.Nexus仓库：</h3><p> <strong>这里的仓库分了四种类型</strong></p><ol><li>hosted(宿主仓库):用来部署自己,第三方或者公共仓库的构件</li><li>proxy(代理仓库):代理远程仓库</li><li>virtual(虚拟仓库):默认提供了一个 Central M1虚拟仓库 用来将maven 2适配为maven 1</li><li>group(仓库组):统一管理多个仓库</li></ol><p><font color="blue" size="5">Public Repositories:  仓库组</font></p><p><strong>3rd party:</strong> 无法从公共仓库获得的第三方发布版本的构件仓库</p><p><strong>Apache Snapshots:</strong> 用了代理ApacheMaven仓库快照版本的构件仓库</p><p><strong>Central:</strong> 用来代理maven中央仓库中发布版本构件的仓库</p><p><strong>Central M1 shadow:</strong> 用于提供中央仓库中M1格式的发布版本的构件镜像仓库</p><p><strong>Codehaus Snapshots:</strong> 用来代理CodehausMaven 仓库的快照版本构件的仓库</p><p><strong>Releases:</strong> 用来部署管理内部的发布版本构件的宿主类型仓库</p><p><strong>Snapshots:</strong>用来部署管理内部的快照版本构件的宿主类型仓库</p><h3 id="4-建立Nexus宿主仓库"><a href="#4-建立Nexus宿主仓库" class="headerlink" title="4.建立Nexus宿主仓库"></a>4.建立Nexus宿主仓库</h3><p> 新建一个内部仓库，步骤为Repositories –&gt; Add –&gt; Hosted Repository，在页面的下半部分输入框中填入Repository ID和Repository Name即可，另外把Deployment Policy设置为<strong>Allow Redeploy</strong>，点击save就创建完成了。这里我点击添加宿主类型的仓库，在仓库列表的下方会出现新增仓库的配置，如下所示：<br> <img src="http://img.blog.csdn.net/20160830195149877" alt="这里写图片描述"></p><p>建立好新的仓库之后需要配置一下相关账号信息.在安全选项下选择用户选项,可以看到三个默认的账号,分别是管理员账号,部署账号和Nexus账号.正常访问仓库内容的时候是不需要这三个账户的,一般也就是把部署账号暴露出去,方便仓库项目维护人员部署项目使用.所以这里可以用默认的Deployment账户(记得重置下密码).也可以新建一个账号来使用,新建的时候可以通过add role management来控制该账号的权限。<br>点击新建的仓库的url可以直接如今仓库的路劲，因为现在还没有部署项目，所以是空的仓库。</p><p><font color="black" size="5">至此，搭建私服的maven仓库就已经完成，下面继续介绍Android 端在AS 上面的应用。</font></p><h2 id="三、上传库到Maven仓库"><a href="#三、上传库到Maven仓库" class="headerlink" title="三、上传库到Maven仓库"></a><strong>三、上传库到Maven仓库</strong></h2><p> 上传库到maven仓库有两种方式，我们先来介绍第一种：</p><ol><li>首先我们创建一个新的AndroidStudio 项目，然后新建一个module，选择Android Library。</li></ol><p><img src="http://img.blog.csdn.net/20160830202410813" alt="这里写图片描述"></p><p>然后，我们随便写一个功能供别人使用。例如我写一个ToastUtils：</p><p><img src="http://img.blog.csdn.net/20160830203501192" alt="这里写图片描述"></p><p>然后RebuildProject生成依赖的arr包。</p><p>2.在MavenRepoDemo项目的根目录的build.gradle中配置刚刚建立的仓库：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven&#123; url <span class="string">'http://localhost:8081/nexus/content/repositories/releases/'</span>&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在同目录下配置gradle.properties文件，定义通用属性，方便如果有多个库需要部署时，不需要修改每一个库中的配置：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Maven仓库的URL</span></span><br><span class="line"><span class="attribute">MAVEN_REPO_RELEASE_URL</span>=http://localhost:8081/nexus/content/repositories/releases/</span><br><span class="line"><span class="attribute">MAVEN_REPO_SNAPSHOT_URL</span>=http://localhost:8081/nexus/content/repositories/snapshots/</span><br><span class="line"></span><br><span class="line"><span class="comment">#对应maven的GroupId的值</span></span><br><span class="line">GROUP = common</span><br><span class="line"><span class="comment">#登录nexus ossde的用户名</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">NEXUS_USERNAME</span>=admin</span><br><span class="line"><span class="comment">#登录nexus oss的密码</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">NEXUS_PASSWORD</span>=admin123</span><br><span class="line"></span><br><span class="line"><span class="comment"># groupid</span></span><br><span class="line">GROUP_ID = common</span><br><span class="line"></span><br><span class="line"><span class="comment"># type</span></span><br><span class="line">TYPE = aar</span><br><span class="line"></span><br><span class="line"><span class="comment"># description</span></span><br><span class="line">DESCRIPTION = This is Toast lib</span><br></pre></td></tr></table></figure><p>这里的仓库我用的是Nexus 原有的仓库（你可以换成刚刚新建的仓库地址）。</p><ol><li>修改module对应的build.gradle文件，添加以下配置：</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.library'</span></span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.3"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">19</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sourceSets</span> &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.4.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    configuration = <span class="keyword">configurations</span>.archives</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            repository(url: MAVEN_REPO_RELEASE_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.<span class="keyword">project</span> &#123;</span><br><span class="line">                version <span class="string">'1.0.0'</span></span><br><span class="line">                artifactId <span class="string">'toastutils-lib'</span></span><br><span class="line">                groupId GROUP_ID</span><br><span class="line">                packaging TYPE</span><br><span class="line">                <span class="keyword">description</span> <span class="keyword">DESCRIPTION</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">artifacts</span> &#123;</span><br><span class="line">    archives <span class="keyword">file</span>(<span class="string">'toastutils.aar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在as右边栏，找到Gradle打开如下：<br><img src="http://img.blog.csdn.net/20160830203919352" alt="这里写图片描述"></li></ol><p>然后双击uploadArchives，编译脚本并上传arr文件到私有仓库，最后在控制台可以看到日志是否上传成功。</p><p>可以去仓库查看到刚刚上传的库文件：</p><p><img src="http://img.blog.csdn.net/20160830204825029" alt="这里写图片描述"></p><p>第二种，就是直接通过Nexus直接上传，这种就不详细说了，有兴趣的自己去研究下吧！ 嘿嘿</p><h2 id="四、在项目中应用"><a href="#四、在项目中应用" class="headerlink" title="四、在项目中应用"></a><strong>四、在项目中应用</strong></h2><ol><li>在项目的根目录build.gradle配置如下：</li></ol><p><img src="http://img.blog.csdn.net/20160830205442120" alt="这里写图片描述"></p><ol><li>在app目录下的build.gradle配置如下：</li></ol><p><img src="http://img.blog.csdn.net/20160830205622888" alt="这里写图片描述"></p><p> 这样我们就完工了。在项目中调用我们库了，别人按照上面的配置就可以引用库使用了。</p><p><font color="black" size="5"><strong>附上Demo的GitHub项目源码</strong>：<a href="https://github.com/git-xuhao/MavenRepoDemo" target="_blank" rel="noopener">MavenRepoDemo</a></font></p><p>对于频繁更新的子项目是否适合采用这种方式。因为每次变动都需要上传，而主项目在引用该AAR的时候则需要每次都去检查是否更新， 这会使得编译时间大大增加，有了这个maven库，就不用那么麻烦了。</p><h2 id="想了解更多有关的资料："><a href="#想了解更多有关的资料：" class="headerlink" title="想了解更多有关的资料："></a><strong>想了解更多有关的资料：</strong></h2><p> <a href="http://blog.csdn.net/liujiahan629629/article/details/39272321" target="_blank" rel="noopener">Nexus私服使Maven更加强大</a></p><p> <a href="http://kvh.io/tags/EmbraceAndroidStudio/" target="_blank" rel="noopener">拥抱的androidStudio 系列文章 博客比较全</a></p><blockquote><p>学习理解并整理下来的笔记；<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习；</p></blockquote>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（七）文件的相关操作</title>
      <link href="/2016/08/29/c/c-file-operation/"/>
      <url>/2016/08/29/c/c-file-operation/</url>
      <content type="html"><![CDATA[<h2 id="C语言文件的打开与关闭"><a href="#C语言文件的打开与关闭" class="headerlink" title="C语言文件的打开与关闭"></a><strong>C语言文件的打开与关闭</strong></h2><hr><p>在C语言中，文件操作都是由库函数来完成的，我们就来总结文件的相关的操作。</p><h3 id="文件的打开-fopen函数"><a href="#文件的打开-fopen函数" class="headerlink" title="文件的打开(fopen函数)"></a><strong>文件的打开(fopen函数)</strong></h3><p>fopen() 函数用来打开一个文件，它的格式为：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span> *fopen(<span class="built_in">char</span> *filename, <span class="built_in">char</span> *<span class="keyword">type</span>);</span><br></pre></td></tr></table></figure><p>filename为文件名（包括文件路径），type为打开方式，它们都是字符串。fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。</p><p>如果接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">fp</span> = (<span class="string">"demo.txt"</span>, <span class="string">"r"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure> <a id="more"></a><p>上面是以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。fp 通常被称为文件指针。又如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">fp</span> = fopen(<span class="string">"D:\\demo.txt"</span>,<span class="string">"rb"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>表示以二进制方式打开 D 盘下的 demo.txt 文件，允许读和写。</p><p>打开方式(mode)有多种：</p><hr><p><strong>使用文件方式    含义</strong><br>“r”（只读）    为输入打开一个文本文件<br>“w”（只写）    为输出打开一个文本文件<br>“a”（追加）    为追加打开一个文本文件<br>“rb”（只读）    为输入打开一个二进制文件<br>“wb”（只写）    为输出打开一个二进制文件<br>“ab”（追加）    为追加打开一个二进制文件<br>“r+”（读写）    为读／写打开一个文本文件<br>“w+”（读写）    为读／写创建一个文本文件<br>“a+”（读写）    为读／写打开一个文本文件<br>“rb+”（读写）    为读／写打开一个二进制文件<br>“wb+”（读写）    为读／写创建一个二进制文件<br>“ab+”（读写）    为读／写打开一个二进制文件</p><hr><p>在打开一个文件时，如果出错，fopen将返回一个空指针值NULL，因此，我们可以在程序中这样来处理</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (fp=fopen(<span class="string">"D:\\demo.txt"</span>,<span class="string">"rb"</span>) == NULL )&#123;</span><br><span class="line">    printf(<span class="string">"open file is error D:\\demo.txt file!"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再打开文件是，返回的指针为空，则表示不能打开D盘跟目录下的demo.txt 文件，输出提示的错误信息！！printf(“open file is error D:\demo.txt file!”);</p><h3 id="文件关闭（fclose函数）"><a href="#文件关闭（fclose函数）" class="headerlink" title="文件关闭（fclose函数）"></a><strong>文件关闭（fclose函数）</strong></h3><p>fp 为文件指针。例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(<span class="name">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。</p><h2 id="C中文本文件和二进制文件的区别"><a href="#C中文本文件和二进制文件的区别" class="headerlink" title="C中文本文件和二进制文件的区别"></a><strong>C中文本文件和二进制文件的区别</strong></h2><p>下面这段摘自网上：</p><p>从文件编码的方式来看，文件可分为ASCII码文件和二进制码文件两种。</p><p>　　ASCII文件也称为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。例如，数5678的存储形式为：<br>ASC码： 　00110101 00110110 00110111 00111000<br>　　　　　↓ 　　　　↓　　　　↓ 　　　↓<br>十进制码： 5　　　　　6　　　　7　　　　8 共占用4个字节。ASCII码文件可在屏幕上按字符显示， 例如源程序文件就是ASCII文件，用DOS命令TYPE可显示文件的内容。 由于是按字符显示，因此能读懂文件内容。</p><p>　　二进制文件是按二进制的编码方式来存放文件的。 例如， 数5678的存储形式为： 00010110 00101110只占二个字节。二进制文件虽然也可在屏幕上显示， 但其内容无法读懂。C系统在处理这些文件时，并不区分类型，都看成是字符流，按字节进行处理。 输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。<br>一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’/n’，而二进制模式认为它是两个字符0x0D,0x0A；如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数据作相应的转换。</p><hr><h2 id="C语言以字符形式读写文件"><a href="#C语言以字符形式读写文件" class="headerlink" title="C语言以字符形式读写文件"></a><strong>C语言以字符形式读写文件</strong></h2><p>以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数：fgetc()和fputc()。</p><h3 id="字符读取函数-fgetc"><a href="#字符读取函数-fgetc" class="headerlink" title="字符读取函数 fgetc"></a><strong>字符读取函数 fgetc</strong></h3><p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span> <span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF。</p><p>EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。</p><blockquote><p>EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。</p></blockquote><p>fgetc() 使用举例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char ch<span class="comment">;</span></span><br><span class="line">FILE *<span class="built_in">fp</span> = fopen(<span class="string">"D:\\demo.txt"</span>, <span class="string">"r+"</span>)<span class="comment">;</span></span><br><span class="line">ch = fgetc(<span class="built_in">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>表示从D:\demo.txt文件中读取一个字符，并保存到变量ch中。</p><p>在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用fgetc 函数后，该指针会向后移动一个字节，所以可以连续多次使用fgetc读取多个字符。</p><blockquote><p><strong>注意：</strong>这个文件内部的位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是透明的。</p></blockquote><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//如果文件不存在，给出提示并退出</span></span><br><span class="line">    <span class="keyword">if</span>( (fp=fopen(<span class="string">"D:\\demo.txt"</span>,<span class="string">"rt"</span>)) == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file, press any key to exit!"</span>);</span><br><span class="line">        getch();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次读取一个字节，直到读取完毕</span></span><br><span class="line">    <span class="keyword">while</span>( (ch=fgetc(fp)) != EOF )&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);  <span class="comment">//输出换行符</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在D盘下创建demo.txt文件，输入任意内容并保存，运行程序，就会看到刚才输入的内容全部都显示在屏幕上。</p><p>该程序的功能是从文件中逐个读取字符，在屏幕上显示，直到读取完毕。</p><p>程序第14行是关键，while 循环的条件为(ch=fgetc(fp)) != EOF。fget() 每次从位置指针所在的位置读取一个字符，并保存到变量 ch，位置指针向后移动一个字节。当文件指针移动到文件末尾时，fget() 就无法读取字符了，于是返回 EOF，表示文件读取结束了。</p><h3 id="对EOF的说明"><a href="#对EOF的说明" class="headerlink" title="对EOF的说明"></a><strong>对EOF的说明</strong></h3><p>EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回EOF时，到底是文件读取完毕了还是读取出错了？我们可以借助 stdio.h 中的两个函数来判断，分别是 feof() 和 ferror()。</p><p>feof() 函数用来判断文件内部指针是否指向了文件末尾，它的原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span> <span class="params">( FILE * fp )</span></span>;</span><br></pre></td></tr></table></figure><p>当指向文件末尾时返回非零值，否则返回零值。</p><p>ferror() 函数用来判断文件操作是否出错，它的原型是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span> <span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>出错时返回非零值，否则返回零值。</p><p>需要说明的是，文件出错是非常少见的情况，上面的示例基本能够保证将文件内的数据读取完毕。如果追求完美，也可以加上判断并给出提示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果文件不存在，给出提示并退出</span></span><br><span class="line">    <span class="keyword">if</span>( (fp=fopen(<span class="string">"D:\\demo.txt"</span>,<span class="string">"rt"</span>)) == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file, press any key to exit!"</span>);</span><br><span class="line">        getch();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次读取一个字节，直到读取完毕</span></span><br><span class="line">    <span class="keyword">while</span>( (ch=fgetc(fp)) != EOF )&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);  <span class="comment">//输出换行符</span></span><br><span class="line">    <span class="keyword">if</span>(ferror(fp))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"读取出错"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"读取成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管是出错还是正常读取，都能够做到心中有数。</p><h3 id="字符写入函数fputc"><a href="#字符写入函数fputc" class="headerlink" title="字符写入函数fputc"></a>字符写入函数fputc</h3><p>fputc 是 file output char 的所以，意思是向指定的文件中写入一个字符。调用的形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span> <span class="params">( <span class="keyword">int</span> ch, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回EOF，返回值类型为 int 也是为了容纳这个负数。例如：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fputc<span class="comment">('a', fp)</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch = <span class="string">'a'</span><span class="comment">;</span></span><br><span class="line">fputc(ch, <span class="built_in">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>表示把字符 ‘a’ 写入fp所指向的文件中。</p><p><strong>两点说明：</strong></p><p>1) 被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。</p><p>2) 每写入一个字符，文件内部位置指针向后移动一个字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="comment">//判断文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span>( (fp=fopen(<span class="string">"D:\\demo.txt"</span>,<span class="string">"wt+"</span>)) == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file, press any key to exit!\n"</span>);</span><br><span class="line">        getch();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input a string:\n"</span>);</span><br><span class="line">    <span class="comment">//每次从键盘读取一个字符并写入文件</span></span><br><span class="line">    <span class="keyword">while</span> ( (ch=getchar()) != <span class="string">'\n'</span> )&#123;</span><br><span class="line">        fputc(ch,fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输入一行字符并按回车键结束，打开D盘下的demo.txt文件，就可以看到刚才输入的内容。</p><hr><h2 id="C语言以字符串形式读写文件"><a href="#C语言以字符串形式读写文件" class="headerlink" title="C语言以字符串形式读写文件"></a><strong>C语言以字符串形式读写文件</strong></h2><p>上面一个模块fgetc()和fputc()函数每次只能读写一个字符，速度比较慢，在实际过程中是每次读写一个字符串或者一个数据块，这样能明显提高效率。</p><h3 id="读字符串函数fgets"><a href="#读字符串函数fgets" class="headerlink" title="读字符串函数fgets"></a><strong>读字符串函数fgets</strong></h3><p>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span> <span class="params">( <span class="keyword">char</span> *str, <span class="keyword">int</span> n, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>str 为字符数组，n 为要读取的字符数目，fp 为文件指针。<br><strong>返回值：</strong>读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。</p><p>读取到的字符串会在末尾自动添加 ‘\0’，n 个字符也包括 ‘\0’。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define N 101</span></span><br><span class="line">char str[N]<span class="comment">;</span></span><br><span class="line">FILE *<span class="built_in">fp</span> = fopen(<span class="string">"D:\\demo.txt"</span>, <span class="string">"r"</span>)<span class="comment">;</span></span><br><span class="line">fgets(str, N, <span class="built_in">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>表示从 D:\demo.txt 中读取100个字符，并保存到字符数组str中。</p><p>需要重点说明的是，在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。这就意味着，不管n的值多大，fgets() 最多只能读取一行数据，不能跨行。在C语言中，没有按行读取文件的函数，我们可以借助 fgets()，将n的值设置地足够大，每次就可以读取到一行数据。</p><p>一行一行的读取文件，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> str[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>( (fp=fopen(<span class="string">"d:\\demo.txt"</span>,<span class="string">"rt"</span>)) == <span class="literal">NULL</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file, press any key to exit!\n"</span>);</span><br><span class="line">        getch();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(fgets(str, N, fp) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个D:\demo.txt：文件中写入下面的内容：</p><p> My Name is Android<br> Google</p><p>那么编译运行上面的程序，结果为：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">My <span class="keyword">Name</span> <span class="keyword">is</span> Android </span><br><span class="line">Google 请按任意键继续...</span><br></pre></td></tr></table></figure><h3 id="写字符串函数fputs"><a href="#写字符串函数fputs" class="headerlink" title="写字符串函数fputs"></a>写字符串函数fputs</h3><p>fputs 函数是指想一个文件中写入一个字符串，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> *str,FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p> str为要写入的字符串，fp为文件指针，写入成功返回非负数，失败返回EOF。<br> eg：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str = <span class="string">"xuhao"</span><span class="comment">;</span></span><br><span class="line">FILE *<span class="built_in">fp</span> = fopen(<span class="string">"D:\\demo.text"</span>,<span class="string">"a+"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>表示把字符串str写入到D：\demo.txt文件中。</p><p>在上述代码中建立的D：\demo.txt 文件中追加一个字符串。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line">    FILE *<span class="built_in">fp</span><span class="comment">;</span></span><br><span class="line">    char str[<span class="number">102</span>] = &#123;<span class="number">0</span>&#125;, strTemp[<span class="number">100</span>]<span class="comment">;</span></span><br><span class="line">    if( (<span class="built_in">fp</span>=fopen(<span class="string">"D:\\demo.txt"</span>, <span class="string">"at+"</span>)) == NULL )&#123;</span><br><span class="line">        printf(<span class="string">"Cannot open file, press any key to exit!\n"</span>)<span class="comment">;</span></span><br><span class="line">        getch()<span class="comment">;</span></span><br><span class="line">        exit(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"Input a string:"</span>)<span class="comment">;</span></span><br><span class="line">    gets(strTemp)<span class="comment">;</span></span><br><span class="line">    strcat(str, <span class="string">"\n"</span>)<span class="comment">;</span></span><br><span class="line">    strcat(str, strTemp)<span class="comment">;</span></span><br><span class="line">    fputs(str, <span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    fclose(<span class="built_in">fp</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行程序，在弹出的视图中 输入java C++，打开 D:\demo.txt，文件内容为：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My <span class="keyword">Name</span> <span class="keyword">is</span> Android </span><br><span class="line">Google </span><br><span class="line">java C++</span><br></pre></td></tr></table></figure><h2 id="C语言中其他文件的操作"><a href="#C语言中其他文件的操作" class="headerlink" title="C语言中其他文件的操作"></a><strong>C语言中其他文件的操作</strong></h2><p>比如文件复制，代码如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">char *read_path = <span class="string">"E:<span class="subst">\\</span>dongnao<span class="subst">\\</span>vip<span class="subst">\\</span>ndk<span class="subst">\\</span>08_08_C_05<span class="subst">\\</span>files<span class="subst">\\</span>liuyan.png"</span>;</span><br><span class="line">char *write_path = <span class="string">"E:<span class="subst">\\</span>dongnao<span class="subst">\\</span>vip<span class="subst">\\</span>ndk<span class="subst">\\</span>08_08_C_05<span class="subst">\\</span>files<span class="subst">\\</span>liuyan_new.png"</span>;</span><br><span class="line"><span class="comment">//读的文件 b字符表示操作二进制文件binary</span></span><br><span class="line">FILE *read_fp = fopen(read_path, <span class="string">"rb"</span>);</span><br><span class="line"><span class="comment">//写的文件</span></span><br><span class="line">FILE *write_fp = fopen(write_path, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">int buff[<span class="number">50</span>]; <span class="comment">//缓冲区域</span></span><br><span class="line">int len = <span class="number">0</span>; <span class="comment">//每次读到的数据长度</span></span><br><span class="line">while ((len = fread(buff, sizeof(int), <span class="number">50</span>, read_fp)) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//将读到的内容写入新的文件</span></span><br><span class="line">fwrite(buff,sizeof(int),len,write_fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">fclose(read_fp);</span><br><span class="line">fclose(write_fp);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件的大小</span></span><br><span class="line">void main()&#123;</span><br><span class="line">char *read_path = <span class="string">"E:<span class="subst">\\</span>dongnao<span class="subst">\\</span>vip<span class="subst">\\</span>ndk<span class="subst">\\</span>08_08_C_05<span class="subst">\\</span>files<span class="subst">\\</span>liuyan.png"</span>;</span><br><span class="line">FILE *fp = fopen(read_path, <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">//重新定位文件指针</span></span><br><span class="line"><span class="comment">//SEEK_END文件末尾，0偏移量</span></span><br><span class="line">fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line"><span class="comment">//返回当前的文件指针，相对于文件开头的位移量</span></span><br><span class="line">long filesize = ftell(fp);</span><br><span class="line">printf(<span class="string">"%d<span class="subst">\n</span>"</span>,filesize);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的文件操作也就上面的几种了，有关文件的加密和解密，二进制文件的加密和解密，可能后面应该会结合JNI调用和NDK开发和实现的，好了，这篇文章到此为止！</p><p>CSDN</p><h3 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h3><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。 </p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（六）结构体和联合体</title>
      <link href="/2016/08/25/c/structure-union/"/>
      <url>/2016/08/25/c/structure-union/</url>
      <content type="html"><![CDATA[<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a><strong>结构体</strong></h3><p>在C语言中，可以使用结构体（Struct）来存放一组不同类型的数据。结构体的定义形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">    结构体所包含的变量或数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。请看下面的一个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> group;  <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>stu 为结构体名，它包含了 5 个成员，分别是 name、num、age、group、score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。</p><blockquote><p>注意大括号后面的分号“；”不能少哦~</p></blockquote><p>结构体也是一种数据类型，它由我们自己来定义，可以包含多个其他类型的数据。<br>像int、float、char 等是由C语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可以包含多个基本类型的数据，也可以包含其他的结构体。</p><h4 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a><strong>结构体变量</strong></h4><p>既然结构体是一种数据类型，那么就可以用它来定义变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>, <span class="title">stu2</span>;</span></span><br></pre></td></tr></table></figure><p>定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字struct不能少。</p><p>还可以在定义结构体的同时定义结构体变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> group;  <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;</span><br></pre></td></tr></table></figure><p>如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//没有写 stu</span></span><br><span class="line">    <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> group;  <span class="comment">//所在学习小组</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2;</span><br></pre></td></tr></table></figure><p>这样的写法很简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量了。</p><p>理论上讲结构体的各个成员在内存中是连续存储的，和数组非常类似，例如上面的结构体变量 stu1、stu2 的内存分布如下图所示，共占用 4+4+4+1+4 = 17 个字节。但是在编译器的具体实现中，各个成员之间可能会存在空隙，C语言中，结构体大小的内存分配，参考于这片文章：<a href="http://blog.csdn.net/zhangjay/article/details/6408907" target="_blank" rel="noopener">C语言中结构体大小计算即存储分配</a></p><p>这里我在做下总结：</p><p>   运算符sizeof可以计算出给定类型的大小，对于32位系统来说，sizeof(char) = 1; sizeof(int) = 4。基本数据类型的大小很好计算，我们来看一下如何计算构造数据类型的大小。</p><p>　　C语言中的构造数据类型有三种：数组、结构体和共用体。</p><p>　　数组是相同类型的元素的集合，只要会计算单个元素的大小，整个数组所占空间等于基础元素大小乘上元素的个数。</p><p>　　结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。看下面这样的一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">stu1</span></span></span><br><span class="line"><span class="class">　　&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　<span class="keyword">char</span> c;</span><br><span class="line">　　<span class="keyword">int</span> j;</span><br><span class="line">　　&#125;；</span><br></pre></td></tr></table></figure><p>　　先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址 的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏 移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成 员的大小（4+1）,其值为5。</p><p>　　实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 二、结构体大小必须是所有成员大小的整数倍。</p><p>　　对照第一条，上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。</p><p>　　对照第二条，结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。</p><p>　　再看一个满足第一条，不满足第二条的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">stu2</span></span></span><br><span class="line"><span class="class">　　&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> k;</span><br><span class="line">　　<span class="keyword">short</span> t;</span><br><span class="line">　　&#125;；</span><br></pre></td></tr></table></figure><p>　　成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不 是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。由此可见，大家在定义结构体类型时需要考虑 到字节对齐的情况，不同的顺序会影响到结构体的大小。对比下面两种定义顺序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">stu3</span></span></span><br><span class="line"><span class="class">　　&#123;</span></span><br><span class="line">　　<span class="keyword">char</span> c1;</span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　<span class="keyword">char</span> c2;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">stu4</span></span></span><br><span class="line"><span class="class">　　&#123;</span></span><br><span class="line">　　<span class="keyword">char</span> c1;</span><br><span class="line">　　<span class="keyword">char</span> c2;</span><br><span class="line">　　<span class="keyword">int</span> i;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>　　虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8。</p><p>　　如果结构体中的成员又是另外一种结构体类型时应该怎么计算呢？只需把其展开即可。但有一点需要注意，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">stu5</span></span></span><br><span class="line"><span class="class">　　&#123;</span></span><br><span class="line">　　<span class="keyword">short</span> i;</span><br><span class="line">　　</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">　　  <span class="keyword">char</span> c;</span><br><span class="line">　　  <span class="keyword">int</span> j;</span><br><span class="line">　　&#125; ss;</span><br><span class="line">　</span><br><span class="line">　　<span class="keyword">int</span> k;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>　　结构体stu5的成员ss.c的偏移量应该是4，而不是2。整个结构体大小应该是16。</p><p>　　如何给结构体变量分配空间由编译器决定，以上情况针对的是Linux下的GCC。其他平台的C编译器可能会有不同的处理，看到这里估计还是有些同学不太明白，多看几遍，领悟领悟，就好啦！</p><h4 id="成员的获取和赋值"><a href="#成员的获取和赋值" class="headerlink" title="成员的获取和赋值"></a><strong>成员的获取和赋值</strong></h4><p>结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标[ ]获取单个元素，结构体使用点号.获取单个成员。获取结构体成员的一般格式为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体变量名.成员名<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>通过上面的格式就可以获取成员的值，和给成员赋值，看下面的栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">        <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">        <span class="keyword">char</span> group;  <span class="comment">//所在小组</span></span><br><span class="line">        <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">    &#125; stu1;</span><br><span class="line">    <span class="comment">//给结构体成员赋值</span></span><br><span class="line">    stu1.name = <span class="string">"haozi"</span>;</span><br><span class="line">    stu1.num = <span class="number">12</span>;</span><br><span class="line">    stu1.age = <span class="number">18</span>;</span><br><span class="line">    stu1.group = <span class="string">'A'</span>;</span><br><span class="line">    stu1.score = <span class="number">136.5</span>;</span><br><span class="line">    <span class="comment">//读取结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n"</span>, stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>haozi的学号是12，年龄是18，在A组，今年的成绩是136.5！<br>除了这种方式赋值外，还可以在定义的时候赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> group;  <span class="comment">//所在小组</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">&#125; stu1, stu2 = &#123; <span class="string">"haozi"</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">'A'</span>, <span class="number">136.5</span> &#125;;</span><br></pre></td></tr></table></figure><p>不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。</p><h4 id="结构体与指针"><a href="#结构体与指针" class="headerlink" title="结构体与指针"></a><strong>结构体与指针</strong></h4><p>指针也可以指向一个结构体，定义的形式一般为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 *变量名;</span></span><br></pre></td></tr></table></figure><p>看例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Man</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Man</span> <span class="title">m1</span> = &#123;</span><span class="string">"Jack"</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Man</span> *<span class="title">p</span> = &amp;<span class="title">m1</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s,%d\n"</span>, m1.name, m1.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s,%d\n"</span>,(*p).name,(*p).age);</span><br><span class="line"><span class="comment">//“-&gt;”（箭头）是“(*p).”简写形式</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s,%d\n"</span>, p-&gt;name, p-&gt;age);</span><br><span class="line"><span class="comment">//(*env)-&gt;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译出的结果是：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Jack,</span><span class="number">30</span></span><br><span class="line"><span class="built_in">Jack,</span><span class="number">30</span></span><br><span class="line"><span class="built_in">Jack,</span><span class="number">30</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>  上面代码：printf(“%s,%d\n”, m1.name, m1.age);还可以换成： printf(“%s,%d\n”, （*p）.name, m1.age);或者 printf(“%s,%d\n”, p-&gt;name, m1.age);<br>其运行结果还是一样的。</p><p>获取结构体成员通过结构体指针可以获取结构体成员，一般形式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*<span class="selector-tag">pointer</span>)<span class="selector-class">.memberName</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pointer-&gt;</span><span class="bash">memberName</span></span><br></pre></td></tr></table></figure><h3 id="联合体（共用体）"><a href="#联合体（共用体）" class="headerlink" title="联合体（共用体）"></a><strong>联合体（共用体）</strong></h3><p>结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名&#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>共用体有时也被成为联合体；</p><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><p>共用体也是一种自定义类型，可以通过它来创建变量，例如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    int n;</span><br><span class="line">    char ch;</span><br><span class="line">    double f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure><p>上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    int n;</span><br><span class="line">    char ch;</span><br><span class="line">    double f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure><p>共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存，请看下面的栗子：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;  </span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">var</span>&#123;  </span></span><br><span class="line">        long j;  </span><br><span class="line">        int i;  </span><br><span class="line">&#125;;  </span><br><span class="line">main()&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">var</span> <span class="title">v</span>;</span>  </span><br><span class="line">        v.j = <span class="number">5</span>;  </span><br><span class="line">        printf(<span class="string">"v.j is %d\n"</span>,v.i);  </span><br><span class="line">        v.i = <span class="number">6</span>;  <span class="regexp">//</span>最后一次赋值有效</span><br><span class="line">        printf(<span class="string">"now v.j is %ld! the address is %p\n"</span>,v.j,&amp;v.j);  </span><br><span class="line">        </span><br><span class="line">        printf(<span class="string">"now v.i is %d! the address is %p\n"</span>,v.i,&amp;v.i);  </span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.j is 5  </span><br><span class="line">now v.j is 6! the<span class="built_in"> address </span>is 0xbfad1e2c  </span><br><span class="line">now v.i is 6! the<span class="built_in"> address </span>is 0xbfad1e2c</span><br></pre></td></tr></table></figure><p>这段代码不但验证了共用体的长度，还说明共用体成员之间会相互影响，修改一个成员的值会影响其他成员。</p><p>CSDN</p><h3 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h3><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。 </p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（五）内存分配与释放</title>
      <link href="/2016/08/23/c/memory_allocation/"/>
      <url>/2016/08/23/c/memory_allocation/</url>
      <content type="html"><![CDATA[<p>首先我们来科普一下：</p><h2 id="什么是堆？说到堆，又忍不住说到了栈！什么是-栈？"><a href="#什么是堆？说到堆，又忍不住说到了栈！什么是-栈？" class="headerlink" title="什么是堆？说到堆，又忍不住说到了栈！什么是 栈？"></a><strong>什么是堆？说到堆，又忍不住说到了栈！什么是 栈？</strong></h2><p><strong>1、什么是堆：</strong>堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。<br><strong>2、什么是栈：</strong>栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。<br><a id="more"></a> </p><h2 id="C语言程序编译的内存分配，堆与栈的区别："><a href="#C语言程序编译的内存分配，堆与栈的区别：" class="headerlink" title="C语言程序编译的内存分配，堆与栈的区别："></a><strong>C语言程序编译的内存分配，堆与栈的区别：</strong></h2><ul><li>栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。<br>堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。再强调一次，记得要释放！</li><li>栈区(stack) :<br>   //windows下，栈内存分配2M（确定的常数），超出了限制，提示stack overflow错误<br> //编译器自动分配释放，主要存放函数的参数值，局部变量值等；</li><li><p>堆区(heap)：程序员手动分配释放，操作系统80%内存</p></li><li><p>全局区或静态区：存放全局变量和静态变量；程序结束时由系统释放，分为全局初始化区和全局未初始化区；</p></li><li><p>字符常量区：常量字符串放与此，程序结束时由系统释放；</p></li><li><p>程序代码区：存放函数体的二进制代码。</p></li></ul><p>栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;        <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;       <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> b;          <span class="comment">//栈</span></span><br><span class="line">   <span class="keyword">char</span> s[]=<span class="string">"bb"</span>;  <span class="comment">//栈</span></span><br><span class="line">   <span class="keyword">char</span> *p2;       <span class="comment">//栈</span></span><br><span class="line">   <span class="keyword">char</span> *p3=<span class="string">"123"</span>; <span class="comment">//其中，“123\0”常量区，p3在栈区</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">0</span>; <span class="comment">//全局区</span></span><br><span class="line">   p1=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);   <span class="comment">//10个字节区域在堆区</span></span><br><span class="line">   <span class="built_in">strcpy</span>(p1,<span class="string">"123"</span>);    <span class="comment">//"123\0"在常量区，编译器 可能 会优化为和p3的指向同一块区域</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈内存</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stackFun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//栈内存自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆内存</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapFun</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//40M内存</span></span><br><span class="line"><span class="comment">//字节</span></span><br><span class="line"><span class="comment">//void *任意类型的指针</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">main</span>()&#123;</span><br><span class="line"><span class="comment">//在堆内存上，分配40M的内存</span></span><br><span class="line"><span class="selector-tag">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="selector-tag">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="selector-tag">stackFun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个数组，动态指定数组的大小（在程序运行过长中，可以随意的开辟指定大小的内存，以供使用，相当于Java中的集合）<br><strong>静态内存分配</strong>，分配内存大小的是固定，问题：1.很容易超出栈内存的最大值 2.为了防止内存不够用会开辟更多的内存，容易浪费内存</p><p><strong>动态内存分配</strong>，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用（活水）</p><p><strong>函数：calloc()  分配内存空间并初始化</strong><br>calloc() 函数用来动态地分配内存空间并初始化为 0，其原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span> <span class="params">(<span class="keyword">size_t</span> num, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>calloc() 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</p><p>【返回值】分配成功返回指向该内存的地址，失败则返回 NULL。</p><p><strong>函数：malloc() 动态地分配内存空间</strong></p><p>malloc() 函数用来动态地分配内存空间（如果你不了解动态内存分配，请查看：C语言动态内存分配及变量存储类别），其原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>应用在程序中代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//静态内存分配创建数组，数组的大小是固定的</span></span><br><span class="line"><span class="comment">//int i = 10;</span></span><br><span class="line"><span class="comment">//int a[i];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数组的长度："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟内存，大小len*4字节</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="comment">//p是数组的首地址，p就是数组的名称</span></span><br><span class="line"><span class="comment">//给数组元素赋值（使用这一块刚刚开辟出来的内存区域）</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">p[i] = rand() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%#x\n"</span>, p[i], &amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动释放内存 </span></span><br><span class="line"><span class="comment">//free()释放动态分配的内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>realloc 重新分配内存</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第一次输入数组的长度："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//int* p = malloc(len * sizeof(int));</span></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">calloc</span>(len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; len; i++)&#123;</span><br><span class="line">p[i] = rand() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%#x\n"</span>, p[i], &amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> addLen;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数组增加的长度："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;addLen);</span><br><span class="line"><span class="comment">//内存不够用，扩大刚刚分配的内存空间</span></span><br><span class="line"><span class="comment">//1.原来内存的指针 2.内存扩大之后的总大小</span></span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="built_in">realloc</span>(p, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (len + addLen));</span><br><span class="line"><span class="keyword">if</span> (p2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重新分配失败，世界那么大，容不下我。。。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新分配内存的两种情况："><a href="#新分配内存的两种情况：" class="headerlink" title="新分配内存的两种情况："></a><strong>新分配内存的两种情况：</strong></h2><p>   //缩小，缩小的那一部分数据会丢失<br>    //扩大，（连续的）<br>    1.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针<br>    2.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据库释放掉，返回新的内存地址<br>    3.如果申请失败，返回NULL，原来的指针仍然有效<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接着上面的代码重新赋值</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------------------------\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (; i &lt; len + addLen; i++)&#123;</span><br><span class="line">p2[i] = rand() % <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%#x\n"</span>, p2[i], &amp;p2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动释放内存</span></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">p2 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="内存分配的几个注意细节"><a href="#内存分配的几个注意细节" class="headerlink" title="内存分配的几个注意细节"></a><strong>内存分配的几个注意细节</strong></h2><p>1.不能多次释放；<br>2.释放完之后（指针仍然有值），给指针置NULL，标志释放完成；<br>3.内存泄露（p重新赋值之后，再free，并没有真正释放内存）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数组的长度："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; len; i++)&#123;</span><br><span class="line">p[i] = rand() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%#x\n"</span>, p[i], &amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是C语言中对内存的分配与释放，常用的几个函数~</p><p>CSDN</p><h2 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h2><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。</p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（四）指针概念的理解</title>
      <link href="/2016/08/22/c-pointers/"/>
      <url>/2016/08/22/c-pointers/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近真的是忙的不可开交，公司一直给安排任务，连学习和写笔记的时间都没有了，落下好几次课的笔记都没有写，所以我抽空把目前的进度给追上来，不然会越落越多。加油吧~（感觉身体都要被掏空了） </p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a><strong>指针</strong></h2><p> 我们通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有必要的。<br>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var1;</span><br><span class="line">   <span class="keyword">char</span> var2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"var1 变量的地址： %x\n"</span>, &amp;var1  );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"var2 变量的地址： %x\n"</span>, &amp;var2  );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">var1</span> 变量的地址： <span class="keyword">bff5a400</span></span><br><span class="line"><span class="keyword">var2 </span>变量的地址： <span class="keyword">bff5a3f6</span></span><br></pre></td></tr></table></figure><p>通过上面的栗子，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针吧！</p><h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a><strong>什么是指针？</strong></h2><p>指针是一个变量，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> *<span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>这里的type 是指针的基类型，它必须是一个有效的 C 数据类型，name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="keyword">char</span>   *ch     <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure><p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p><h2 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a><strong>如何使用指针？</strong></h2><ul><li>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="comment">//指针存储的是变量的内存地址</span></span><br><span class="line"><span class="comment">//内存地址，系统给数据分配的编号（门牌号）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">90</span>;</span><br><span class="line"><span class="comment">//指针变量，创建一个int类型的指针</span></span><br><span class="line"><span class="keyword">int</span>* p = &amp;i; <span class="comment">//p的值就是i这个变量的内存地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">89.5f</span>;</span><br><span class="line"><span class="comment">//创建一个float类型的指针</span></span><br><span class="line"><span class="keyword">float</span> *fp = &amp;f;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>, fp);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码被编译和执行时，运行的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xeff</span>b30</span><br><span class="line"><span class="number">0xeff</span>b18</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><ul><li>对指针存的地址指向的变量进行操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>* p)</span></span>&#123;</span><br><span class="line">*p = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量名，对内存空间上的一段数据的抽象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">90</span>;</span><br><span class="line"><span class="comment">//i = 89;</span></span><br><span class="line"><span class="comment">//创建一个int类型的指针</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="comment">//输出地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p的地址：%#x\n"</span>,&amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i的地址：%#x\n"</span>,&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i的值为：%d\n"</span>, i);</span><br><span class="line"><span class="comment">//间接赋值 i = 200;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对p存的地址指向的变量进行操作</span></span><br><span class="line"><span class="comment">//*p = 200;</span></span><br><span class="line"><span class="comment">//change(p);</span></span><br><span class="line">change(&amp;i);  <span class="comment">// int *p = &amp;i;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i的值为：%d\n"</span>,i);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码编译执行结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p的地址：<span class="number">0x6ffdb0</span></span><br><span class="line">i的地址：<span class="number">0x6ffdbc</span></span><br><span class="line">i的值为：<span class="number">90</span></span><br><span class="line">i的值为：<span class="number">300</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>通过上面栗子，我们可以看出，指针所指向的变量值已经被更改了。</p><h2 id="C中的NULL-指针"><a href="#C中的NULL-指针" class="headerlink" title="C中的NULL 指针"></a><strong>C中的NULL 指针</strong></h2><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。<br>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">int</span>  *<span class="built_in">ptr</span> = <span class="literal">NULL</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">   printf(<span class="string">"ptr 的值是 %x\n"</span>, <span class="built_in">ptr</span>  )<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ptr</span> 的值是 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。<br>如需检查一个空指针，您可以使用 if 语句，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *s = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"s is null\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"s is null\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都能判断字符指针是否为空，但推荐使用前者。”NULL” 的本质是个宏，并非是个常量，C99 中甚至可以自行定义，故尽量避免使用它去判断，当 !s 与 s == NULL 表示同一含义的时候，使用前者吧！</p><h2 id="C中的二级指针（多级指针）"><a href="#C中的二级指针（多级指针）" class="headerlink" title="C中的二级指针（多级指针）"></a><strong>C中的二级指针（多级指针）</strong></h2><p>指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int <em>、double </em>、char * 等。</p><p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。<br>假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示：</p><p><img src="http://img.blog.csdn.net/20160821214956473" alt="这里写图片描述"></p><p>用代码表示为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a =100;</span><br><span class="line">int *p1 = &amp;a;</span><br><span class="line">int **p2 = &amp;p1;</span><br></pre></td></tr></table></figure><p>指针变量也是一种变量，也会占用存储空间，也可以使用&amp;获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号 <em> 。p1 是一级指针，指向普通类型的数据，定义时有一个 </em> ；p2 是二级指针，指向一级指针 p1，定义时有两个*。</p><p>如果再定义一个三级指针 p3，让它指向 p2，那么可以这样写：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> ***<span class="built_in">p3</span> = &amp;<span class="built_in">p2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>四级指针：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">int</span> ****<span class="built_in">p4</span> = &amp;<span class="built_in">p3</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>等等，以此类推。。。<br>不过，经常使用的也就是一级指针和二级指针了。<br>在获取指针指向的数据时，一级指针加一个 <em> ，二级指针加两个 </em> ，三级指针加三个 *，以此类推，请看代码：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">    <span class="keyword">int</span> ***p3 = &amp;p2;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"%d, %d, %d, %d\n"</span>, a, *p1, **p2, ***p3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"&amp;p2 = %#X, p3 = %#X\n"</span>, &amp;p2, p3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"&amp;p1 = %#X, p2 = %#X, *p3 = %#X\n"</span>, &amp;p1, p2, *p3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">" &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n"</span>, &amp;a, p1, *p2, **p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行结果如下：<br><img src="http://img.blog.csdn.net/20160821215837967" alt="这里写图片描述"></p><p>以三级指针 p3 为例来分析上面的代码。<em>** p3等价于 </em> ( <em> (</em> p3))。<em> p3 得到的是 p2 的值，也即 p1 的地址；</em> ( <em> p3) 得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后，</em> ( *(p3)) 得到的才是 a 的值。</p><p>假设 a、p1、p2、p3 的地址分别是 0X00A0、0X1000、0X2000、0X3000，它们之间的关系可以用下图来描述：</p><p><img src="http://img.blog.csdn.net/20160821220050579" alt="这里写图片描述"></p><p>方框里面是变量本身的值，方框下面是变量的地址。</p><h2 id="C中指针的运算"><a href="#C中指针的运算" class="headerlink" title="C中指针的运算"></a><strong>C中指针的运算</strong></h2><p>指针变量保存的是地址，本质上是一个整数，可以进行部分运算，例如加法、减法、比较等，请看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//指针的运算，一般在数组遍历时才有意义，基于数组在内存中线性排列的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//数组在内存中连续存储</span></span><br><span class="line"><span class="keyword">int</span> ids[] = &#123; <span class="number">78</span>, <span class="number">90</span>, <span class="number">23</span>, <span class="number">65</span>, <span class="number">19</span> &#125;;</span><br><span class="line"><span class="comment">//数组变量名：ids就是数组的首地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,ids);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,&amp;ids);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,&amp;ids[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//指针变量</span></span><br><span class="line"><span class="keyword">int</span> *p = ids;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);</span><br><span class="line"><span class="comment">//指针的加法</span></span><br><span class="line">p++; <span class="comment">//p++向前移动sizeof(数据类型)个字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p的值:%#x\n"</span>, p);</span><br><span class="line"><span class="comment">//p--;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x5ff7d</span>0</span><br><span class="line"><span class="number">0x5ff7d</span>0</span><br><span class="line"><span class="number">0x5ff7d</span>0</span><br><span class="line"><span class="number">78</span></span><br><span class="line">p的值:<span class="number">0x5ff7d</span>4</span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure><p>从上面的栗子来看，数组变量名：ids就是数组的首地址，指针的加法，p++就是向前移动了sizeof(数据类型)个字节。<br>我们知道，数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示指向下一个元素，减 1 就表示指向上一个元素，不过C语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。</p><p>下面举一个栗子，通过指针获取下一个变量的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, "</span>, *(p+i) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>, <span class="number">-858993460</span>, <span class="number">-858993460</span>, <span class="number">2</span>, <span class="number">-858993460</span>, <span class="number">-858993460</span>, <span class="number">1</span>, <span class="number">-858993460</span>,</span><br></pre></td></tr></table></figure><p>可以看出变量 a、b、c 并不挨着，它们中间还有其他的数据。</p><p>指针变量除了可以参与加减运算，还可以参与比较运算。当对指针变量进行比较运算时，比较的是指针变量本身的值，也就是数据的地址。如果地址相等，那么两个指针就指向同一份数据，否则就指向不同的数据。<br>所以总结出，不要对指向普通变量的指针进行加减运算；另外需要说明的是，不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。</p><h2 id="C中的指针数组"><a href="#C中的指针数组" class="headerlink" title="C中的指针数组"></a><strong>C中的指针数组</strong></h2><p>如果一个数组中的所有元素保存的都是指针，那么我们就称它为指针数组。指针数组的定义形式一般为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType *arrayName[length]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p> ]的优先级高于*，该定义形式应该理解为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType *(<span class="name">arrayName</span>[length])<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>括号里面说明arrayName是一个数组，包含了length个元素，括号外面说明每个元素的类型为dataType *。</p><p>除了每个元素的数据类型不同，指针数组和普通数组在其他方面都是一样的，下面是一个简单的栗子：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = <span class="number">16</span>, b = <span class="number">932</span>, c = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个指针数组</span></span><br><span class="line">    int *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//也可以不指定长度，直接写作 int *parr[]</span></span><br><span class="line">    <span class="comment">//定义一个指向指针数组的指针</span></span><br><span class="line">    int **parr = arr;</span><br><span class="line">    printf(<span class="string">"%d, %d, %d<span class="subst">\n</span>"</span>, *arr[<span class="number">0</span>], *arr[<span class="number">1</span>], *arr[<span class="number">2</span>]);</span><br><span class="line">    printf(<span class="string">"%d, %d, %d<span class="subst">\n</span>"</span>, **(parr+<span class="number">0</span>), **(parr+<span class="number">1</span>), **(parr+<span class="number">2</span>));</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>, <span class="number">932</span>, <span class="number">100</span></span><br><span class="line"><span class="number">16</span>, <span class="number">932</span>, <span class="number">100</span></span><br></pre></td></tr></table></figure><p>arr 是一个指针数组，它包含了 3 个元素，每个元素都是一个指针，在定义 arr 的同时，我们使用变量 a、b、c 的地址对它进行了初始化，这和普通数组是多么地类似。</p><p>parr 是指向数组 arr 的指针，确切地说是指向 arr 第一个元素的指针，它的定义形式应该理解为int <em> ( </em> parr)，括号中的 <em> 表示 parr 是一个指针，括号外面的int </em> 表示 parr 指向的数据的类型。arr 第一个元素的类型为 int <em>，<br> 所以在定义 parr 时要加两个 </em> （星号）（MD语法自动识别其他的格式了）。</p><p>第一个 printf() 语句中，arr[i] 表示获取第 i 个元素的值，该元素是一个指针，还需要在前面增加一个 <em> 才能取得它指向的数据，也即 </em>arr[i] 的形式。</p><p>第二个 printf() 语句中，parr+i 表示第 i 个元素的地址，<em> (parr+i) 表示获取第 i 个元素的值（该元素是一个指针），*</em>(parr+i) 表示获取第 i 个元素指向的数据。</p><p>通过指针给数组赋值，下面是一个简单的栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> uids[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//高级写法</span></span><br><span class="line"><span class="comment">//int i = 0;</span></span><br><span class="line"><span class="comment">//for (; i &lt; 5; i++)&#123;</span></span><br><span class="line"><span class="comment">//uids[i] = i;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//早些版本的写法</span></span><br><span class="line"><span class="keyword">int</span>* p = uids;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,p);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//i是数组元素的值</span></span><br><span class="line"><span class="keyword">for</span> (; p &lt; uids + <span class="number">5</span>; p++)&#123;</span><br><span class="line">*p = i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C中的指针与二维数组"><a href="#C中的指针与二维数组" class="headerlink" title="C中的指针与二维数组"></a><strong>C中的指针与二维数组</strong></h2><p>二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>从概念上来理解，数组a 的分布如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="symbol">8 </span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br></pre></td></tr></table></figure><p>但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：</p><p><img src="http://img.blog.csdn.net/20160821224606127" alt="这里写图片描述"></p><p>C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。</p><p>C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0][0]、a[0][1]、a[0][2]、a[0][3]。</p><p>假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：<br><img src="http://img.blog.csdn.net/20160821224959492" alt="这里写图片描述"></p><p>为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> <span class="comment">(*p)[4] = a;</span></span><br></pre></td></tr></table></figure><p><strong>int *p[4]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。</strong></p><p><strong>int (*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">区分<span class="built_in">int</span> *p[<span class="built_in">n</span>]; 和<span class="built_in">int</span> (*p)[<span class="built_in">n</span>]; 就要看运算符的优先级了。</span><br><span class="line"><span class="built_in">int</span> *p[<span class="built_in">n</span>]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由<span class="built_in">int</span>*说明这是一个整型指针数组。</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="built_in">n</span>]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。</span><br></pre></td></tr></table></figure><p>对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。</p><p>下面我们就来实现如何使用指针 p 来访问二维数组中的每个元素。按照上面的定义：</p><ul><li>p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。</li><li>*(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点：</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;</span><br><span class="line">    int (*p)[<span class="number">4</span>] = a;</span><br><span class="line">    printf(<span class="string">"%d<span class="subst">\n</span>"</span>, sizeof(*(p+<span class="number">1</span>)));</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>  那么，*(p+1)+1表示第 1 行第 1 个元素的地址。这个如何理解呢？（注意，这里的小细节）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(p+<span class="number">1</span>)单独使用时表示的是第 <span class="number">1</span> 行数据，放在表达式中会被转换为第 <span class="number">1</span> 行数据的首地址，也就是第 <span class="number">1</span> 行第 <span class="number">0</span> 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 <span class="number">0</span> 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、&amp; 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 <span class="number">0</span> 个元素的指针。</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* ( *(p+<span class="number">1</span>)+<span class="number">1</span>) 表示第 <span class="number">1</span> 行第 <span class="number">1</span> 个元素的值。很明显，增加一个 * 表示取地址上的数据。</span><br></pre></td></tr></table></figure><p>根据上面的推论，推出以下等价关系：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a+i == p+i</span><br><span class="line">a[i] == p[i] == <span class="emphasis">*(a+i) == *</span>(p+i)</span><br><span class="line">a[<span class="string">i</span>][<span class="symbol">j</span>] == p[<span class="string">i</span>][<span class="symbol">j</span>] == <span class="emphasis">*(a[i]+j) == *</span>(p[i]+j) == <span class="emphasis">*(*</span>(a+i)+j) == <span class="emphasis">*(*</span>(p+i)+j)</span><br></pre></td></tr></table></figure><p>可能有点绕，不好理解，不过没关系，多看几遍，相信你是可以的。</p><p>栗子：<br>使用指针遍历二维数组<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    int(*p)[<span class="number">4</span>];</span><br><span class="line">    int i,j;</span><br><span class="line">    p=a;</span><br><span class="line">    for(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        for(j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++) printf(<span class="string">"%2d  "</span>,*(*(p+i)+j));</span><br><span class="line">        printf(<span class="string">"<span class="subst">\n</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译并运行的结果如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="symbol">8 </span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br></pre></td></tr></table></figure><p><strong>指针数组和二维数组指针的区别：</strong></p><p>指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> *(p1[<span class="number">5</span>]);  <span class="comment">//指针数组，可以去掉括号直接写作 int *p1[5];</span></span><br><span class="line"><span class="selector-tag">int</span> (*p2)<span class="selector-attr">[5]</span>;  <span class="comment">//二维数组指针，不能去掉括号</span></span><br></pre></td></tr></table></figure><p>指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。</p><h2 id="C中的函数指针"><a href="#C中的函数指针" class="headerlink" title="C中的函数指针"></a><strong>C中的函数指针</strong></h2><p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是<strong>函数指针。</strong></p><p><strong>函数指针的定义形式为：</strong></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (<span class="name">*pointerName</span>)(<span class="name">param</span> list)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。</p><p><strong>注意：</strong></p><blockquote><p>( )的优先级高于<em>，第一个括号不能省略，如果写作returnType </em>pointerName(paramlist);<br>就成了函数原型，它表明函数的返回值类型为returnType *。</p></blockquote><p>下面写一个简单的栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msg</span><span class="params">(<span class="keyword">char</span>* msg,<span class="keyword">char</span>* title)</span></span>&#123;</span><br><span class="line">MessageBox(<span class="number">0</span>,msg,title,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//msg();</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,&amp;msg);</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="comment">//函数返回值类型，函数指针的名称，函数的参数列表</span></span><br><span class="line"><span class="keyword">int</span>(*fun_p)(<span class="keyword">char</span>* msg, <span class="keyword">char</span>* title) = msg;</span><br><span class="line">fun_p(<span class="string">"消息内容"</span>,<span class="string">"标题"</span>);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行结果如下：</p><p><img src="http://img.blog.csdn.net/20160822141122306" alt="这里写图片描述"></p><p>上面对msg函数进行了调用，fun_p是一个函数指针。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。</p><p>常见的指针含义：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">int</span> *p;    p 可以指向 <span class="built_in">int</span> 类型的数据，也可以指向类似 <span class="built_in">int</span> arr[<span class="built_in">n</span>] 的数组。</span><br><span class="line">- <span class="built_in">int</span> **p;    p 为二级指针，指向 <span class="built_in">int</span> * 类型的数据。</span><br><span class="line">- <span class="built_in">int</span> *p[<span class="built_in">n</span>];p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 <span class="built_in">int</span> *(p[<span class="built_in">n</span>]);</span><br><span class="line">- <span class="built_in">int</span> (*p)[<span class="built_in">n</span>];p 为二维数组指针。</span><br><span class="line">- <span class="built_in">int</span> *p();    p 是一个函数，它的返回值类型为 <span class="built_in">int</span> *。</span><br><span class="line">- <span class="built_in">int</span> (*p)();p 是一个函数指针，指向原型为 <span class="built_in">int</span> func() 的函数。</span><br></pre></td></tr></table></figure><p>以上就是通过学习对指针的概念的理解，不能再写了，不然又是长篇大论，很难让读者看完，（我也不喜欢）。</p><p>CSDN</p><h2 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h2><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。<br>转载请注明出处：<a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">http://blog.csdn.net/u011974987/article/details/52270018</a><br>个人主页：<a href="http://xuhaoblog.com">xuhaoblog.com</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（三）字符串处理函数</title>
      <link href="/2016/08/13/c/language/string/"/>
      <url>/2016/08/13/c/language/string/</url>
      <content type="html"><![CDATA[<p>C语言提供了丰富的字符串处理函数，例如字符串的输入、输出、合并、修改、比较、转换、复制、搜索等，使用这些现成的函数可大大减轻编程的负担。</p><p>用于输入输出的字符串函数，例如printf、puts、scanf、gets等，使用时应包含头文件stdio.h，使用其它字符串函数则应包含头文件string.h。</p><a id="more"></a><h3 id="1-字符串长度函数strlen"><a href="#1-字符串长度函数strlen" class="headerlink" title="1.字符串长度函数strlen"></a><strong>1.字符串长度函数strlen</strong></h3><p>strlen 是 string length 的缩写，用来获得字符串的长度。所谓长度，就是包含多少个字符（不包括字符串结束标志 ‘\0’）。语法格式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen(<span class="name">arrayName</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>strlen 将返回字符串的长度，它是一个整数。请看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[]=<span class="string">"C language"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The lenth of the string is %d\n"</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The lenth <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">string</span> <span class="keyword">is</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>需要说明的是，strlen 会从字符串的第 0 个字符开始计算，直到遇到字符串结束标志 ‘\0’。将上面代码中的 str 改为：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">str</span>[]=<span class="string">"C \0language"</span>;</span><br></pre></td></tr></table></figure><p>那么输出结果就是：<br><strong>The lenth of the string is 2</strong></p><h3 id="2-字符串连接函数-strcat"><a href="#2-字符串连接函数-strcat" class="headerlink" title="2.字符串连接函数 strcat"></a><strong>2.字符串连接函数 strcat</strong></h3><p>strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(<span class="name">arrayName1</span>, arrayName2)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>arrayName1、arrayName2 为需要拼接的字符串。</p><p>strcat 将把 arrayName2 连接到 arrayName1 后面，并删去 arrayName1 最后的结束标志 ‘\0’。<br><strong>这就意味着，arrayName1 的长度要足够，必须能够同时容纳 arrayName1 和 arrayName2，否则会越界。</strong></p><p>strcat 返回值为 arrayName1 的首地址。请看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">40</span>]=<span class="string">"My name is "</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input your name:"</span>);</span><br><span class="line">    gets(str2);</span><br><span class="line">    <span class="built_in">strcat</span>(str1,str2);</span><br><span class="line">    <span class="built_in">puts</span>(str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input your <span class="built_in">name</span>: xuhao</span><br><span class="line">My <span class="built_in">name</span> <span class="keyword">is</span> xuhao</span><br></pre></td></tr></table></figure><h3 id="3-字符串复制函数strcpy"><a href="#3-字符串复制函数strcpy" class="headerlink" title="3.字符串复制函数strcpy"></a><strong>3.字符串复制函数strcpy</strong></h3><p>strcpy 是 string copy 的缩写，意思是字符串复制，语法格式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(<span class="name">arrayName1</span>, arrayName2)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>strcpy 会把 arrayName2 中的字符串拷贝到 arrayName1 中，串结束标志 ‘\0’ 也一同拷贝。请看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">15</span>], str2[]=<span class="string">"C Language"</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line">    <span class="built_in">puts</span>(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><strong>C Language</strong></p><p>strcat 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。</p><h3 id="4-字符串比较函数strcmp"><a href="#4-字符串比较函数strcmp" class="headerlink" title="4.字符串比较函数strcmp"></a><strong>4.字符串比较函数strcmp</strong></h3><p>strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp(<span class="name">arrayName1</span>, arrayName2)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>arrayName1 和 arrayName2 是需要比较的两个字符串。</p><p>字符本身没有大小之分，strcmp() 是以各个字符在ASCII 码表上对应的数值进行比较的。strcmp() 首先将 arrayName1 中第0个字符的 ASCII 码值减去 arrayName2 中第0个字符的 ASCII 码值，若差值为 0，则说明两个字符相同，再继续比较下个字符，若差值不为 0 则将差值返回。例如字符串”Ac”和”ba”比较则会返回字符”A”(65)和’b’(98)的差值(－33)。</p><p>返回值：若 arrayName1 和 arrayName2 相同，则返回0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于0 的值。</p><p>下面对4组字符串进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">main()&#123;</span><br><span class="line"><span class="keyword">char</span> *a = <span class="string">"AaBbCc"</span>;</span><br><span class="line"><span class="keyword">char</span> *b = <span class="string">"AbCdEf"</span>;</span><br><span class="line"><span class="keyword">char</span> *c = <span class="string">"aacdef"</span>;</span><br><span class="line"><span class="keyword">char</span> *d = <span class="string">"AaBbCc"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strcmp(a, b) : %d\n"</span>, <span class="built_in">strcmp</span>(a, b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strcmp(a, c) : %d\n"</span>, <span class="built_in">strcmp</span>(a, c));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strcmp(a, d) : %d\n"</span>, <span class="built_in">strcmp</span>(a, d));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">strcmp</span><span class="params">(a, b)</span></span> : -<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">strcmp</span><span class="params">(a, c)</span></span> : -<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">strcmp</span><span class="params">(a, d)</span></span> : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>CSDN</p><h3 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h3><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。</p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（二）有符号和无符号的理解</title>
      <link href="/2016/08/07/c/language/signed/"/>
      <url>/2016/08/07/c/language/signed/</url>
      <content type="html"><![CDATA[<h3 id="1-你自已决定是否需要有正负："><a href="#1-你自已决定是否需要有正负：" class="headerlink" title="1.你自已决定是否需要有正负："></a><strong>1.你自已决定是否需要有正负：</strong></h3><p>就像我们必须决定某个量使用整数还是实数，使用多大的范围数一样，我们必须自已决定某个量是否需要正负。如果这个量不会有负值，那么我们可以定它为带正负的类型。</p><p>在计算机中，可以区分正负的类型，称为有符类型（signed），无正负的类型（只有正值），称为无符类型。 （unsigned）数值类型分为整型或实型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。 比如有两个量，年龄和库存，我们可以定前者为无符的字符类型，后者定为有符的整数类型。</p><h3 id="2-使用二制数中的最高位表示正负"><a href="#2-使用二制数中的最高位表示正负" class="headerlink" title="2.使用二制数中的最高位表示正负: "></a><strong>2.使用二制数中的最高位表示正负: </strong></h3><p>首先得知道最高位是哪一位？1个字节的类型，如字符类型，最高位是第7位，2个字节的数，最高位是第15位，4个字节的数，最高位是第31位。不同长度的数值类型，其最高位也就不同，但总是最左边的那位（如下示意）。字符类型固定是1个字节，所以最高位总是第7位。</p><a id="more"></a><p>(红色为最高位)  </p><p><strong>单字节数：</strong> </p><font color="red">1</font>1111111<br><br><strong>双字节数：</strong><br><br><font color="red">1</font>1111111 11111111<br><br><strong>四字节数：</strong><br><br><font color="red">1</font>1111111 11111111 11111111 11111111<br><br>当我们指定一个数量是无符号类型时，那么其最高位的1或0，和其它位一样，用来表示该数的大小。<br>当我们指定一个数量是无符号类型时，此时，最高数称为“符号位”。为1时，表示该数为负值，为0时表示为正值。<br><br><strong>3.无符号数和有符号数的范围区别: </strong><br><br>无符号数中，所有的位都用于直接表示该值的大小。有符号数中最高位用于表示正负，所以，当为正值时，该数的最大值就会变小。我们举一个字节的数值对比：<br><br><strong>无符号数：</strong> 11111111    值：255<br><br><img src="http://img.blog.csdn.net/20160807123518124" alt="这里写图片描述"><br><br><br><strong>有符号数：</strong> 01111111    值：127<br><br><img src="http://img.blog.csdn.net/20160807123533339" alt="这里写图片描述"><br><br>eg：（本屌实在不知道怎么用md语法来打出数学公式，2的幂次方）<br><br>同样是一个字节，无符号数的最大值是255，而有符号数的最大值是127。原因是有符号数中的最高位被挪去表示符号了。并且，我们知道，最高位的权值也是最高的（对于1字节数来说是2的7次方=128），所以仅仅少于一位，最大值一下子减半。<br><br>不过，有符号数的长处是它可以表示负数。因此，虽然它的在最大值缩水了，却在负值的方向出现了伸展。我们仍一个字节的数值对比：<br><br><font color="blue" size="4">无符号数： </font>           0 —————– 255<br><br><font color="blue" size="4">有符号数： </font>          -128 ——— 0 ———- 127<br><br>同样是一个字节，无符号的最小值是 0 ，而有符号数的最小值是-128。<br><br>所以二者能表达的不同的数值的个数都一样是256个。只不过前者表达的是0到255这256个数，后者表达的<br><br>是-128到+127这256个数。<br><br><strong>一个有符号的数据类型的最小值是如何计算出来的呢？</strong><br><br>有符号的数据类型的最大值的计算方法完全和无符号一样，只不过它少了一个最高位（见第3点）。但在负值<br>范围内，数值的计算方法不能直接使用1<em> 26 + 1</em> 25 的公式进行转换。<br><br>在计算机中，负数除为最高位为1以外，还采用补码形式进行表达。所以在计算其值前，需要对补码进行还原。 这里，先直观地看一眼补码的形式：<br><br><br>在10进制中：1 表示正1，而加上负号：-1 表示和1相对的负值。<br><br>那么，我们会很容易认为在2进制中（1个字节）： 0000 0001 表示正1，则高位为1后：1000 0001应该表示-1。<br><br>然而，事实上计算机中的规定有些相反，请看下表：<br><br>|二进制（1字节）| 十进制值   |<br>|:——: | —— |<br>|10000000 | -128   |<br>|10000001 | -127   |<br>|10000010 | -126   |<br>|10000011 | -125   |<br>|10000100 | -124   |<br>| ……  | …… |<br>|11111110 | -2     |<br>|11111111 | -1     |<br><br>首先我们看到，从-1到-128，其二进制的最高位都是1，正如我们前面说的，负数最高位为1，然后我们觉得有点奇怪了，1000 0000 并没有用来表示 0；而 1000 0001也不是拿来直观地表示-1，事实上，-1用1111 1111来表示。<br>怎么理解这个问题呢？先问一句是-1大还是-128大？<br>当然是-1大，那么，1111 1111 -1是什么呢？ 和现实中的计算结果完全一致。1111 1111 -1=1111 1110，而1111 1110 就是-2，就这样一直减下去，当见到只剩最高位用于表示符号的1意外，其他低位全为0时，就是最小的负值，在一字节中，最小的负值是1000 0000，也就是-128。<br>我们以-1位例，来看看不同字节数的整数中，如何表达-1这个数；<br><br>| 字节数 |   二进制值     |         十进制值 |<br>|:——:  | ——   |  —— |<br>|单字节数  | 11111111 | -1   |<br>|双字节数 | 11111111 11111111  |-1  |<br>|四字节数| 11111111 11111111 11111111 11111111 | -1 |<br><br>可能有些人看到这里，就已经混了，为什么呢？1111 1111 有时表示255，有时又表示-1？所以我再强调 前面说的第二点，你自己决定一个数是有符号还是无符号的，写程序时，指定一个量是有符号的，那么当这个量的二进制各位上的数都是1时，它表示的数就是-1；相反，如果事先声明这个量是无符号的， 此时它表示的就是该量允许的最大值，对于一个字节的数来说，最大值就是255。<br><br><br><br><br>我们已经知道计算机中，所有数据最终都是使用二进制数表达。 也已经学会如何将一个10进制数如何转换为二进制数。 不过，我们仍然没有学习一个负数如何用二进制表达。  比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：<br><br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00000000 </span><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span></span><br></pre></td></tr></table></figure><br><br>5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。 现在想知道，-5在计算机中如何表示？ 在计算机中，负数以其正值的补码形式表达。    什么叫补码呢？这得从原码，反码说起。<br><br><br><strong>原码：</strong>一个整数，按照绝对值大小转换成的二进制数，最高为为符号位，称为原码。 红色为符号位<br><br>比如：<br><br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00000000 </span><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span>  是 <span class="number">5</span>的原码。                      </span><br><span class="line"><span class="symbol">10000000 </span><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span>  是-<span class="number">5</span>的原码。</span><br></pre></td></tr></table></figure><br><br><strong>反码：</strong> 将二进制除符号位数按位取反，所得的新二进制数称为原二进制数的反码。 正数的反码为原码，负数的反码是原码符号位外按位取反。<br><br> 取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）<br><br><font color="red" size="4">正数：正数的反码与原码相同。 </font><br><font color="red" size="4">负数：负数的反码，符号位为“1”，数值部分按位取反。  </font> <p><strong>比如：</strong>将10000000 00000000 00000000 00000101除符号位每一位取反，<br>得11111111 11111111 11111111 11111010。   </p><p>这时候我们称：11111111 11111111 11111111 11111010 是 10000000 00000000 00000000 00000101 的反码。 </p><font color="black" size="4">反码是相互的， </font> 所以也可称：<br>11111111 11111111 11111111 11111010 和 10000000 00000000 00000000 00000101 互为反码。<br><br><br><strong>补码：</strong> 反码加1称为补码。  <font color="red" size="4"> （如果反码最后一位是1得话就向前加1）</font><br> 1. 正数：正数的补码和原码相同。<br> 2. 负数：按照规则来<br>也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。<br> 11111111 11111111 11111111 11111010 是 10000000 00000000 00000000 00000101（-5） 的反码。<br>加1得11111111 11111111 11111111 11111011<br>所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六<br><br>进制：0xFFFFFFFB。<br>再举一例，我们来看整数-1在计算机中如何表示。<br>假设这也是一个int类型，那么：<br><br> 1、先取-1的原码：        10000000 00000000 00000000 00000001<br> 2、除符号位取反得反码：   11111111 11111111 11111111 11111110<br> 3、加1得补码：            11111111 11111111 11111111 11111111<br><br> 可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF。<br><br> <strong>计算机中带有符号数用补码表示的优点：</strong><br><br><font color="red" size="4">1、负数的补码与对应正数的补码之间的转换可以用同一种方法——求补运算完成，可以简化硬件；<br>2、可将减法变为加法，省去减法器；<br>3、无符号数及带符号数的加法运算可以用同一电路完成。 </font><p>可得出一种心算求补的方法——从最低位开始至找到的第一个1均不变，符号位不变，这之间的各位“求反”(该方法仅用于做题）</p><table><thead><tr><th style="text-align:center">方法</th><th>例子1</th><th>列子2</th></tr></thead><tbody><tr><td style="text-align:center">1,从右边开始，找到第一个“1”</td><td>10101001</td><td>10101100</td></tr><tr><td style="text-align:center">2,从这个“1”之后开始到最左边取反（不包括符号位，也就是最高位）</td><td>11010111</td><td>11010100</td></tr></tbody></table><p><strong>注意：（如果反码最后一位是1得话就向前加1）</strong></p><p>CSDN</p><h3 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h3><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>查找资料学习理解并整理下来。<br>希望大家能提出宝贵意见，一起学习。</p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言（一）的基本数据类型</title>
      <link href="/2016/08/07/c-language/"/>
      <url>/2016/08/07/c-language/</url>
      <content type="html"><![CDATA[<h2 id="C语言helloworld"><a href="#C语言helloworld" class="headerlink" title="C语言helloworld"></a>C语言helloworld</h2><hr><p>1.声明头文件，相当于java的导包。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//只有函数的声明，编译时会去找到函数的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><p>2.写main()方法 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span>()&#123;</span><br><span class="line"> <span class="selector-tag">printf</span>(<span class="string">"hello from c\n"</span>);    <span class="comment">//\n换行   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.为了观察程序执行的结果，需要调用windows系统的一个指令</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待输入</span></span><br><span class="line"><span class="selector-tag">system</span>(<span class="string">"pause"</span>); 或者<span class="selector-tag">getchar</span>();</span><br></pre></td></tr></table></figure><h2 id="C语言的基本数据类型"><a href="#C语言的基本数据类型" class="headerlink" title="C语言的基本数据类型"></a>C语言的基本数据类型</h2><hr><ul><li><p><strong>C语言的数据类型：</strong> </p><p><img src="http://img.blog.csdn.net/20160806212417802" alt="这里写图片描述"></p></li><li><p><strong>java语言的8大基本类型</strong> </p><ul><li>int   4byte  32位</li><li>byte  1byte  8位</li><li>short 2byte  16位</li><li>long  8byte   64位</li><li>float 4byte   32位</li><li>double 8byte  64位</li><li>boolean 1byte 8位</li><li>char   2byte 16位</li></ul></li><li><p><strong>c语言的基本数据类型</strong></p><blockquote><p>sizeof();获取一个数据类型的长度 </p></blockquote><ul><li>char    1byte 8位 和java不同</li><li>long    4byte 32位和java不同</li><li>int       4byte 32位 和java一致</li><li>float    4byte 32位 和java一致</li><li>double     8byte  64位和java一致</li><li>short 2byte      16位 还可以表示java里面的char</li><li>在c语言里面没有boolean类型，0假 非0真</li><li>在c语言里面没有byte类型 可以用char表示byte类型。</li></ul></li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">char, int, float, double, long, short and  组合关键字signed, unsigned,  void</span></span><br><span class="line"><span class="comment">sizeof();获取一个数据类型的长度 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">short</span>));    </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"signed int的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>));      <span class="comment">// -2的31次方~ 2的31次方-1 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unsigned int的占据的byte为%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));    <span class="comment">//0~ 2的32次方-1  </span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int*占据的byte为%d \n "</span> ,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char*占据的byte为%d \n "</span> ,<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float*占据的byte为%d \n "</span> ,<span class="keyword">sizeof</span>(<span class="keyword">float</span>*)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double*占据的byte为%d \n "</span> ,<span class="keyword">sizeof</span>(<span class="keyword">double</span>*)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long*占据的byte为%d \n "</span> ,<span class="keyword">sizeof</span>(<span class="keyword">long</span>*)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short*占据的byte为%d \n "</span> ,<span class="keyword">sizeof</span>(<span class="keyword">short</span>*)); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="http://img.blog.csdn.net/20160806213113253" alt="这里写图片描述"></p><p>CSDN</p><h2 id="更多系列相关文章传送门："><a href="#更多系列相关文章传送门：" class="headerlink" title="更多系列相关文章传送门："></a>更多系列相关文章传送门：</h2><p><a href="http://blog.csdn.net/u011974987/article/details/52138798" target="_blank" rel="noopener">C语言（一）基本数据类型</a><br><a href="http://blog.csdn.net/u011974987/article/details/52142794" target="_blank" rel="noopener">C语言（二）有符号数和无符号数的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52200178" target="_blank" rel="noopener">C语言（三）字符串处理函数</a><br><a href="http://blog.csdn.net/u011974987/article/details/52270018" target="_blank" rel="noopener">C语言（四）指针概念的理解</a><br><a href="http://blog.csdn.net/u011974987/article/details/52290724" target="_blank" rel="noopener">C语言（五）内存的分配与释放</a><br><a href="http://blog.csdn.net/u011974987/article/details/52305364" target="_blank" rel="noopener">C语言（六）结构体和联合体</a><br><a href="http://blog.csdn.net/u011974987/article/details/52354074" target="_blank" rel="noopener">C语言（七）文件的相关操作</a></p><blockquote><p>学习理解并整理下来的笔记。<br>希望大家能够指点或提出宝贵意见，谢谢！一起学习。<br>个人主页：<a href="http://xuhaoblog.com">xuhaoblog.com</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 性能检测工具</title>
      <link href="/2016/06/27/performance_tests/"/>
      <url>/2016/06/27/performance_tests/</url>
      <content type="html"><![CDATA[<h4 id="Android常见问题"><a href="#Android常见问题" class="headerlink" title="Android常见问题"></a>Android常见问题</h4><ul><li><p>内存泄漏：不使用的内存空间(对象)一直被引用着没有得到释放。</p></li><li><p>内存抖动：短时间内大量创建对象又在短时间内频繁触发GC导致内存波动很大，android虚拟机执行GC操作时需要耗费CPU性能频繁GC会到来严重的性能问题。内存抖动是因为大量的对象被创建又在短时间内马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p><a id="more"></a></li><li><p>内存溢出：内存泄漏到一定程度超出系统给进程分配的内存大小就会造成内存溢出程序奔溃，或者加载一个或多个大型文件(图片)到内存中也会导致内存溢出。</p></li><li><p>ANR：应用无响应，代码效率过低或者在主线程执行耗时操作。</p></li></ul><h4 id="内存监控工具"><a href="#内存监控工具" class="headerlink" title="内存监控工具"></a>内存监控工具</h4><ul><li><p><a href="http://zmywly8866.github.io/2016/05/04/android-application-leak-analysis-and-fix.html" target="_blank" rel="noopener">adb shell dumpsys meminfo</a>：内存泄露检测和改善。</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100906" target="_blank" rel="noopener">Memory Monitor</a>：查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号。</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100909" target="_blank" rel="noopener">Allocation Tracker</a>：使用此工具来追踪内存的分配。</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100907" target="_blank" rel="noopener">Heap Viewer</a>：实时查看App分配的内存大小和空闲内存大小，发现Memory Leaks</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100910" target="_blank" rel="noopener">Heap Snapshot</a>：获取Java堆内存详细信息，可以分析出内存泄漏的问题</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100912" target="_blank" rel="noopener">Memory Analyzer Tool</a>：MAT一款详细分析Java堆内存的工具，该工具非常强大，为了使用该工具，我们需要hprof文件，该文件我们在之前的Heap Snapshot工具的时候，我们就生成了该文件。但是该文件不能直接被MAT使用，需要进行一步转化，可以使用hprof-conv命令来转化，但是Android Studio可以直接转化。</p></li></ul><h4 id="性能监控工具"><a href="#性能监控工具" class="headerlink" title="性能监控工具"></a>性能监控工具</h4><ul><li><p><a href="http://blog.csdn.net/xu_fu/article/details/45008779" target="_blank" rel="noopener">Profile GPU Rendering</a>：连续多帧每一帧的刷新时间都超过16ms就应该被视为性能问题。</p></li><li><p><a href="http://hukai.me/android-performance-patterns-season-5/" target="_blank" rel="noopener">Profile GPU Rendering : M Update</a>：Profile GPU Rendering的升级版。</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100911" target="_blank" rel="noopener">TraceView</a>：从代码层面分析性能问题，针对每个方法来分析，比如当我们发现我们的应用出现卡顿的时候，我们可以来分析出现卡顿时在方法的调用上有没有很耗时的操作，关注以下两个问题：</p></li></ul><ul><li>调用次数不多，但是每一次执行都很耗时</li><li>方法耗时不大，但是调用次数太多</li></ul><ul><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100913" target="_blank" rel="noopener">Systrace</a>：计算容器的性能并发现性能的瓶颈。</p></li><li><p><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100914" target="_blank" rel="noopener">GPU Monitor</a>：分析GPU的性能，实时查看绘制每一帧所花费的时间，与Profile GPU Rendering差不多。</p></li><li><p><a href="http://tech.it168.com/a2011/0908/1243/000001243936_all.shtml" target="_blank" rel="noopener">Strict Mode</a>：UI线程被阻塞超过5秒，就会出现ANR，这太糟糕了。防止程序出现ANR是很重要的事情，那么如何找出程序里面潜在的坑，预防ANR呢？很多大部分情况下执行很快的方法，但是他们有可能存在巨大的隐患，这些隐患的爆发就很容易导致ANR。<br>Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过StrictMode API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。</p></li><li><p><a href="http://blog.csdn.net/xyz_lmn/article/details/14222939" target="_blank" rel="noopener">LINT</a>：Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具。<br>例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -&gt; Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。<br>Lint的功能非常强大，他能够扫描各种问题。当然我们可以通过Android Studio设置找到Lint，对Lint做一些定制化扫描的设置，可以选择忽略掉那些不想Lint去扫描的选项，我们还可以针对部分扫描内容修改它的提示优先级。<br>建议把与内存有关的选项中的严重程度标记为红色的Error，对于Layout的性能问题标记为黄色Warning。</p></li><li><p><a href="http://www.cnblogs.com/vanezkw/archive/2013/05/24/3096815.html" target="_blank" rel="noopener">Monkey</a>：Monkey是可以运行在模拟器里或实际设备中的程序。它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，实现对正在开发的应用程序进行压力测试。</p></li><li><p><a href="http://zmywly8866.github.io/2015/09/09/android-performance-tools.html" target="_blank" rel="noopener">其他工具</a>：其他性能检测工具</p></li></ul><h4 id="网络监控工具"><a href="#网络监控工具" class="headerlink" title="网络监控工具"></a>网络监控工具</h4><ul><li><a href="http://www.kancloud.cn/digest/itfootballprefermanc/100915" target="_blank" rel="noopener">Network monitor</a>：实时监控上传和接收的网速</li></ul>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义一款炫酷的加载控件</title>
      <link href="/2016/05/13/Android-custom-loadingview/"/>
      <url>/2016/05/13/Android-custom-loadingview/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p>在设计应用的时候，我们应该热爱极简主义，简单就是好的，对于很多用户来说，复杂的东西并不受欢迎。<br>我要实现的是根据不同的情况去显示不同的加载效果，随用随调，效果是借鉴于某一项目的效果，我认为有必要提取出来改善封装一下，供以后使用。情况大致分为：加载中、无网络、无数据、加载失败等；<br><a id="more"></a></p><h4 id="预览下效果图"><a href="#预览下效果图" class="headerlink" title="预览下效果图"></a><strong>预览下效果图</strong></h4><p><img src="http://img.blog.csdn.net/20160519152132230" alt="这里写图片描述"></p><h4 id="我们怎么实现这种效果呢"><a href="#我们怎么实现这种效果呢" class="headerlink" title="我们怎么实现这种效果呢"></a><strong>我们怎么实现这种效果呢</strong></h4><p>view_loading.xml的布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/lin_loading"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/img_loading"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/loading_animation"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/tv_loading"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">"14sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/lin_load"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"visible"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_load"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/tv_load"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_load"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">"14sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>从布局来看，我分了两个部分，一个是加载中，另外一个是带有ImagView、文字和按钮的布局，有人看到这，就会说，哇靠，这不是很简单吗？根据不同的情况去设置Visibility的值就好了啊，没错，原理就是这样。</strong></p><p>XHLoadingView.java的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woyou.loadingdemo.widget;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.AnimationDrawable;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.FrameLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.woyou.loadingdemo.LoadingState;</span><br><span class="line"><span class="keyword">import</span> com.woyou.loadingdemo.R;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiho on 11:21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XHLoadingView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="comment">// 加载中的布局</span></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mLinearLoad;</span><br><span class="line">    <span class="comment">//其他加载的布局</span></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mLinearLoading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTvLoading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTvLoad;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView mIvLoading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView mIvLoad;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mBtnLoad;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadingState mState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnimationDrawable animation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XHLoadingView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XHLoadingView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XHLoadingView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XHLoadingView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">        mContext = context;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LayoutInflater.from(mContext).inflate(R.layout.view_loading, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        mLinearLoading = (LinearLayout) findViewById(R.id.lin_loading);</span><br><span class="line"></span><br><span class="line">        mLinearLoad = (LinearLayout) findViewById(R.id.lin_load);</span><br><span class="line"></span><br><span class="line">        mIvLoading = (ImageView) findViewById(R.id.img_loading);</span><br><span class="line"></span><br><span class="line">        mIvLoad = (ImageView) findViewById(R.id.iv_load);</span><br><span class="line"></span><br><span class="line">        mTvLoading = (TextView) findViewById(R.id.tv_loading);</span><br><span class="line"></span><br><span class="line">        mTvLoad = (TextView) findViewById(R.id.tv_load);</span><br><span class="line"></span><br><span class="line">        mBtnLoad = (Button) findViewById(R.id.btn_load);</span><br><span class="line"></span><br><span class="line">        mBtnLoad.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                setState(LoadingState.STATE_LOADING);</span><br><span class="line">                mOnRetryListener.onRetry();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setVisibility(visibility);</span><br><span class="line">        <span class="keyword">if</span>(View.GONE==visibility &amp;&amp; mState==LoadingState.STATE_LOADING &amp;&amp; animation!=<span class="keyword">null</span>&amp;&amp;animation.isRunning())&#123;</span><br><span class="line">            animation.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载中提示文字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mLoadingText;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLoadingIcon;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadingIcon</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</span><br><span class="line">        mLoadingIcon = resId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载数据为空提示文字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mLoadEmptyText;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLoadEmptyIcon;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withEmptyIcon</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</span><br><span class="line">        mLoadEmptyIcon = resId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无网络提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mLoadNoNetworkText;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mNoNetworkIcon;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withNoNetIcon</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</span><br><span class="line">        mNoNetworkIcon = resId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnRetryListener mOnRetryListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义重试的的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnRetryListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onRetry</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withOnRetryListener</span><span class="params">(OnRetryListener mOnRetryListener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mOnRetryListener = mOnRetryListener;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  设置加载的状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(LoadingState state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mState==state)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state==LoadingState.STATE_LOADING)&#123;</span><br><span class="line">            mLinearLoading.setVisibility(VISIBLE);</span><br><span class="line">            mLinearLoad.setVisibility(GONE);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state!=LoadingState.STATE_LOADING)&#123;</span><br><span class="line">            mLinearLoading.setVisibility(GONE);</span><br><span class="line">            mLinearLoad.setVisibility(VISIBLE);</span><br><span class="line">            <span class="keyword">if</span>(animation!=<span class="keyword">null</span> &amp;&amp; mState==LoadingState.STATE_LOADING)</span><br><span class="line">                animation.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        changeState(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> btnEmptyEnable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> btnErrorEnable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> btnNoNetworkEnable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withBtnNoNetEnnable</span><span class="params">(<span class="keyword">boolean</span> ennable)</span> </span>&#123;</span><br><span class="line">        btnNoNetworkEnable = ennable;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withBtnErrorEnnable</span><span class="params">(<span class="keyword">boolean</span> ennable)</span> </span>&#123;</span><br><span class="line">        btnErrorEnable = ennable;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withBtnEmptyEnnable</span><span class="params">(<span class="keyword">boolean</span> ennable)</span> </span>&#123;</span><br><span class="line">        btnEmptyEnable = ennable;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改变状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(LoadingState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="comment">//加载中</span></span><br><span class="line">            <span class="keyword">case</span> STATE_LOADING:</span><br><span class="line">                mState = LoadingState.STATE_LOADING;</span><br><span class="line">                mIvLoading.setImageResource(mLoadingIcon);</span><br><span class="line">                mTvLoading.setText(mLoadingText);</span><br><span class="line">                <span class="keyword">if</span> (animation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    animation = (AnimationDrawable) mIvLoading.getDrawable();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (animation != <span class="keyword">null</span>)</span><br><span class="line">                    animation.start();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//数据为空</span></span><br><span class="line">            <span class="keyword">case</span> STATE_EMPTY:</span><br><span class="line">                mState = LoadingState.STATE_EMPTY;</span><br><span class="line">                mIvLoad.setImageResource(mLoadEmptyIcon);</span><br><span class="line">                mTvLoad.setText(mLoadEmptyText);</span><br><span class="line">                <span class="keyword">if</span> (btnEmptyEnable) &#123;</span><br><span class="line">                    mBtnLoad.setVisibility(VISIBLE);</span><br><span class="line">                    mBtnLoad.setText(btn_empty_text);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBtnLoad.setVisibility(GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//加载失败</span></span><br><span class="line">            <span class="keyword">case</span> STATE_ERROR:</span><br><span class="line">                mState = LoadingState.STATE_ERROR;</span><br><span class="line">                mIvLoad.setImageResource(mErrorIco);</span><br><span class="line">                mTvLoad.setText(mLoadErrorText);</span><br><span class="line">                <span class="keyword">if</span> (btnErrorEnable) &#123;</span><br><span class="line">                    mBtnLoad.setVisibility(VISIBLE);</span><br><span class="line">                    mBtnLoad.setText(btn_error_text);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBtnLoad.setVisibility(GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//无网络</span></span><br><span class="line">            <span class="keyword">case</span> STATE_NO_NET:</span><br><span class="line">                mState = LoadingState.STATE_NO_NET;</span><br><span class="line">                mIvLoad.setImageResource(mNoNetworkIcon);</span><br><span class="line">                mTvLoad.setText(mLoadNoNetworkText);</span><br><span class="line">                <span class="keyword">if</span> (btnNoNetworkEnable) &#123;</span><br><span class="line">                    mBtnLoad.setVisibility(VISIBLE);</span><br><span class="line">                    mBtnLoad.setText(btn_nonet_text);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBtnLoad.setVisibility(GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后台或者本地出现错误提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mLoadErrorText;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mErrorIco;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withErrorIco</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        mErrorIco = resId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载空数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadEmptyText</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        mLoadEmptyText = getResources().getString(resId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadEmptyText</span><span class="params">(String mLoadEmptyText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoadEmptyText = mLoadEmptyText;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  无网络时候加载文字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadNoNetworkText</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        mLoadNoNetworkText = getResources().getString(resId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String btn_empty_text = <span class="string">"重试"</span>;</span><br><span class="line">    <span class="keyword">public</span> String btn_error_text = <span class="string">"重试"</span>;</span><br><span class="line">    <span class="keyword">public</span> String btn_nonet_text = <span class="string">"重试"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据为空的Button的文字提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withBtnEmptyText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.btn_empty_text = text;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载错误的Button的文字提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withBtnErrorText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.btn_error_text = text;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载错误的文字提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadErrorText</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoadErrorText = getResources().getString(resId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadErrorText</span><span class="params">(String mLoadedErrorText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoadErrorText = mLoadedErrorText;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载无网络的Button的文字提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withBtnNoNetText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.btn_nonet_text = text;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载没有网路的文字提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mLoadedNoNetText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadNoNetworkText</span><span class="params">(String mLoadedNoNetText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoadNoNetworkText = mLoadedNoNetText;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadingText</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoadingText = getResources().getString(resId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XHLoadingView <span class="title">withLoadingText</span><span class="params">(String mLoadingText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLoadingText = mLoadingText;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对不同的情况作了不同的处理，然后我们在需要的Activity调用。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">XHLoadingView</span> mLoadingView;</span><br><span class="line"> </span><br><span class="line">    @<span class="type">Override</span></span><br><span class="line">    protected void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_display);</span><br><span class="line">        mLoadingView = (<span class="type">XHLoadingView</span>) findViewById(<span class="type">R</span>.id.lv_loading);</span><br><span class="line">        mLoadingView.withLoadEmptyText(<span class="string">"≥﹏≤ , 啥也木有 !"</span>).withEmptyIcon(<span class="type">R</span>.drawable.disk_file_no_data).withBtnEmptyEnnable(<span class="literal">false</span>)</span><br><span class="line">                    .withErrorIco(<span class="type">R</span>.drawable.ic_chat_empty).withLoadErrorText(<span class="string">"(῀( ˙᷄ỏ˙᷅ )῀)ᵒᵐᵍᵎᵎᵎ,我家程序猿跑路了 !"</span>).withBtnErrorText(<span class="string">"臭狗屎!!!"</span>)</span><br><span class="line">                    .withLoadNoNetworkText(<span class="string">"你挡着信号啦o(￣ヘ￣o)☞ᗒᗒ 你走"</span>).withNoNetIcon(<span class="type">R</span>.drawable.ic_chat_empty).withBtnNoNetText(<span class="string">"网弄好了，重试"</span>)</span><br><span class="line">                    .withLoadingIcon(<span class="type">R</span>.drawable.loading_animation).withLoadingText(<span class="string">"加载中..."</span>).withOnRetryListener(<span class="function"><span class="keyword">new</span> <span class="title">XHLoadingView</span>.<span class="title">OnRetryListener</span>() &#123;</span></span><br><span class="line"><span class="function">                @<span class="title">Override</span></span></span><br><span class="line"><span class="function">                <span class="title">public</span> <span class="title">void</span> <span class="title">onRetry</span>() &#123;</span></span><br><span class="line"><span class="function">                    <span class="title">SnackbarUtil</span>.<span class="title">show</span>(mLoadingView,"已经在努力重试了",<span class="number">0</span>);</span></span><br><span class="line"><span class="function">                &#125;</span></span><br><span class="line"><span class="function">            &#125;).<span class="title">build</span>();</span></span><br><span class="line"><span class="function">     &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">........</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">//加载中</span></span></span><br><span class="line"><span class="function">      <span class="title">mLoadingView</span>.<span class="title">setVisibility</span>(<span class="type">View</span>.<span class="type">VISIBLE</span>);</span></span><br><span class="line"><span class="function">      <span class="title">mLoadingView</span>.<span class="title">setState</span>(<span class="type">LoadingState</span>.<span class="type">STATE_LOADING</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="comment">//空数据</span></span></span><br><span class="line"><span class="function">  <span class="title">mLoadingView</span>.<span class="title">setVisibility</span>(<span class="type">View</span>.<span class="type">VISIBLE</span>);</span></span><br><span class="line"><span class="function">      <span class="title">mLoadingView</span>.<span class="title">setState</span>(<span class="type">LoadingState</span>.<span class="type">STATE_EMPTY</span>)</span></span><br><span class="line"><span class="function"> <span class="comment">//无网络</span></span></span><br><span class="line"><span class="function">  <span class="title">mLoadingView</span>.<span class="title">setVisibility</span>(<span class="type">View</span>.<span class="type">VISIBLE</span>);</span></span><br><span class="line"><span class="function">      <span class="title">mLoadingView</span>.<span class="title">setState</span>(<span class="type">LoadingState</span>.<span class="type">STATE_NO_NET</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="comment">//加载错误</span></span></span><br><span class="line"><span class="function">  <span class="title">mLoadingView</span>.<span class="title">setVisibility</span>(<span class="type">View</span>.<span class="type">VISIBLE</span>);</span></span><br><span class="line"><span class="function">      <span class="title">mLoadingView</span>.<span class="title">setState</span>(<span class="type">LoadingState</span>.<span class="type">STATE_ERROR</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">.......</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   &#125;</span></span><br></pre></td></tr></table></figure><p>源码中注释详细，就不用再做过多的解释了吧！</p><h4 id="完整代码：XHLoadingView"><a href="#完整代码：XHLoadingView" class="headerlink" title="完整代码：XHLoadingView"></a><strong>完整代码</strong>：<a href="https://github.com/git-xuhao/XHLoadingView" target="_blank" rel="noopener">XHLoadingView</a></h4><blockquote><p>希望您能指出宝贵意见，谢谢。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 异常退出的生命周期分析</title>
      <link href="/2016/04/25/Android-exception-exit/"/>
      <url>/2016/04/25/Android-exception-exit/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p>典型的Activity 生命周期众所周知，就不用多说了吧；我们知道，Activity除了受用户操作所导致的正常的生命周期方法调度，还有一些异常情况，比如当资源相关的系统配置发生了改变以及系统内存不足时，Activity就可能被杀死，下面就来具体分析这两种情况。<br><a id="more"></a></p><h4 id="情况一-：-当一个activity的config改变的时候，Activity就会被杀死然后重建"><a href="#情况一-：-当一个activity的config改变的时候，Activity就会被杀死然后重建" class="headerlink" title="情况一 ： 当一个activity的config改变的时候，Activity就会被杀死然后重建"></a><strong>情况一 ：</strong> 当一个activity的config改变的时候，Activity就会被杀死然后重建</h4><p>而我们最熟悉的config的改变就是屏幕方向改变，系统语言改变，还有键盘可见改变了等等，系统配置发生了改变，在默认情况下，Activity就会被销毁并且重新创建，当然我们也可阻止系统重新创建我们的Activity。</p><p>在默认情况下，如果我们的Activity不做特殊处理，那么当系统配置发生改变后，Activity就会被销毁并重新创建，如图所示：<br><img src="http://img.blog.csdn.net/20160425154234928" alt="这里写图片描述"></p><p>当系统配置发生改变后，Activiy会被销毁，其onPause、onStop、onDestroy 均会被调用，同时由于Activiy 是在异常情况下终止的，系统会在onStop之前调用onSaveInstanState来保存当前Activiy的状态。<br>所以当出现异常有重要的数据需要恢复的，要在这里做一些数据的保存工作；系统只会帮我们保存视图。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState); </span><br><span class="line">   <span class="comment">//在这里我们可以把我们需要保存的东西给写入Bundle </span></span><br><span class="line">   <span class="comment">//....... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们保存的数据就可以在onCreate中来读取了：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState); </span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//TODO 取出数据</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另一种就是一个独立的回调了：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者的区别是：onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的判断是否为空；但是onCreate不行，这两个方法都可以进行数据恢复，但是Google建议采用onRestoreInstanceState 去恢复数据。<br>  <br></p><h4 id="情况二：-资源内存不足导致低优先级的Activity被杀死"><a href="#情况二：-资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="情况二： 资源内存不足导致低优先级的Activity被杀死"></a><strong>情况二：</strong> 资源内存不足导致低优先级的Activity被杀死</h4><p>Activity 按照优先级从高到低，可以分为三种：<br>（1）前台Activity——正在和用户交互的Activity，优先级最高。<br>（2）可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。<br>（3）后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。</p><p>当系统内存不足时，系统就会按照上述优先级去杀死目标Activity所在的进程，并通过onSaveInstanState和onRestoreInstanceState 来存储和恢复数据。如果一个进程中没有四大组件在执行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件而独自运行在后台中，这样进程很容易被杀死。建议将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死了。</p><p><strong>NOTES</strong>：虽然内容很简单，但也是博主辛苦的做了下笔记，转载请注明出处！</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android TextView 实现文字间距</title>
      <link href="/2016/04/18/android-spacingtextview/"/>
      <url>/2016/04/18/android-spacingtextview/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p>Android系统中TextView默认显示中文时会比较紧凑，不是很美观。为了让每行保持一定的行间距，可以设置属性android:lineSpacingExtra或android:lineSpacingMultiplier。<br>但是有时候我们需要在TextView的文本之间有间距，两个字的话，我们可以在xml文件中，用敲空格的方式来实现，如果有很多文本或者是一个变量的文本呢。我们还这样用敲空格的方式来实现吗？oh no~！<br>如何实现行间距和文本间距呢？（请往下看 ↓）。</p><h4 id="1、设置TextView的行间距"><a href="#1、设置TextView的行间距" class="headerlink" title="1、设置TextView的行间距"></a>1、设置TextView的行间距</h4><p>在TextView控件中添加属性：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">android:</span>lineSpacingExtra=<span class="string">"13dp"</span>   <span class="comment">//设置行间距</span></span><br><span class="line"><span class="symbol">android:</span>lineSpacingMultiplier=<span class="string">"1.2"</span>  <span class="comment">//设置行间距的倍数。如”1.2”</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="2、设置TextView的文本间距"><a href="#2、设置TextView的文本间距" class="headerlink" title="2、设置TextView的文本间距"></a>2、设置TextView的文本间距</h4><ul><li><p>先看下效果图：<br><img src="http://img.blog.csdn.net/20160311173839446" alt="这里写图片描述"></p></li><li><p>自定义的TextView 的代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woyou.spacingtextview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.text.Spannable;</span><br><span class="line"><span class="keyword">import</span> android.text.SpannableString;</span><br><span class="line"><span class="keyword">import</span> android.text.style.ScaleXSpan;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiho on 2016/3/7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpacingTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> letterSpacing = LetterSpacing.BIGGEST;</span><br><span class="line">    <span class="keyword">private</span> CharSequence originalText = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpacingTextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpacingTextView</span><span class="params">(Context context, AttributeSet attrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        originalText = <span class="keyword">super</span>.getText();</span><br><span class="line">        applyLetterSpacing();</span><br><span class="line">        <span class="keyword">this</span>.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpacingTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getLetterSpacing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> letterSpacing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLetterSpacing</span><span class="params">(<span class="keyword">float</span> letterSpacing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.letterSpacing = letterSpacing;</span><br><span class="line">        applyLetterSpacing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(CharSequence text, BufferType type)</span> </span>&#123;</span><br><span class="line">        originalText = text;</span><br><span class="line">        applyLetterSpacing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字距为任何字符串（技术上，一个简单的方法为CharSequence不使用）的TextView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyLetterSpacing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="keyword">null</span> || <span class="keyword">this</span>.originalText == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; originalText.length(); i++) &#123;</span><br><span class="line">            String c = <span class="string">""</span>+ originalText.charAt(i);</span><br><span class="line">            builder.append(c.toLowerCase());</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; originalText.length()) &#123;</span><br><span class="line">                builder.append(<span class="string">"\u00A0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SpannableString finalText = <span class="keyword">new</span> SpannableString(builder.toString());</span><br><span class="line">        <span class="keyword">if</span>(builder.toString().length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; builder.toString().length(); i+=<span class="number">2</span>) &#123;</span><br><span class="line">                finalText.setSpan(<span class="keyword">new</span> ScaleXSpan((letterSpacing+<span class="number">1</span>)/<span class="number">10</span>), i, i+<span class="number">1</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.setText(finalText, BufferType.SPANNABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterSpacing</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">float</span> NORMAL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">float</span> NORMALBIG = (<span class="keyword">float</span>)<span class="number">0.025</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">float</span> BIG = (<span class="keyword">float</span>)<span class="number">0.05</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">float</span> BIGGEST = (<span class="keyword">float</span>)<span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在activity 中使用：</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SpacingTextView mSpacingTextView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mSpacingTextView = (SpacingTextView) findViewById(R.id.space_text);</span><br><span class="line">        mSpacingTextView.setText(getResources().getString(R.string.test));</span><br><span class="line">        <span class="comment">//Or any float. To reset to normal, use 0 or LetterSpacingTextView.Spacing.NORMAL</span></span><br><span class="line">        mSpacingTextView.setLetterSpacing(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>xml 文件如下：</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingLeft=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingRight=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    app:layout_behavior=<span class="string">"@string/appbar_scrolling_view_behavior"</span></span><br><span class="line">    tools:context=<span class="string">"com.woyou.spacingtextview.MainActivity"</span></span><br><span class="line">    tools:showIn=<span class="string">"@layout/activity_main"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.woyou.spacingtextview.SpacingTextView</span><br><span class="line">        android:id=<span class="string">"@+id/space_text"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:lineSpacingExtra=<span class="string">"13dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:text=<span class="string">"@string/test"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/RelativeLayout&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码使用起来很方便，添加到自己的项目中看下效果。</p><p>TextView控件以开源：<a href="https://github.com/git-xuhao/SpacingTextView" target="_blank" rel="noopener">SpacingTextView</a><br>如果你想实现TextView的 文本对齐；请参考开源项目：<a href="https://github.com/androiddevelop/AlignTextView" target="_blank" rel="noopener">AlignTextView</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> TextView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中线程池的分析</title>
      <link href="/2016/04/15/Android%20%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2016/04/15/Android%20%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><strong>介绍new Thread的弊端及Java四种线程池的使用，对Android同样适用。</strong></p><h3 id="1、new-Thread的弊端"><a href="#1、new-Thread的弊端" class="headerlink" title="1、new Thread的弊端"></a><strong>1、new Thread的弊端</strong></h3><p>执行一个异步任务你还只是如下new Thread吗？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>那你就out太多了，new Thread的弊端如下：</strong></p><p>a. 每次new Thread新建对象性能差。<br>b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。<br>c. 缺乏更多功能，如定时执行、定期执行、线程中断。</p><p><strong>相比new Thread，Java提供的四种线程池的好处在于：</strong></p><p>a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。<br>b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br>c. 提供定时执行、定期执行、单线程、并发数控制等功能。</p><h3 id="2、Java-线程池"><a href="#2、Java-线程池" class="headerlink" title="2、Java 线程池"></a><strong>2、Java 线程池</strong></h3><p>Java通过Executors提供四种线程池，分别为：</p><ul><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h3 id="1-newCachedThreadPool："><a href="#1-newCachedThreadPool：" class="headerlink" title="(1)newCachedThreadPool："></a><strong>(1)newCachedThreadPool：</strong></h3><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">index</span> = i;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="keyword">index</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">    System.out.println(<span class="keyword">index</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><h3 id="2-newFixedThreadPool："><a href="#2-newFixedThreadPool：" class="headerlink" title="(2)newFixedThreadPool："></a><strong>(2)newFixedThreadPool：</strong></h3><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"></span><br><span class="line">    fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。</p><p>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p><h3 id="3-newScheduledThreadPool："><a href="#3-newScheduledThreadPool：" class="headerlink" title="(3)newScheduledThreadPool："></a><strong>(3)newScheduledThreadPool：</strong></h3><p>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ScheduledExecutorService </span><span class="keyword">scheduledThreadPool </span>= Executors.newScheduledThreadPool(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line"> <span class="keyword">scheduledThreadPool.schedule(new </span>Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    System.out.println(<span class="string">"delay 3 seconds"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>表示延迟3秒执行。</p><p>定期执行示例代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>表示延迟1秒后每3秒执行一次。</p><p>ScheduledExecutorService比Timer更安全，功能更强大</p><h3 id="4-newSingleThreadExecutor："><a href="#4-newSingleThreadExecutor：" class="headerlink" title="(4)newSingleThreadExecutor："></a><strong>(4)newSingleThreadExecutor：</strong></h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果依次输出，相当于顺序执行各个任务。</p><p>现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p><h3 id="线程池的作用："><a href="#线程池的作用：" class="headerlink" title="线程池的作用："></a><strong>线程池的作用：</strong></h3><p>线程池作用就是限制系统中执行线程的数量。<br>     根 据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池:"></a><strong>为什么要用线程池:</strong></h3><p>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><p>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p><p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p><p><strong>比较重要的几个类：</strong></p><p>ExecutorService：               真正的线程池接口。</p><p>ScheduledExecutorService：      能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</p><p>ThreadPoolExecutor：            ExecutorService的默认实现。</p><p>ScheduledThreadPoolExecutor：   继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p><h3 id="1-newSingleThreadExecutor"><a href="#1-newSingleThreadExecutor" class="headerlink" title="1.newSingleThreadExecutor"></a><strong>1.newSingleThreadExecutor</strong></h3><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><h3 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2.newFixedThreadPool"></a><strong>2.newFixedThreadPool</strong></h3><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><h3 id="3-newCachedThreadPool"><a href="#3-newCachedThreadPool" class="headerlink" title="3.newCachedThreadPool"></a><strong>3.newCachedThreadPool</strong></h3><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，</p><p>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><h3 id="4-newScheduledThreadPool"><a href="#4-newScheduledThreadPool" class="headerlink" title="4.newScheduledThreadPool"></a><strong>4.newScheduledThreadPool</strong></h3><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a><strong>实例代码</strong></h3><h3 id="一、固定大小的线程池，newFixedThreadPool："><a href="#一、固定大小的线程池，newFixedThreadPool：" class="headerlink" title="一、固定大小的线程池，newFixedThreadPool："></a><strong>一、固定大小的线程池，newFixedThreadPool：</strong></h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> app.executors;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Java线程：线程池 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * @author xiho</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;  </span><br><span class="line">        <span class="comment">// 创建一个可重用固定线程数的线程池  </span></span><br><span class="line">        ExecutorService pool = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">2</span>);  </span><br><span class="line">        <span class="comment">// 创建线程  </span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="type">MyThread</span>();  </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="type">MyThread</span>();  </span><br><span class="line">        Thread t3 = <span class="keyword">new</span> <span class="type">MyThread</span>();  </span><br><span class="line">        Thread t4 = <span class="keyword">new</span> <span class="type">MyThread</span>();  </span><br><span class="line">        Thread t5 = <span class="keyword">new</span> <span class="type">MyThread</span>();  </span><br><span class="line">        <span class="comment">// 将线程放入池中进行执行  </span></span><br><span class="line">        pool.execute(t1);  </span><br><span class="line">        pool.execute(t2);  </span><br><span class="line">        pool.execute(t3);  </span><br><span class="line">        pool.execute(t4);  </span><br><span class="line">        pool.execute(t5);  </span><br><span class="line">        <span class="comment">// 关闭线程池  </span></span><br><span class="line">        pool.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Thread</span></span> </span>&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    <span class="keyword">public</span> void run() &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-3</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-4</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-2</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-5</span>正在执行。。。</span><br></pre></td></tr></table></figure><p>改变ExecutorService pool = Executors.newFixedThreadPool(5)中的参数：ExecutorService pool = Executors.newFixedThreadPool(2)，输出结果是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-2</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-2</span>正在执行。。。</span><br></pre></td></tr></table></figure><p>从以上结果可以看出，newFixedThreadPool的参数指定了可以运行的线程的最大数目，超过这个数目的线程加进去以后，不会运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。</p><h3 id="二、单任务线程池，newSingleThreadExecutor："><a href="#二、单任务线程池，newSingleThreadExecutor：" class="headerlink" title="二、单任务线程池，newSingleThreadExecutor："></a><strong>二、单任务线程池，newSingleThreadExecutor：</strong></h3><p>仅仅是把上述代码中的ExecutorService pool = Executors.newFixedThreadPool(2)改为ExecutorService pool = Executors.newSingleThreadExecutor();<br><strong>输出结果：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。</span><br></pre></td></tr></table></figure><p>可以看出，每次调用execute方法，其实最后都是调用了thread-1的run方法。</p><h3 id="三、可变尺寸的线程池，newCachedThreadPool："><a href="#三、可变尺寸的线程池，newCachedThreadPool：" class="headerlink" title="三、可变尺寸的线程池，newCachedThreadPool："></a><strong>三、可变尺寸的线程池，newCachedThreadPool：</strong></h3><p>与上面的类似，只是改动下pool的创建方式：ExecutorService pool = Executors.newCachedThreadPool();</p><p><strong>输出结果：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool<span class="number">-1</span>-thread<span class="number">-1</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-2</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-4</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-3</span>正在执行。。。  </span><br><span class="line">pool<span class="number">-1</span>-thread<span class="number">-5</span>正在执行。。。</span><br></pre></td></tr></table></figure><p>这种方式的特点是：可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p><h3 id="四、延迟连接池，newScheduledThreadPool："><a href="#四、延迟连接池，newScheduledThreadPool：" class="headerlink" title="四、延迟连接池，newScheduledThreadPool："></a><strong>四、延迟连接池，newScheduledThreadPool：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduledThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ScheduledThreadPoolExecutor exec = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//每隔一段时间就触发异常</span></span><br><span class="line"></span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">                      <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">//throw new RuntimeException();</span></span><br><span class="line"></span><br><span class="line">                           System.out.println(<span class="string">"================"</span>);</span><br><span class="line"></span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125;, <span class="number">1000</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//每隔一段时间打印系统时间，证明两者是互不影响的</span></span><br><span class="line"></span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">                      <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                           System.out.println(System.nanoTime());</span><br><span class="line"></span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                  &#125;, <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="number">8384644549516</span></span><br><span class="line"></span><br><span class="line"><span class="number">8386643829034</span></span><br><span class="line"></span><br><span class="line"><span class="number">8388643830710</span></span><br><span class="line"></span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"><span class="number">8390643851383</span></span><br><span class="line"></span><br><span class="line"><span class="number">8392643879319</span></span><br><span class="line"></span><br><span class="line"><span class="number">8400643939383</span></span><br></pre></td></tr></table></figure></p><blockquote><p>转载请标注原地址：<a href="http://blog.csdn.net/u011974987/article/details/51027795" target="_blank" rel="noopener">http://blog.csdn.net/u011974987/article/details/51027795</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 线程池 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 网络请求库Retrofit简单使用</title>
      <link href="/2016/04/12/android-retrofit/"/>
      <url>/2016/04/12/android-retrofit/</url>
      <content type="html"><![CDATA[<h2 id="什么是-Retrofit"><a href="#什么是-Retrofit" class="headerlink" title="什么是 Retrofit ?"></a><strong>什么是 Retrofit ?</strong></h2><p>Retrofit是一套 RESTful 架构的 Android（Java）客户端实现，基于注解，提供 JSON to POJO（Plain Ordinary Java Object ，简单Java对象），POJO to JSON，网络请求（POST，GET， PUT，DELETE 等）封装。</p><a id="more"></a><p>既然只是一个网络请求封装库，现在已经有了那么多的大家已经耳熟能详的网络请求封装库了，为什么还要介绍它呢，原因在于 Retrofit 是一套注解形的网络请求封装库，让我们的代码结构更给为清晰。它可以直接解析JSON数据变成JAVA对象，甚至支持回调操作，处理不同的结果。<br>想更详细的了解 Retrofit，可以查看<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">官方文档</a> 。</p><p>话不多说，直入主题~~</p><h3 id="一、集成"><a href="#一、集成" class="headerlink" title="一、集成"></a><strong>一、集成</strong></h3><p>目前我使用的是AndroidStudio,那么在model的build.gradle文件中添加以下引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.okhttp3:okhttp:3.2.0'</span> </span><br><span class="line">compile <span class="string">'com.squareup.retrofit2:retrofit:2.0.0-beta4'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit2:converter-gson:2.0.0-beta3'</span></span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong></p><p>Retrofit依赖于okhttp，所以需要集成okhttp<br>API返回的数据为JSON格式，在此我使用的是Gson对返回数据解析.<strong>请使用最新版的Gson</strong></p><h3 id="二、返回的数据格式"><a href="#二、返回的数据格式" class="headerlink" title="二、返回的数据格式"></a><strong>二、返回的数据格式</strong></h3><p>使用的是百度API的数据接口：<a href="http://apistore.baidu.com/apiworks/servicedetail/1756.html" target="_blank" rel="noopener">名人名言API</a><br><img src="http://img.blog.csdn.net/20160408133309596" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160408133322319" alt="这里写图片描述"></p><p>该接口的API主机地址为：<a href="http://apistore.baidu.com；" target="_blank" rel="noopener">http://apistore.baidu.com；</a><br>需要访问的接口：avatardata/mingrenmingyan/lookup；</p><p>需要一个key等于apikey的Header和一个keyword等于<strong>名人名言</strong>的查询关键字,而且该请求为<strong>GET</strong>请求.</p><p>访问该API返回的数据格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"total"</span>: <span class="number">914</span>,</span><br><span class="line">    <span class="string">"result"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"famous_name"</span>: <span class="string">"布兰登"</span>,</span><br><span class="line">            <span class="string">"famous_saying"</span>: <span class="string">"人生至善，就是对生活乐观，对工作愉快，对事业兴奋。"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"famous_name"</span>: <span class="string">"魏书生"</span>,</span><br><span class="line">            <span class="string">"famous_saying"</span>: <span class="string">"抽打自己的鞭子要掌握在自己的手里，在漫长的人生道路的每一步上，都要经常鞭策自警，万不可以为有过一两次抽打就可以沿途平安了。"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"famous_name"</span>: <span class="string">"亨·易卜生"</span>,</span><br><span class="line">            <span class="string">"famous_saying"</span>: <span class="string">"夺走了普通人生活的幻想，也就等于夺去了他的幸福"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"famous_name"</span>: <span class="string">"佚名"</span>,</span><br><span class="line">            <span class="string">"famous_saying"</span>: <span class="string">"不知道自己走向何方的人，大都是人生的匆匆过客。"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"famous_name"</span>: <span class="string">"南丁格尔"</span>,</span><br><span class="line">            <span class="string">"famous_saying"</span>: <span class="string">"人生欲求安全，当有五要。一是清洁空气，二是澄清饮水，三是流通沟渠，四是扫洒屋宇，五是日光充足。"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"error_code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"reason"</span>: <span class="string">"Succes"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、AndroidStudio插件-GsonFormat"><a href="#三、AndroidStudio插件-GsonFormat" class="headerlink" title="三、AndroidStudio插件 GsonFormat"></a><strong>三、AndroidStudio插件<a href="https://plugins.jetbrains.com/plugin/7654?pr=androidstudio" target="_blank" rel="noopener"> GsonFormat</a></strong></h3><p>我们根据上面API返回的json数据来创建一个FamousInfo数据对象，我们可以利用AndroidStudio插件<a href="https://plugins.jetbrains.com/plugin/7654?pr=androidstudio" target="_blank" rel="noopener"> GsonFormat</a> 快速，方便的将json数据转为Java 对象，<br>FamousInfo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woyou.androidsample.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Xiho on 2016/3/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamousInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * total : 227</span></span><br><span class="line"><span class="comment">     * result : [&#123;"famous_name":"车尔尼雪夫斯基","famous_saying":"非凡的单纯，非凡的明确\u2014\u2014这是天才的智慧的最可惊人的品质。"&#125;,&#123;"famous_name":"约·德莱顿","famous_saying":"天才在社会生活中往往显得迟钝而"&#125;,&#123;"famous_name":"雨果","famous_saying":"敢于冲撞命运才是天才"&#125;,&#123;"famous_name":"卡莱尔","famous_saying":"所谓天才，就是比任何人都先抵挡痛苦的经验本领。"&#125;,&#123;"famous_name":"林肯","famous_saying":"卓越的天才不屑走一条人家走过的路。他寻找迄今没有开拓过的地区。"&#125;,&#123;"famous_name":"席勒","famous_saying":"产生天才的土壤比天才还要难找"&#125;,&#123;"famous_name":"爱因斯坦","famous_saying":"任何天才不能在孤独的状态中发展"&#125;,&#123;"famous_name":"民谚","famous_saying":"名人的古怪行为是天才的标志，凡人的古怪行为是神经出了毛病"&#125;,&#123;"famous_name":"鲁迅","famous_saying":"哪里有天才，我是把别人喝咖啡的工夫都用在了工作上了。"&#125;,&#123;"famous_name":"塞涅夫","famous_saying":"没有某些发狂的劲头，就没有天才。"&#125;,&#123;"famous_name":"狄德罗","famous_saying":"精神的浩瀚想象的活跃心灵的勤奋：就是天才。"&#125;,&#123;"famous_name":"爱默生","famous_saying":"平凡的人希望，天才的人创造。"&#125;,&#123;"famous_name":"契诃夫","famous_saying":"真正的天才是常常隐藏在群众里面，绝不挤向人前去露脸的。"&#125;,&#123;"famous_name":"别林斯基","famous_saying":"任何天才，不经过艰苦不断的劳动，不经过最使空想家头疼和懊恼的最初纯物质和机械的劳动，就无法精通任何种类的艺术。"&#125;,&#123;"famous_name":"杨格","famous_saying":"我愿意以天才比美德，以学问比财富。如美德越少的人，越需要财富，天才越低的人，越需要学问。"&#125;,&#123;"famous_name":"巴尔扎克","famous_saying":"职业尽管不同，但天才的品德并无分别。"&#125;,&#123;"famous_name":"恩格斯","famous_saying":"逆境使天才脱颖而出，顺境会埋没"&#125;,&#123;"famous_name":"巴尔扎克","famous_saying":"破坏的人和建设的人，两者都是意志的现象：一个是准备工作，另一个是完成工作；前者好像是一个恶的天才，后者似乎是一个善的天才；对这一个给予光荣，对另一个给予忘却。恶者哇啦哇啦，把庸俗的人们从梦里惊醒，对他佩服得五体投地，可是善者却一直默不作声。"&#125;,&#123;"famous_name":"培根","famous_saying":"如果孩子确有某种超群的天才，那当然应该扶植发展。但就一般情况说，下面这句格言很有用的：\u201c长期的训练会通过适应化难为易。\u201d"&#125;,&#123;"famous_name":"爱迪生","famous_saying":"天才是百分之一的灵感，百分之九十九的血汗。"&#125;]</span></span><br><span class="line"><span class="comment">     * error_code : 0</span></span><br><span class="line"><span class="comment">     * reason : Succes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> error_code;</span><br><span class="line">    <span class="keyword">private</span> String reason;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * famous_name : 车尔尼雪夫斯基</span></span><br><span class="line"><span class="comment">     * famous_saying : 非凡的单纯，非凡的明确——这是天才的智慧的最可惊人的品质。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultEntity&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError_code</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.error_code = error_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReason</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(List&lt;ResultEntity&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getError_code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error_code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ResultEntity&gt; <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultEntity</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String famous_name;</span><br><span class="line">        <span class="keyword">private</span> String famous_saying;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFamous_name</span><span class="params">(String famous_name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.famous_name = famous_name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFamous_saying</span><span class="params">(String famous_saying)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.famous_saying = famous_saying;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getFamous_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> famous_name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getFamous_saying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> famous_saying;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、实现过程"><a href="#四、实现过程" class="headerlink" title="四、实现过程"></a><strong>四、实现过程</strong></h3><p>首先， 按照官方的说明，我们需要创建一个接口，返回 Call<famousinfo>；如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"/avatardata/mingrenmingyan/lookup"</span>)</span><br><span class="line">    <span class="function">Call&lt;FamousInfo&gt; <span class="title">getFamousResult</span><span class="params">(@Header(<span class="string">"apiKey"</span>)</span> String apiKey,</span></span><br><span class="line"><span class="function">                                     @<span class="title">Query</span><span class="params">(<span class="string">"keyword"</span>)</span> String keyword,</span></span><br><span class="line"><span class="function">                                     @<span class="title">Query</span><span class="params">(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page,</span></span><br><span class="line"><span class="function">                                     @<span class="title">Query</span><span class="params">(<span class="string">"rows"</span>)</span> <span class="keyword">int</span> rows)</span>;</span><br></pre></td></tr></table></figure></famousinfo></p><p>这里我们使用的是Retrofit 提供注解的方式来定义接口的</p><ul><li>@get后面我们填写需要访问对应的接口地址</li><li>@Header用来添加Header</li><li>@Query用来添加查询关键字</li></ul><p>现在接口定义好了，我们来<strong> 定义Retrofit 网络接口服务的包装类 </strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.woyou.androidsample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> retrofit2.GsonConverterFactory;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrofit 网络接口服务的包装类</span></span><br><span class="line"><span class="comment"> * Created by Xiho on 2016/3/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RetrofitWrapper instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> Retrofit retrofit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RetrofitWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//1.创建Retrofit对象</span></span><br><span class="line">        retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(Constant.BASEURL) <span class="comment">// 定义访问的主机地址</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())  <span class="comment">//解析方法</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RetrofitWrapper <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RetrofitWrapper.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> RetrofitWrapper();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.create(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">   * Created by Xiho on 2016/3/14. </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constant</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> String BASEURL=<span class="string">"http://apis.baidu.com"</span>; <span class="comment">//服务器地址   </span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> String APIKEY=<span class="string">"4c4f0c3c49e09d5578ae0ba49fa84a97"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网络服务的包装类定义好了之后，在定义一个访问的Model（个人编码风格，其实可以更简洁点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamousInfoModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FamousInfoModel famousInfoModel;</span><br><span class="line">    <span class="keyword">private</span> FamousService mFamousService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FamousInfoModel <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (famousInfoModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            famousInfoModel = <span class="keyword">new</span> FamousInfoModel(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> famousInfoModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FamousInfoModel</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mFamousService = (FamousService) RetrofitWrapper.getInstance().create(FamousService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询名人名言</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> famousInfoReq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Call&lt;FamousInfo&gt; <span class="title">queryLookUp</span><span class="params">(FamousInfoReq famousInfoReq)</span> </span>&#123;</span><br><span class="line">        Call&lt;FamousInfo&gt; infoCall = mFamousService.getFamousResult(famousInfoReq.apiKey, famousInfoReq.keyword, famousInfoReq.page, famousInfoReq.rows);</span><br><span class="line">        <span class="keyword">return</span> infoCall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、如何使用"><a href="#五、如何使用" class="headerlink" title="五、如何使用"></a><strong>五、如何使用</strong></h3><p>构建好接口以后,可以使用了!</p><p>使用分为四步:</p><ul><li>创建Retrofit对象</li><li>创建访问API的请求</li><li>发送请求</li><li>处理结果<br>主要代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FamousInfoModel famousInfoModel =FamousInfoModel.getInstance(getApplicationContext());</span><br><span class="line"><span class="comment">// 获取事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSerachBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//创建访问的API请求</span></span><br><span class="line">                Call&lt;FamousInfo&gt; callFamous= famousInfoModel.queryLookUp(initParams());</span><br><span class="line">                <span class="comment">//发送请求</span></span><br><span class="line">                callFamous.enqueue(<span class="keyword">new</span> Callback&lt;FamousInfo&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;FamousInfo&gt; call, Response&lt;FamousInfo&gt; response)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(response.isSuccess())&#123;</span><br><span class="line">                            FamousInfo result = response.body();</span><br><span class="line">                            <span class="keyword">if</span>(result!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                                List&lt;FamousInfo.ResultEntity&gt; entity = result.getResult();</span><br><span class="line">                                    mTxtContent.setText(<span class="string">"1、"</span>+entity.get(<span class="number">0</span>).getFamous_saying()+<span class="string">"\n---"</span>+entity.get(<span class="number">0</span>).getFamous_name()+<span class="string">"\n 2、"</span></span><br><span class="line">                                            +entity.get(<span class="number">1</span>).getFamous_saying()+<span class="string">"\n---"</span>+entity.get(<span class="number">1</span>).getFamous_name());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;FamousInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后运行的效果图如下：</p><p><img src="http://img.blog.csdn.net/20160408133246502" alt="这里写图片描述"></p><p><strong> 搜索的结果我只是显示了其中一部分，只用来使用Retrofit 这个框架，没有很具体去做一些处理啦，后面还会用一些其他的库，还会使用本Demo 来进行测试，所以这次就简单写了下。</strong>   <br><br>附上源码：<a href="http://download.csdn.net/download/u011974987/9461917" target="_blank" rel="noopener">AndroidRetrofitSample</a>   <br></p><h3 id="六、扩展阅读"><a href="#六、扩展阅读" class="headerlink" title="六、扩展阅读"></a><strong>六、扩展阅读</strong></h3><p><strong> Retrofit:</strong> </p><ul><li>Retrofit 官方文档：<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">http://square.github.io/retrofit/</a></li><li>Retrofit 使用介绍：<a href="http://www.cnblogs.com/angeldevil/p/3757335.html" target="_blank" rel="noopener">http://www.cnblogs.com/angeldevil/p/3757335.html</a></li><li>Retrofit 离线缓存策略：<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0115/3873.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0115/3873.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 切换系统语言源码分析（上）</title>
      <link href="/2016/04/12/android-change-language_01/"/>
      <url>/2016/04/12/android-change-language_01/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p>以前了解Android的多语言实现很简单，可以在不同的语言环境下使用不同的资源，就做好相应的语言适配就好，但是一直没有实际使用过。 最近公司的项目要用到多国语言切换，并且还是和手机上系统设置里面的语言切换功能一样，于是就上网查了下资料。一般都是在应用类实现多国语言切换，这个是很简单。而我想切换整个系统的语言。由于谷歌没有把系统设置里面的接口给开放出来，所以就只好去查看它的源码了~<br><a id="more"></a></p><ul><li>android语言切换是在：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packages<span class="regexp">/apps/</span>Settings<span class="regexp">/com/</span>android<span class="regexp">/settings/</span>LocalePicker.java</span><br></pre></td></tr></table></figure><p>的updateLocale()函数中调用，<br>源码如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Requests the system to update the system locale. Note that the system looks halted  for a while during the Locale migration, so the caller need to take care of it. </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> updateLocale(Locale locale) &#123;  </span><br><span class="line">        <span class="built_in">try</span> &#123;  </span><br><span class="line">            IActivityManager am = ActivityManagerNative.getDefault();  </span><br><span class="line">            Configuration <span class="built_in">config</span> = am.getConfiguration();  </span><br><span class="line">  </span><br><span class="line">            <span class="built_in">config</span>.locale = locale;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// indicate this isn't some passing default - the user wants this remembered  </span></span><br><span class="line">            <span class="built_in">config</span>.userSetLocale = true;  </span><br><span class="line">  </span><br><span class="line">            am.updateConfiguration(<span class="built_in">config</span>);  </span><br><span class="line">            <span class="comment">// Trigger the dirty bit for the Settings Provider.  </span></span><br><span class="line">            BackupManager.dataChanged(<span class="string">"com.android.providers.settings"</span>);  </span><br><span class="line">        &#125; <span class="built_in">catch</span> (RemoteException e) &#123;  </span><br><span class="line">            <span class="comment">// Intentionally left blank  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>从注释可以看出, 只要本地local改变就会调用该函数. 查看ActivityManagerNative的getDefault()可以看到, 该函数返回的是远程服务对象ActivityManagerServices.java在本地的一个代理.  最终调用的是ActivityManagerService.java中的updateConfiguration()函数. </li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">updateConfiguration</span><span class="params">(Configuration values)</span> </span>&#123;  </span><br><span class="line">        enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,  </span><br><span class="line">                <span class="string">"updateConfiguration()"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (values == <span class="keyword">null</span> &amp;&amp; mWindowManager != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// sentinel: fetch the current configuration from the window manager  </span></span><br><span class="line">                values = mWindowManager.computeNewConfiguration();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (mWindowManager != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                mProcessList.applyDisplaySize(mWindowManager);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();  </span><br><span class="line">            <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                Settings.System.clearConfiguration(values);  </span><br><span class="line">            &#125;  </span><br><span class="line">            updateConfigurationLocked(values, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);  </span><br><span class="line">            Binder.restoreCallingIdentity(origId);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>该函数, 首先进行的是权限的校验. 然后调用updateConfigurationLocked()函数. </li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Do either or both things: (1) change the current configuration, and (2) </span></span><br><span class="line"><span class="comment">     * make sure the given activity is running with the (now) current </span></span><br><span class="line"><span class="comment">     * configuration.  Returns true if the activity has been left running, or </span></span><br><span class="line"><span class="comment">     * false if &lt;var&gt;starting&lt;/var&gt; is being destroyed to match the new </span></span><br><span class="line"><span class="comment">     * configuration. </span></span><br><span class="line"><span class="comment">     * @param persistent TODO </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> boolean updateConfigurationLocked(Configuration values,  </span><br><span class="line">            ActivityRecord starting, boolean persistent, boolean initLocale) &#123;  </span><br><span class="line">        int changes = <span class="number">0</span>;  </span><br><span class="line">          </span><br><span class="line">        boolean kept = <span class="literal">true</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;  </span><br><span class="line">            Configuration <span class="keyword">new</span><span class="type">Config</span> = <span class="keyword">new</span> <span class="type">Configuration</span>(mConfiguration);  </span><br><span class="line">            changes = <span class="keyword">new</span><span class="type">Config</span>.updateFrom(values);  </span><br><span class="line">            <span class="keyword">if</span> (changes != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_CONFIGURATION) &#123;  </span><br><span class="line">                    Slog.i(TAG, <span class="string">"Updating configuration to: "</span> + values);  </span><br><span class="line">                &#125;  </span><br><span class="line">                  </span><br><span class="line">                EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes);  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (values.locale != <span class="literal">null</span> &amp;&amp; !initLocale) &#123;  </span><br><span class="line">                    saveLocaleLocked(values.locale,   </span><br><span class="line">                                     !values.locale.equals(mConfiguration.locale),  </span><br><span class="line">                                     values.userSetLocale, values.simSetLocale);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                  </span><br><span class="line">                mConfigurationSeq++;  </span><br><span class="line">                <span class="keyword">if</span> (mConfigurationSeq &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                    mConfigurationSeq = <span class="number">1</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">new</span><span class="type">Config</span>.seq = mConfigurationSeq;  </span><br><span class="line">                mConfiguration = <span class="keyword">new</span><span class="type">Config</span>;  </span><br><span class="line">                Slog.i(TAG, <span class="string">"Config changed: "</span> + <span class="keyword">new</span><span class="type">Config</span>);  </span><br><span class="line">  </span><br><span class="line">                final Configuration configCopy = <span class="keyword">new</span> <span class="type">Configuration</span>(mConfiguration);  </span><br><span class="line">  </span><br><span class="line">                AttributeCache ac = AttributeCache.instance();  </span><br><span class="line">                <span class="keyword">if</span> (ac != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    ac.updateConfiguration(configCopy);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// Make sure all resources in our process are updated  </span></span><br><span class="line">                <span class="comment">// right now, so that anyone who is going to retrieve  </span></span><br><span class="line">                <span class="comment">// resource values after we return will be sure to get  </span></span><br><span class="line">                <span class="comment">// the new ones.  This is especially important during  </span></span><br><span class="line">                <span class="comment">// boot, where the first config change needs to guarantee  </span></span><br><span class="line">                <span class="comment">// all resources have that config before following boot  </span></span><br><span class="line">                <span class="comment">// code is executed.  </span></span><br><span class="line">                mSystemThread.applyConfigurationToResources(configCopy);  </span><br><span class="line">  </span><br><span class="line">                <span class="keyword">if</span> (persistent &amp;&amp; Settings.System.hasInterestingConfigurationChanges(changes)) &#123;  </span><br><span class="line">                    Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG);  </span><br><span class="line">                    msg.obj = <span class="keyword">new</span> <span class="type">Configuration</span>(configCopy);  </span><br><span class="line">                    mHandler.sendMessage(msg);  </span><br><span class="line">                &#125;  </span><br><span class="line">          </span><br><span class="line">                <span class="keyword">for</span> (int i=mLruProcesses.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;  </span><br><span class="line">                    ProcessRecord app = mLruProcesses.<span class="keyword">get</span>(i);  </span><br><span class="line">                    <span class="keyword">try</span> &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (app.thread != <span class="literal">null</span>) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Sending to proc "</span>  </span><br><span class="line">                                    + app.processName + <span class="string">" new config "</span> + mConfiguration);  </span><br><span class="line">                            app.thread.scheduleConfigurationChanged(configCopy);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                Intent intent = <span class="keyword">new</span> <span class="type">Intent</span>(Intent.ACTION_CONFIGURATION_CHANGED);  </span><br><span class="line">                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY  </span><br><span class="line">                        | Intent.FLAG_RECEIVER_REPLACE_PENDING);  </span><br><span class="line">                broadcastIntentLocked(<span class="literal">null</span>, <span class="literal">null</span>, intent, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>,  </span><br><span class="line">                        <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>, MY_PID, Process.SYSTEM_UID);  </span><br><span class="line">                <span class="keyword">if</span> ((changes&amp;ActivityInfo.CONFIG_LOCALE) != <span class="number">0</span>) &#123;  </span><br><span class="line">                    broadcastIntentLocked(<span class="literal">null</span>, <span class="literal">null</span>,  </span><br><span class="line">                            <span class="keyword">new</span> <span class="type">Intent</span>(Intent.ACTION_LOCALE_CHANGED),  </span><br><span class="line">                            <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>,  </span><br><span class="line">                            <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>, MY_PID, Process.SYSTEM_UID);  </span><br><span class="line">                &#125;  </span><br><span class="line">                  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (changes != <span class="number">0</span> &amp;&amp; starting == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// If the configuration changed, and the caller is not already  </span></span><br><span class="line">            <span class="comment">// in the process of starting an activity, then find the top  </span></span><br><span class="line">            <span class="comment">// activity to check if its configuration needs to change.  </span></span><br><span class="line">            starting = mMainStack.topRunningActivityLocked(<span class="literal">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (starting != <span class="literal">null</span>) &#123;  </span><br><span class="line">            kept = mMainStack.ensureActivityConfigurationLocked(starting, changes);  </span><br><span class="line">            <span class="comment">// And we need to make sure at this point that all other activities  </span></span><br><span class="line">            <span class="comment">// are made visible with the correct configuration.  </span></span><br><span class="line">            mMainStack.ensureActivitiesVisibleLocked(starting, changes);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (values != <span class="literal">null</span> &amp;&amp; mWindowManager != <span class="literal">null</span>) &#123;  </span><br><span class="line">            mWindowManager.setNewConfiguration(mConfiguration);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> kept;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>整个语言切换就在这个函数中完成. 咋一看似乎没感觉到该函数做了哪些事情. 我们首先来看注释: Do either or both things: (1) change the current configuration, and (2)<br>make sure the given activity is running with the (now) current. configuration大概意思是: 这个函数做了两件事情. (1). 改变当前的configuration. 意思就是让改变的configuration更新到当前configuration. (2) 确保所有正在运行的activity都能更新改变后的configuration.(这点是关键.) . 我们按照这个思路看看android是如何更新configuration. 查看代码 , 首先看到 这个函数首先判断values是否为空, 这里values肯定不为空的, 然后changes = newConfig.updateFrom(values); 我们看看updateFrom做了什么操作。</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Copy the fields from delta into this Configuration object, keeping </span></span><br><span class="line"><span class="comment">     * track of which ones have changed.  Any undefined fields in </span></span><br><span class="line"><span class="comment">     * &lt;var&gt;delta&lt;/var&gt; are ignored and not copied in to the current </span></span><br><span class="line"><span class="comment">     * Configuration. </span></span><br><span class="line"><span class="comment">     * @return Returns a bit mask of the changed fields, as per </span></span><br><span class="line"><span class="comment">     * &#123;@link #diff&#125;. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> int updateFrom(Configuration delta) &#123;  </span><br><span class="line">        int changed = <span class="number">0</span>;  </span><br><span class="line">        <span class="params">...</span>  </span><br><span class="line">        <span class="keyword">if</span> (delta.<span class="built_in">locale</span> != <span class="built_in">null</span>   &amp;&amp; (<span class="built_in">locale</span> == <span class="built_in">null</span> || !<span class="built_in">locale</span>.<span class="keyword">equals</span>(delta.<span class="built_in">locale</span>))) &#123;  </span><br><span class="line">            changed |= ActivityInfo.CONFIG_LOCALE;  </span><br><span class="line">            <span class="built_in">locale</span> = delta.<span class="built_in">locale</span> != <span class="built_in">null</span>   ? (<span class="built_in">Locale</span>) delta.<span class="built_in">locale</span>.clone() : <span class="built_in">null</span>;  </span><br><span class="line">            textLayoutDirection = LocaleUtil.getLayoutDirectionFromLocale(<span class="built_in">locale</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (delta.userSetLocale &amp;&amp; (!userSetLocale || ((changed &amp; ActivityInfo.CONFIG_LOCALE) != <span class="number">0</span>)))  </span><br><span class="line">        &#123;  </span><br><span class="line">            userSetLocale = <span class="literal">true</span>;  </span><br><span class="line">            changed |= ActivityInfo.CONFIG_LOCALE;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="params">...</span>  </span><br><span class="line">        <span class="keyword">return</span> changed;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>因为语言改变了, 那么 (!locale.equals(delta.locale)) 是true. changed 大于0, 然后return changed. 回到ActivityManagerService.java的updateConfigurationLocked函数, 因为changed不为0 , 所以走if这个流程.  继续看代码。</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">int</span> i=mLruProcesses.size()<span class="number">-1</span><span class="comment">; i&gt;=0; i--) &#123;  </span></span><br><span class="line">                  ProcessRecord app = mLruProcesses.get(<span class="name">i</span>)<span class="comment">;  </span></span><br><span class="line">                  try &#123;  </span><br><span class="line">                      if (<span class="name">app</span>.thread != null) &#123;  </span><br><span class="line">                          if (<span class="name">DEBUG_CONFIGURATION</span>) Slog.v(<span class="name">TAG</span>, <span class="string">"Sending to proc "</span>  </span><br><span class="line">                                  + app.processName + <span class="string">" new config "</span> + mConfiguration)<span class="comment">;  </span></span><br><span class="line">                          app.thread.scheduleConfigurationChanged(<span class="name">configCopy</span>)<span class="comment">;  </span></span><br><span class="line">                      &#125;  </span><br><span class="line">                  &#125; catch (<span class="name">Exception</span> e) &#123;  </span><br><span class="line">                  &#125;  </span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><ul><li>首先看到的是mLurProcesses 是ArrayList<processrecord>类型.  LRU : Least Recently Used保存所有运行过的进程.  ProcessRecord进程类, 一个apk文件运行时会对应一个进程. app.thread. 此处的thread代表的是ApplicationThreadNative.java类型.  然后调用其scheduleConfigurationChanged();  查看该函数。</processrecord></li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">public</span> final void scheduleConfigurationChanged(<span class="type">Configuration</span> config)  </span><br><span class="line">           throws <span class="type">RemoteException</span> &#123;  </span><br><span class="line">       <span class="type">Parcel</span> <span class="class"><span class="keyword">data</span> = <span class="type">Parcel</span>.obtain();  </span></span><br><span class="line">       <span class="class"><span class="keyword">data</span>.writeInterfaceToken(<span class="type">IApplicationThread</span>.<span class="title">descriptor</span>);  </span></span><br><span class="line">       config.writeToParcel(<span class="class"><span class="keyword">data</span>, 0);  </span></span><br><span class="line">       mRemote.transact(<span class="type">SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION</span>, <span class="class"><span class="keyword">data</span>, null,  </span></span><br><span class="line">               <span class="type">IBinder</span>.<span class="type">FLAG_ONEWAY</span>);  </span><br><span class="line">       <span class="class"><span class="keyword">data</span>.recycle();  </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>又是通过binder调用, 所以 , binder在android中是一个很重要的概念. 此处远程调用的是ActivityThread.java中的私有内部内ApplicationThread。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">String</span> <span class="type">HEAP_COLUMN</span> = <span class="string">"%13s %8s %8s %8s %8s %8s %8s"</span>;  </span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">String</span> <span class="type">ONE_COUNT_COLUMN</span> = <span class="string">"%21s %8d"</span>;  </span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">String</span> <span class="type">TWO_COUNT_COLUMNS</span> = <span class="string">"%21s %8d %21s %8d"</span>;  </span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">String</span> <span class="type">TWO_COUNT_COLUMNS_DB</span> = <span class="string">"%21s %8d %21s %8d"</span>;  </span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">String</span> <span class="type">DB_INFO_FORMAT</span> = <span class="string">"  %8s %8s %14s %14s  %s"</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        ...  </span><br><span class="line">        public void scheduleConfigurationChanged(<span class="type">Configuration</span> config) &#123;  </span><br><span class="line">            updatePendingConfiguration(config);  </span><br><span class="line">            queueOrSendMessage(<span class="type">H</span>.<span class="type">CONFIGURATION_CHANGED</span>, config);  </span><br><span class="line">        &#125;  </span><br><span class="line">        ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而ApplicationThread中的handler的CONFIGURATION_CHANGED是调用handleConfigurationChanged()。</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final void handleConfigurationChanged(Configuration config, CompatibilityInfo compat) &#123;  </span><br><span class="line"> </span><br><span class="line">      ArrayList&lt;ComponentCallbacks2&gt; callbacks = <span class="literal">null</span>;  </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">..</span>.         <span class="built_in">..</span>.  </span><br><span class="line">      applyConfigurationToResourcesLocked(config, compat);  </span><br><span class="line">        </span><br><span class="line">      <span class="built_in">..</span>.  </span><br><span class="line">        </span><br><span class="line">      callbacks = collectComponentCallbacksLocked(<span class="literal">false</span>, config);  </span><br><span class="line">      <span class="built_in">..</span>.  </span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (callbacks != <span class="literal">null</span>) &#123;  </span><br><span class="line">          final int N = callbacks.size();  </span><br><span class="line">          <span class="keyword">for</span> (int <span class="attribute">i</span>=0; i&lt;N; i++) &#123;  </span><br><span class="line">              performConfigurationChanged(callbacks.<span class="builtin-name">get</span>(i), config);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ul><li>这个函数首先是调用applyConfigurationToResourcesLocked(). 看函数名大概可以猜想到: 将configuration应用到resources.这里configuration改变的是local 本地语言. 那而resources资源包含语言包吗？</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final boolean applyConfigurationToResourcesLocked(Configuration config,  </span><br><span class="line">           CompatibilityInfo compat) &#123;  </span><br><span class="line">         </span><br><span class="line">       int <span class="attr">changes</span> = mResConfiguration.updateFrom(config);  </span><br><span class="line">       DisplayMetrics <span class="attr">dm</span> = getDisplayMetricsLocked(<span class="literal">null</span>, <span class="literal">true</span>);  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> (compat != <span class="literal">null</span> &amp;&amp; (<span class="attr">mResCompatibilityInfo</span> == <span class="literal">null</span> ||  </span><br><span class="line">               !mResCompatibilityInfo.equals(compat))) &#123;  </span><br><span class="line">           <span class="attr">mResCompatibilityInfo</span> = compat;  </span><br><span class="line">           changes |= ActivityInfo.CONFIG_SCREEN_LAYOUT  </span><br><span class="line">                   | ActivityInfo.CONFIG_SCREEN_SIZE  </span><br><span class="line">                   | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;  </span><br><span class="line">       &#125;  </span><br><span class="line"> </span><br><span class="line">       ...  </span><br><span class="line"> </span><br><span class="line">       Resources.updateSystemConfiguration(config, dm, compat);  </span><br><span class="line"> </span><br><span class="line">       ...  </span><br><span class="line">         </span><br><span class="line">       Iterator&lt;WeakReference&lt;Resources&gt;&gt; <span class="attr">it</span> =  </span><br><span class="line">           mActiveResources.values().iterator();  </span><br><span class="line">       while (it.hasNext()) &#123;  </span><br><span class="line">           WeakReference&lt;Resources&gt; <span class="attr">v</span> = it.next();  </span><br><span class="line">           Resources <span class="attr">r</span> = v.get();  </span><br><span class="line">           <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Changing resources "</span>  </span><br><span class="line">                       + r + <span class="string">" config to: "</span> + config);  </span><br><span class="line">               r.updateConfiguration(config, dm, compat);  </span><br><span class="line">               //Slog.i(TAG, <span class="string">"Updated app resources "</span> + v.getKey()  </span><br><span class="line">               //        + <span class="string">" "</span> + r + <span class="string">": "</span> + r.getConfiguration());  </span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">               //Slog.i(TAG, <span class="string">"Removing old resources "</span> + v.getKey());  </span><br><span class="line">               it.remove();  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">       return changes != <span class="number">0</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>Resources.updateSystemConfiguration()清除一部分系统资源, 并且将config更新到Resources, 而Resources包含了一个AssetManager对象, 该对象的核心实现是在AssetManager.cpp中完成的. 然后循环清空mActivityResources资源. 再回到handleConfigurationChanged()函数, 执行完updateSystemConfiguration后, 会循环该进程的所有activity:</li></ul><p>if (callbacks != null) {</p><pre><code>    final int N = callbacks.size();    for (int i=0; i&lt;N; i++) {        performConfigurationChanged(callbacks.get(i), config);    }}</code></pre><p>再来看performConfigurationChanged的实现:</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> performConfigurationChanged(  </span><br><span class="line">            ComponentCallbacks2 cb, Configuration config) &#123;  </span><br><span class="line">        <span class="comment">// Only for Activity objects, check that they actually call up to their  </span></span><br><span class="line">        <span class="comment">// superclass implementation.  ComponentCallbacks2 is an interface, so  </span></span><br><span class="line">        <span class="comment">// we check the runtime type and act accordingly.  </span></span><br><span class="line">        Activity activity = (cb <span class="keyword">instanceof</span> Activity) ? (Activity) cb : <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">boolean</span> shouldChangeConfig = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">if</span> ((activity == <span class="keyword">null</span>) || (activity.mCurrentConfig == <span class="keyword">null</span>)) &#123;  </span><br><span class="line">            shouldChangeConfig = <span class="keyword">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// If the new config is the same as the config this Activity  </span></span><br><span class="line">            <span class="comment">// is already running with then don't bother calling  </span></span><br><span class="line">            <span class="comment">// onConfigurationChanged  </span></span><br><span class="line">            <span class="keyword">int</span> diff = activity.mCurrentConfig.diff(config);  </span><br><span class="line">            <span class="keyword">if</span> (diff != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// If this activity doesn't handle any of the config changes  </span></span><br><span class="line">                <span class="comment">// then don't bother calling onConfigurationChanged as we're  </span></span><br><span class="line">                <span class="comment">// going to destroy it.  </span></span><br><span class="line">                <span class="keyword">if</span> ((~activity.mActivityInfo.getRealConfigChanged() &amp; diff) == <span class="number">0</span>) &#123;  </span><br><span class="line">                    shouldChangeConfig = <span class="keyword">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Config callback "</span> + cb  </span><br><span class="line">                + <span class="string">": shouldChangeConfig="</span> + shouldChangeConfig);  </span><br><span class="line">        <span class="keyword">if</span> (shouldChangeConfig) &#123;  </span><br><span class="line">            cb.onConfigurationChanged(config);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!activity.mCalled) &#123;  </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(  </span><br><span class="line">                            <span class="string">"Activity "</span> + activity.getLocalClassName() +  </span><br><span class="line">                        <span class="string">" did not call through to super.onConfigurationChanged()"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">                activity.mConfigChangeFlags = <span class="number">0</span>;  </span><br><span class="line">                activity.mCurrentConfig = <span class="keyword">new</span> Configuration(config);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>该函数判断configuration是否改变, 如果改变那么shouldChangeConfig为true. 然后调用activity的onConfigurationChange(config);</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    * Called by the system when the device configuration changes while your </span></span><br><span class="line"><span class="comment">    * activity is running.  Note that this will &lt;em&gt;only&lt;/em&gt; be called if </span></span><br><span class="line"><span class="comment">    * you have selected configurations you would like to handle with the </span></span><br><span class="line"><span class="comment">    * &#123;@link android.R.attr#configChanges&#125; attribute in your manifest.  If </span></span><br><span class="line"><span class="comment">    * any configuration change occurs that is not selected to be reported </span></span><br><span class="line"><span class="comment">    * by that attribute, then instead of reporting it the system will stop </span></span><br><span class="line"><span class="comment">    * and restart the activity (to have it launched with the new </span></span><br><span class="line"><span class="comment">    * configuration). </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * &lt;p&gt;At the time that this function has been called, your Resources </span></span><br><span class="line"><span class="comment">    * object will have been updated to return resource values matching the </span></span><br><span class="line"><span class="comment">    * new configuration. </span></span><br><span class="line"><span class="comment">    *  </span></span><br><span class="line"><span class="comment">    * @param newConfig The new device configuration. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="keyword">public</span> void onConfigurationChanged(Configuration <span class="keyword">new</span><span class="type">Config</span>) &#123;  </span><br><span class="line">       mCalled = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">       mFragments.dispatchConfigurationChanged(<span class="keyword">new</span><span class="type">Config</span>);  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">if</span> (mWindow != <span class="literal">null</span>) &#123;  </span><br><span class="line">           <span class="comment">// Pass the configuration changed event to the window  </span></span><br><span class="line">           mWindow.onConfigurationChanged(<span class="keyword">new</span><span class="type">Config</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">if</span> (mActionBar != <span class="literal">null</span>) &#123;  </span><br><span class="line">           <span class="comment">// Do this last; the action bar will need to access  </span></span><br><span class="line">           <span class="comment">// view changes from above.  </span></span><br><span class="line">           mActionBar.onConfigurationChanged(<span class="keyword">new</span><span class="type">Config</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>查看注释, 大概意思是:  如果你的activity运行 , 设备信息有改变(即configuration改变)时由系统调用. 如果你在manifest.xml中配置了configChnages属性则表示有你自己来处理configuration change. 否则就重启当前这个activity.  而重启之前, 旧的resources已经被清空, 那么就会装载新的资源, 整个过程就完成了语言切换后 , 能够让所有app使用新的语言。</li><li>上面这些就是对Android 系统里面的语言切换进行了源码分析，就先分析到这里；有些东西我也不是很看懂，能力有限~ </li><li>明天我们再来分析怎么来实现Android 系统语言切换的功能。 <a href="http://blog.csdn.net/u011974987/article/details/50801770" target="_blank" rel="noopener"> Android 切换系统语言功能实现</a>！</li><li>O(∩_∩)O~  打哈欠了睡觉了~</li></ul><blockquote><p>转载请标明出处：  <a href="http://blog.csdn.net/u011974987/article/details/50793343" target="_blank" rel="noopener">http://blog.csdn.net/u011974987/article/details/50793343</a> </p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 切换系统语言功能实现（下）</title>
      <link href="/2016/04/12/android-change-language_02/"/>
      <url>/2016/04/12/android-change-language_02/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p>简单介绍下这个需求的缘由，这段时间因公司业务需要，其中有一项“设置系统语言”功能，就是在使用APP的过程中，动态的去切换整个Android机器的语言，具体参照手机设置页面有语言切换功能。期初想来是很简单的事情嘛，不就是个简单的资源国际化嘛，strings.xml资源文件一整还不给OK？真正动起手来就真不是这么一回事了，国际化是没问题，但是怎样能更改所有页面的文字资源呢，这是一个问题。下面介绍下网上找的几个方案。</p><h4 id="一、API欺骗"><a href="#一、API欺骗" class="headerlink" title="一、API欺骗"></a>一、API欺骗</h4><p>   烧制到手机中的android.jar包含了Android所需的各种类与方法；而供开发者使用的android.jar只是其中的一部分。API欺骗是指在应用中去模拟未公开的类和方法让应用编译通过并生成APK，然而在应用实际运行中调用的却仍是烧制到手机中真实的android.jar。<br> <a id="more"></a></p><h4 id="二、使用Java反射机制"><a href="#二、使用Java反射机制" class="headerlink" title="二、使用Java反射机制"></a>二、使用Java反射机制</h4><pre><code>IActivityManager与ActivityManagerNative都是非公开类，使用Java反射去调用其中的方法。</code></pre><p>但是这个弊端是显而易见的，上述两种方法都是去更改系统的语言的类型，功能和你去设置页面去设置语言类型的效果一样。发现对当前系统设置了新的Locale后，不单自己的应用语系改变了，系统所有的应用语系都改变了，这正是我们所需要的。折腾了下下这个很2的问题。<strong>网上放的方法比较旧， Android5.1的话， 设置后当时生效， 重启后就失效了。</strong></p><h4 id="核心代码如下："><a href="#核心代码如下：" class="headerlink" title="核心代码如下："></a><strong>核心代码如下：</strong></h4><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO&lt;更新系统语言&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @author Xiho</span></span><br><span class="line"><span class="comment"> * @versionCode 1 &lt;每次修改提交前+1&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">public <span class="keyword">class</span> LanguageUtils &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void updateLanguage(Locale locale) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object objIActMag, objActMagNative<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> clzIActMag = <span class="keyword">Class</span>.forName(<span class="string">"android.app.IActivityManager"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> clzActMagNative = <span class="keyword">Class</span></span><br><span class="line">.forName(<span class="string">"android.app.ActivityManagerNative"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//amn = ActivityManagerNative.getDefault(); </span></span><br><span class="line">Method mtdActMagNative<span class="built_in">$getDefault</span> = clzActMagNative</span><br><span class="line">.getDeclaredMethod(<span class="string">"getDefault"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">objIActMag = mtdActMagNative<span class="built_in">$getDefault</span>.invoke(clzActMagNative)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// objIActMag = amn.getConfiguration();  </span></span><br><span class="line">Method mtdIActMag<span class="built_in">$getConfiguration</span> = clzIActMag</span><br><span class="line">.getDeclaredMethod(<span class="string">"getConfiguration"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Configuration config = (Configuration) mtdIActMag<span class="built_in">$getConfiguration</span></span><br><span class="line">.invoke(objIActMag)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set the locale to the new value  </span></span><br><span class="line">config.locale = locale<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//持久化   config.userSetLocale = true; </span></span><br><span class="line"><span class="keyword">Class</span> clzConfig = <span class="keyword">Class</span></span><br><span class="line">.forName(<span class="string">"android.content.res.Configuration"</span>)<span class="comment">;</span></span><br><span class="line">java.lang.reflect.Field userSetLocale = clzConfig</span><br><span class="line">.getField(<span class="string">"userSetLocale"</span>)<span class="comment">;</span></span><br><span class="line">userSetLocale.<span class="keyword">set</span>(config, true)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处需要声明权限:android.permission.CHANGE_CONFIGURATION</span></span><br><span class="line"><span class="comment">// 会重新调用 onCreate();</span></span><br><span class="line"><span class="keyword">Class</span>[] clzParams = &#123; Configuration.<span class="keyword">class</span> &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objIActMag.updateConfiguration(config);</span></span><br><span class="line">Method mtdIActMag<span class="built_in">$updateConfiguration</span> = clzIActMag</span><br><span class="line">.getDeclaredMethod(<span class="string">"updateConfiguration"</span>, clzParams)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">mtdIActMag<span class="built_in">$updateConfiguration</span>.invoke(objIActMag, config)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">BackupManager.dataChanged(<span class="string">"com.android.providers.settings"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们利用JAVA的反射机制，调用那些隐藏的方法就可以实现了。</p><ul><li><strong>需要注意的是</strong>调用此方法：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objIActMag.updateConfiguration(config);</span></span><br><span class="line">mtdIActMag$updateConfiguration.invoke(objIActMag, <span class="built_in">config</span>);</span><br></pre></td></tr></table></figure><p>需要加上权限：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android<span class="selector-class">.permission</span><span class="selector-class">.CHANGE_CONFIGURATION</span></span><br></pre></td></tr></table></figure><p>并且此处会重新调用onCreate方法，我就在这个地方处被坑了一把。（如果调用此方法的时候做了一些逻辑，就注意下）。</p><p>不同的地方在添加了</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">clzConfig </span>= Class.forName(<span class="string">"android.content.res.Configuration"</span>)<span class="comment">; </span></span><br><span class="line"><span class="keyword">java.lang.reflect.Field </span>userSetLocale = <span class="keyword">clzConfig.getField("userSetLocale"); </span></span><br><span class="line">userSetLocale<span class="meta">.set</span>(<span class="built_in">config</span>, true)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Debug发现的逻辑是：<br>1： 持久化保存下来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">SystemProperties</span><span class="selector-class">.set</span>("<span class="selector-tag">persist</span><span class="selector-class">.sys</span><span class="selector-class">.language</span>", <span class="selector-tag">l</span><span class="selector-class">.getLanguage</span>());</span><br><span class="line"><span class="selector-tag">SystemProperties</span><span class="selector-class">.set</span>("<span class="selector-tag">persist</span><span class="selector-class">.sys</span><span class="selector-class">.country</span>", <span class="selector-tag">l</span><span class="selector-class">.getCountry</span>());</span><br></pre></td></tr></table></figure><p>2： 开机AndroidRuntime读取这个属性， 更新系统之前的属性。估计是为了方便跑测试的Case添加的这个逻辑。</p><p><strong> 最后声明：</strong></p><p>既然是更改系统的配置当然你的签名也应该是系统签名和sharedUserId。不然会类似以下的错误！</p><p>error：</p><font color="#ff0000" size="5" face="黑体">java.lang.SecurityException: Permission Denial: updateConfiguration() from pid=31594, uid=10099 requires android.permission.CHANGE_CONFIGURATION</font><p>各位都注意下吧~</p><p>附上GitHub源码：<a href="https://github.com/git-xuhao/SwitchLanguage" target="_blank" rel="noopener">SwitchLanguage</a>；</p><h3 id="welcome-everyone’s-Star-and-fork！"><a href="#welcome-everyone’s-Star-and-fork！" class="headerlink" title="welcome everyone’s Star and fork！"></a><strong>welcome everyone’s Star and fork！</strong></h3><blockquote><p>转载请标明出处： <a href="http://blog.csdn.net/u011974987/article/details/50801770" target="_blank" rel="noopener">http://blog.csdn.net/u011974987/article/details/50801770</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 5.1 Settings源码简要分析</title>
      <link href="/2016/04/11/android-5.1-settings/"/>
      <url>/2016/04/11/android-5.1-settings/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p><strong>先声明：</strong>本人工作快两年了，仍是菜鸟级别的，惭愧啊！以前遇到好多知识点都没有记录下来，感觉挺可惜的，现在有机会接触Android 源码。我们一个Android组的搞Setting，我觉得是得写得东西，毕竟才接触，现在只能看一段时间代码，就先记录下一些收获吧，说多了就是泪~本文主要针对L平台上Settings模块正常启动流程做一个简要分析，并试着分析一下Settings下面某选项的实现。<br><a id="more"></a></p><h3 id="Setting-简介"><a href="#Setting-简介" class="headerlink" title="Setting 简介"></a><strong>Setting 简介</strong></h3><p>在之前的KK平台上Settings模块的第一个Activity名字为Settings，其继承的是PreferenceActivity，设置的每一个选项都是对应的一个Header对象，并且Header对象允许显示switch控件，button控件，checkbox控件等。如下图1.1，WLAN和蓝牙上使用到了switch开关。但在L上面，WLAN和蓝牙的这两个开关已经去掉了，如图1.2，在Settings模块的首个页面似乎就只是一个普通的Listview，那它用的还是不是Header呢？或者说取而代之的是什么呢？继续往下看吧~</p><p><img src="http://img.blog.csdn.net/20160329120918137" alt="图片1.1"><br><strong>图片-1.1</strong><br><img src="http://img.blog.csdn.net/20160329121723202" alt="这里写图片描述"><br><strong>图片-1.2</strong></p><h3 id="L-Settings-模块首界面初始化流程"><a href="#L-Settings-模块首界面初始化流程" class="headerlink" title="L Settings 模块首界面初始化流程"></a><strong>L Settings 模块首界面初始化流程</strong></h3><p>L Settings模块首界面为Settings，继承自SettingsActivity，SettingsActivity继承自Activity。</p><p>首先看一下Settings.java代码可以发现它没有重写任何SettingsActiviy的方法，也没有增加任何自己的方法，唯独增加了许多静态内部类，如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Top-level Settings activity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Settings</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Settings subclasses for launching independently.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">BluetoothSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">WirelessSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">SimSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">TetherSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">VpnSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">DateTimeSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">StorageSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">WifiSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">WifiP2pSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">InputMethodAndLanguageSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">KeyboardLayoutPickerActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">InputMethodAndSubtypeEnablerActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">VoiceInputSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">SpellCheckersSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">LocalePickerActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">UserDictionarySettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">HomeSettingsActivity</span> <span class="keyword">extends</span> <span class="title">SettingsActivity</span> </span>&#123; <span class="comment">/* empty */</span> &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看注释可以知道，这些子类是为了启动特定独立的Settings选项而创建的，例如在某个应用里需要设置无线那么只需要启动 WirelessSettingsActivity 就可以了。</p><p>所以Settings模块的启动流程直接看SettingsActiviy就行了。</p><ol><li><strong>SettingsActivity.onCreate方法</strong><br>onCreate方法是Activity的生命周期第一步，看看 SettingsActivity在这里都做了些什么？</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Should happen before any <span class="keyword">call</span> <span class="keyword">to</span> getIntent()</span><br><span class="line"></span><br><span class="line">    getMetaData();</span><br></pre></td></tr></table></figure><p>这个方法用来获得Activity的额外数据mFragmentClass，如果可以获得这个数据，那么下面会去显示mFragmentClass对应的Activity。直接启动Settings模块不会获得这个数据。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mIsShowingDashboard</span> = className.equals(Settings.class.getName())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这一步很重要，因为我们是从Settings这个Activity过来的，所以这里的 mIsShowingDashboard 为 true 。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a "Sub Settings" when:</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// - this is a real SubSettings</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// - or :settings:show_fragment_as_subsetting is passed to the Intent</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> isSubSettings = className.equals(SubSettings.<span class="keyword">class</span>.getName()) ||</span><br><span class="line"></span><br><span class="line">             intent.getBooleanExtra(EXTRA_SHOW_FRAGMENT_AS_SUBSETTING, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这个判断很重要但很明显这时isSubSettings的值是fasle，暂时忽略。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">setContentView</span>(<span class="selector-tag">mIsShowingDashboard</span> ?</span><br><span class="line"></span><br><span class="line">              <span class="selector-tag">R</span><span class="selector-class">.layout</span><span class="selector-class">.settings_main_dashboard</span> : <span class="selector-tag">R</span><span class="selector-class">.layout</span><span class="selector-class">.settings_main_prefs</span>);</span><br></pre></td></tr></table></figure><p>前面知道这里的 mIsShowingDashboard为true，所以这里使用的布局文件为R.layout.settings_main_dashboard。settings_main_dashboard.xml文件如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:<span class="attribute">android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line"></span><br><span class="line">             android:<span class="attribute">id</span>=<span class="string">"@+id/main_content"</span></span><br><span class="line"></span><br><span class="line">             android:<span class="attribute">layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line"></span><br><span class="line">             android:<span class="attribute">layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line"></span><br><span class="line">             android:<span class="attribute">background</span>=<span class="string">"@color/dashboard_background_color"</span></span><br><span class="line"></span><br><span class="line">             /&gt;</span><br></pre></td></tr></table></figure><p>由于mIsShowingDashboard为true，直接走到下面这段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">else</span> <span class="string">&#123;</span></span><br><span class="line"></span><br><span class="line">              <span class="string">//</span> <span class="literal">No</span> <span class="string">UP</span> <span class="string">affordance</span> <span class="string">if</span> <span class="string">we</span> <span class="string">are</span> <span class="string">displaying</span> <span class="string">the</span> <span class="string">main</span> <span class="string">Dashboard</span></span><br><span class="line"></span><br><span class="line">              <span class="string">mDisplayHomeAsUpEnabled</span> <span class="string">=</span> <span class="literal">false</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">              <span class="string">//</span> <span class="string">Show</span> <span class="string">Search</span> <span class="string">affordance</span></span><br><span class="line"></span><br><span class="line">              <span class="string">mDisplaySearch</span> <span class="string">=</span> <span class="literal">true</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">              <span class="string">mInitialTitleResId</span> <span class="string">=</span> <span class="string">R.string.dashboard_title;</span></span><br><span class="line"></span><br><span class="line">              <span class="string">switchToFragment(DashboardSummary.class.getName(),</span> <span class="literal">null</span><span class="string">,</span> <span class="literal">false</span><span class="string">,</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"></span><br><span class="line">                      <span class="string">mInitialTitleResId,</span> <span class="string">mInitialTitle,</span> <span class="literal">false</span><span class="string">);</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这里看到switchToFragment这个方法，可以知道这里是要切换DashboardSummary这个Fragment.</p><p>接下来就看看DashboardSummary是个什么玩意？</p><p>dashboard中文意思是仪表盘，这里是指DashboardSummary就是用来显示Settings所有选项的。</p><p>在DashboardSummary的onCreateView里加载了这个布局文件R.layout.dashboard</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;ScrollView xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line"></span><br><span class="line">    android:id=<span class="string">"@+id/dashboard"</span></span><br><span class="line"></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line"></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line"></span><br><span class="line">    android:scrollbarStyle=<span class="string">"outsideOverlay"</span></span><br><span class="line"></span><br><span class="line">    android:clipToPadding=<span class="string">"false"</span>&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        &lt;LinearLayout</span><br><span class="line"></span><br><span class="line">                android:id=<span class="string">"@+id/dashboard_container"</span></span><br><span class="line"></span><br><span class="line">                android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line"></span><br><span class="line">                android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line"></span><br><span class="line">                android:layout_gravity=<span class="string">"center_horizontal"</span></span><br><span class="line"></span><br><span class="line">                android:paddingStart=<span class="string">"@dimen/dashboard_padding_start"</span></span><br><span class="line"></span><br><span class="line">                android:paddingEnd=<span class="string">"@dimen/dashboard_padding_end"</span></span><br><span class="line"></span><br><span class="line">                android:paddingTop=<span class="string">"@dimen/dashboard_padding_top"</span></span><br><span class="line"></span><br><span class="line">                android:paddingBottom=<span class="string">"@dimen/dashboard_padding_bottom"</span></span><br><span class="line"></span><br><span class="line">                android:orientation=<span class="string">"vertical"</span></span><br><span class="line"></span><br><span class="line">                /&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/ScrollView&gt;</span></span><br></pre></td></tr></table></figure><p>看了上面的布局文件可以知道Settings的选项视图应该就是显示在dashboard_container中了。</p><p>  <br><br>DashboardSummary走完onCreateView方法后会走onResume,然后一路下来又会调到SettingsActivity的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">loadCategoriesFromResource</span>(<span class="selector-tag">R</span><span class="selector-class">.xml</span><span class="selector-class">.dashboard_categories</span>, <span class="selector-tag">categories</span>);</span><br></pre></td></tr></table></figure><p>这一步是通过 R.xml.dashboard_categories来加载categories，这里的categorys为ArrayList<dashboardcategory> mCategories。接着来看看dashboard_categories.xml这个文件吧</dashboardcategory></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!-- Copyright (C) 2014 The Android Open Source Project</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">     you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">     You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">     distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">     See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">     limitations under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dashboard-categories</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- WIRELESS and NETWORKS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dashboard-category</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/wireless_section"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/header_category_wireless_networks"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Wifi --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/wifi_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/wifi_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.wifi.WifiSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_wireless"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--HetComm--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/hetcomm_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_hetcomm"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/hetcom_setting_title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent</span> <span class="attr">android:action</span>=<span class="string">"com.android.settings.HETCOMM_SETTINGS"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dashboard-tile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Bluetooth --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/bluetooth_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/bluetooth_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.bluetooth.BluetoothSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_bluetooth2"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">&lt;!-- Hotknot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/hotknot_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/hotknot_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.mediatek.settings.hotknot.HotKnotSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_hotknot"</span> </span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SIM Cards --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/sim_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/sim_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.sim.SimSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_sim_sd"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Data Usage --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/data_usage_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/data_usage_summary_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.DataUsageSummary"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_data_usage"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Operator hook --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/operator_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.WirelessSettings"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent</span> <span class="attr">android:action</span>=<span class="string">"com.android.settings.OPERATOR_APPLICATION_SETTING"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dashboard-tile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Other wireless and network controls --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/wireless_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/radio_controls_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.WirelessSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_more"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dashboard-category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DEVICE --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dashboard-category</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/device_section"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/header_category_device"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Home --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/home_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/home_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.HomeSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_home"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Display --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/display_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/display_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.DisplaySettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_display"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Notifications --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/notification_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/notification_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.mediatek.audioprofile.AudioProfileSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_notifications"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Storage --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/storage_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/storage_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.deviceinfo.Memory"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_storage"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Battery --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/battery_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/power_usage_summary_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.fuelgauge.PowerUsageSummary"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_battery"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Application Settings --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/application_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/applications_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.applications.ManageApplications"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_applications"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Manage users --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/user_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/user_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.users.UserSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_multiuser"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Manage NFC payment apps --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/nfc_payment_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/nfc_payment_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.nfc.PaymentSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_nfc_payment"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Manufacturer hook --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/manufacturer_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.WirelessSettings"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent</span> <span class="attr">android:action</span>=<span class="string">"com.android.settings.MANUFACTURER_APPLICATION_SETTING"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dashboard-tile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dashboard-category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- PERSONAL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dashboard-category</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/personal_section"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"@string/header_category_personal"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Location --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/location_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/location_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.location.LocationSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_location"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Security --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/security_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/security_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.SecuritySettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_security"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Account --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/account_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/account_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.accounts.AccountSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_accounts"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Language --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/language_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/language_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.inputmethod.InputMethodAndLanguageSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_language"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Backup and reset --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/privacy_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/privacy_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.PrivacySettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_backup"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dashboard-category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SYSTEM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dashboard-category</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/system_section"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"@string/header_category_system"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Date &amp; Time --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/date_time_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/date_and_time_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.DateTimeSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_date_time"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Scheduled power on&amp;off--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/power_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_schpwronoff"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/schedule_power_on_off_settings_title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent</span> <span class="attr">android:action</span>=<span class="string">"com.android.settings.SCHEDULE_POWER_ON_OFF_SETTING"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dashboard-tile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Accessibility feedback --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/accessibility_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/accessibility_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.accessibility.AccessibilitySettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_accessibility"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Print --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/print_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/print_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.print.PrintSettingsFragment"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_print"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Development --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/development_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/development_settings_title"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.DevelopmentSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_development"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- About Device --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dashboard-tile</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/about_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:title</span>=<span class="string">"@string/about_settings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:fragment</span>=<span class="string">"com.android.settings.DeviceInfoSettings"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_settings_about"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dashboard-category</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dashboard-categories</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据这个文件我们可以知道了，所谓的dashboard就是Settings模块首界面的一个抽象。而dashboard-categorys则是设置分类集合的抽象，而dashboard-category是分类的抽象，dashboard-tile就是分类下每个选项的抽象了。代码中的List<dashboardcategory>对应dashboard-categorys， DashboardCategory对应dashboard-category，而dashboard-tile则对因代码中的DashboardTile。</dashboardcategory></p><p>当加载完这些对象后SettingsActivity会将得到的 mCategories 返回给DashboardSummary来初始化Settings的设置选项。</p><p>下面这段代码就是DashboardSummary.rebuildUI()中完成界面的初始化</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> Resources res = getResources();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     mDashboard.removeAllViews();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     List&lt;DashboardCategory&gt; categories =</span><br><span class="line"></span><br><span class="line">             ((SettingsActivity) context).getDashboardCategories(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">count</span> = categories.<span class="keyword">size</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="keyword">count</span>; n++) &#123;</span><br><span class="line"></span><br><span class="line">         DashboardCategory category = categories.get(n);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         View categoryView = mLayoutInflater.inflate(R.layout.dashboard_category, mDashboard,</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         TextView categoryLabel = (TextView) categoryView.findViewById(R.id.category_title);</span><br><span class="line"></span><br><span class="line">         categoryLabel.setText(category.getTitle(res));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         ViewGroup categoryContent =</span><br><span class="line"></span><br><span class="line">                 (ViewGroup) categoryView.findViewById(R.id.category_content);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> tilesCount = category.getTilesCount();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tilesCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">             DashboardTile tile = category.getTile(i);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">             DashboardTileView tileView = <span class="keyword">new</span> DashboardTileView(context);</span><br><span class="line"></span><br><span class="line">             updateTileView(context, res, tile, tileView.getImageView(),</span><br><span class="line"></span><br><span class="line">                     tileView.getTitleTextView(), tileView.getStatusTextView());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">             tileView.setTile(tile);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">             categoryContent.addView(tileView);</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">         <span class="comment">// Add the category</span></span><br><span class="line"></span><br><span class="line">         mDashboard.addView(categoryView);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这段代码我就不具体分析了，逻辑很简单，遍历categories这个列表来获取DashboardCategory对象，将所有DashboardCategory对象和DashboardCategory对象中的DashboardTile对象转化为视图对象并添加到主视图对象mDashboard中。</p><p>到这里SettingsActivity的onCreate方法就算结束了。总结一下，</p><p>   <strong>1.onCreate完成的任务是切换DashboardSmmary这个Fragment，然后从dashboard_categories.xml中读取预先配置好的文件来初始化Settings的首界面视图。</strong><br>   <strong>2.L中舍弃了Header类，取而代之的是DashboardCategory和DashboardTile类。</strong></p><blockquote><p>转载请注明出处，谢谢~: <a href="http://blog.csdn.net/u011974987/article/details/51004854" target="_blank" rel="noopener">http://blog.csdn.net/u011974987/article/details/51004854</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 更改 Gun Make 版本</title>
      <link href="/2016/04/10/change-gun-make-code/"/>
      <url>/2016/04/10/change-gun-make-code/</url>
      <content type="html"><![CDATA[<h3 id="1：Gun-Make-下载地址"><a href="#1：Gun-Make-下载地址" class="headerlink" title="1：Gun Make 下载地址"></a>1：Gun Make 下载地址</h3><p>ftp://ftp.gnu.org/gnu/make/</p><h3 id="2：-下载并解压-make3-8-1-tar-gz"><a href="#2：-下载并解压-make3-8-1-tar-gz" class="headerlink" title="2： 下载并解压 make3.8.1.tar.gz"></a>2： 下载并解压 make3.8.1.tar.gz</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf make3.<span class="number">8.1</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><h3 id="3：-编译Make"><a href="#3：-编译Make" class="headerlink" title="3： 编译Make"></a>3： 编译Make</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><h3 id="4：-安装Make"><a href="#4：-安装Make" class="headerlink" title="4： 安装Make"></a>4： 安装Make</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 15.10 下载Android5.1代码环境搭建</title>
      <link href="/2016/04/10/android-source-download/"/>
      <url>/2016/04/10/android-source-download/</url>
      <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a><strong>概述：</strong></h2><p>作为一个Android开发者，想要自己提升一个阶段，想深入了解 Android 相关的知识，Activity 是工作流程是怎样的？ View 是怎样绘制的？ 怎样修改一些系统相关的应用？等等，就得要深入Android 源代码~所以就要先获取Android源码：</p><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><ol><li>装一个Ubuntu系统（<a href="http://www.ubuntu.com/download/desktop）电脑的内存最好有" target="_blank" rel="noopener">http://www.ubuntu.com/download/desktop）电脑的内存最好有</a> 8 G，因为编译 Android 源码很吃电脑内存，特别是在 4.4 以后的版本，电脑内存大点，比较保险，编译一次源码要好几个小时，要因为内存原因，太让人郁闷了。<br>ps:( ubuntu装完后把系统软件全都更新一下)</li><li><p>一个翻墙vpn（<a href="https://www.trueyt.com/）" target="_blank" rel="noopener">https://www.trueyt.com/）</a></p><a id="more"></a></li></ol><h3 id="编译环境的部署："><a href="#编译环境的部署：" class="headerlink" title="编译环境的部署："></a>编译环境的部署：</h3><p>   访问： <a href="http://source.android.com/source/initializing.html" target="_blank" rel="noopener">http://source.android.com/source/initializing.html</a></p><h2 id="1、-Installing-the-JDK"><a href="#1、-Installing-the-JDK" class="headerlink" title="1、 Installing the JDK"></a><strong>1、 Installing the JDK</strong></h2><p>Android 5.0 编译需要 Open Java7 版本<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">$ sudo apt-<span class="builtin-name">get</span> install openjdk-7-jdk</span><br></pre></td></tr></table></figure></p><p>Android 4.4 编译需要 Sun Java6 版本</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo<span class="built_in"> add-apt-repository </span>ppa:webupd8team/java</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install oracle-java6-set-default</span><br></pre></td></tr></table></figure><p>切换 Java 的方法 (上面 2 个根据你的需要安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --config java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo update-alternatives --config javac</span></span><br></pre></td></tr></table></figure><h2 id="2、-Installing-required-packages"><a href="#2、-Installing-required-packages" class="headerlink" title="2、   Installing required packages"></a><strong>2、   Installing required packages</strong></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install bison g++-multilib git gperf libxml2-utils <span class="keyword">make</span> <span class="keyword">python</span>-networkx zlib1g-de<span class="variable">v:i386</span> zip</span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-de<span class="variable">v:i386</span> x11proto-core-dev libx11-de<span class="variable">v:i386</span> libreadline6-de<span class="variable">v:i386</span> libgl1-mesa-glx:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos <span class="keyword">python</span>-markdown libxml2-utils xsltproc zlib1g-de<span class="variable">v:i386</span></span><br><span class="line">$ sudo <span class="keyword">ln</span> -s /usr/lib/i386-linux-gnu/mesa/libGL.<span class="keyword">so</span>.<span class="number">1</span> /usr/lib/i386-linux-gnu/libGL.<span class="keyword">so</span></span><br></pre></td></tr></table></figure><p><strong> Notes！！不同的 Ubuntu 版本可能不能，安装这些编译工具可能不成功，也不用管，在你编译的时候，可能会出错，根据错误日志去解决就行了。</strong></p><p>配置 USB 访问 (下面的都可能需要翻墙了)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -S -O - http://source.android.com/<span class="built_in">source</span>/51-android.rules | sed <span class="string">"s/&lt;username&gt;/<span class="variable">$USER</span>/"</span> |sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo udevadm control --reload-rules</span></span><br></pre></td></tr></table></figure><p>安装 repo ， repo 是 git 的管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> PATH=~/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod a+x ~/bin/repo</span></span><br></pre></td></tr></table></figure><h3 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h3><p>（我这边添加的是内置服务器，从我们自己的服务器下载的代码很快，一般一个小时左右就下载完了！）</p><ul><li>建立一个目录来存放 Android 源码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir android_source_5.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> android_source_5.0</span></span><br></pre></td></tr></table></figure><ul><li>初始化下载</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://<span class="keyword">android.googlesource.com/platform/manifest </span>-<span class="keyword">b </span></span><br><span class="line">你要同步的源码(<span class="keyword">android-5.0.1_r1)</span></span><br></pre></td></tr></table></figure><ul><li>在初始化时，可能要配置下git的emai 信息：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"you@example.com"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br></pre></td></tr></table></figure><ul><li>Downloading the Android Source Tree同步源码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> repo sync</span></span><br></pre></td></tr></table></figure><p>这个命令如果代理断了需要重新执行这个命令同步代码(也可以写一个shell 脚本)</p><p>当控制台显示 successful的时候恭喜你代码同步成功了~控制台显示如下：</p><h3 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h3><p>进入到你DownLoad 源码的目录下，执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> android_source_5.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> build/envsetup.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> choosecombo release aosp_flo eng</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j4</span></span><br></pre></td></tr></table></figure><p>编译的时间是漫长的，中间还可能出错，所以我们需要随时陪同，中间还可能需要解错，当你看见屏幕的最下面出现 Successful 的时候，恭喜你，源码已经编译成功。如下图：<br><img src="http://img.blog.csdn.net/20160325114724525" alt="这里写图片描述"></p><blockquote><p>转载请注明出处：<a href="http://blog.csdn.net/u011974987/article/details/50978291" target="_blank" rel="noopener">http://blog.csdn.net/u011974987/article/details/50978291</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> AOSP </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
